{"version":3,"file":"bundle.umd.js","sources":["../../apollo-client/src/core/networkStatus.ts","../../apollo-client/node_modules/zen-observable-ts/src/zenObservable.ts","../../apollo-client/node_modules/apollo-link/src/linkUtils.ts","../../apollo-client/node_modules/apollo-link/src/link.ts","../../apollo-client/src/util/Observable.ts","../../apollo-client/src/errors/ApolloError.ts","../../apollo-client/src/core/types.ts","../../apollo-client/src/core/ObservableQuery.ts","../../apollo-client/node_modules/apollo-link-dedup/src/dedupLink.ts","../../apollo-client/src/scheduler/scheduler.ts","../../apollo-client/src/data/mutations.ts","../../apollo-client/src/data/queries.ts","../../apollo-client/src/core/QueryManager.ts","../../apollo-client/src/data/store.ts","../../apollo-client/src/version.ts","../../apollo-client/src/ApolloClient.ts","../node_modules/zen-observable-ts/src/zenObservable.ts","../node_modules/apollo-link/src/linkUtils.ts","../node_modules/apollo-link/src/link.ts","../../apollo-cache/src/utils.ts","../../apollo-cache/src/cache.ts","../../apollo-cache-inmemory/src/fragmentMatcher.ts","../../apollo-cache-inmemory/src/objectCache.ts","../../apollo-cache-inmemory/src/writeToStore.ts","../../graphql-anywhere/src/graphql.ts","../../apollo-cache-inmemory/src/readFromStore.ts","../../apollo-cache-inmemory/src/recordingCache.ts","../../apollo-cache-inmemory/src/inMemoryCache.ts","../node_modules/apollo-link-http-common/src/index.ts","../node_modules/apollo-link-http/src/httpLink.ts","../node_modules/apollo-link-state/src/utils.ts","../node_modules/apollo-link-state/src/index.ts","../node_modules/apollo-link-error/src/index.ts","../src/index.ts"],"sourcesContent":["/**\n * The current status of a queryâ€™s execution in our system.\n */\nexport enum NetworkStatus {\n  /**\n   * The query has never been run before and the query is now currently running. A query will still\n   * have this network status even if a partial data result was returned from the cache, but a\n   * query was dispatched anyway.\n   */\n  loading = 1,\n\n  /**\n   * If `setVariables` was called and a query was fired because of that then the network status\n   * will be `setVariables` until the result of that query comes back.\n   */\n  setVariables = 2,\n\n  /**\n   * Indicates that `fetchMore` was called on this query and that the query created is currently in\n   * flight.\n   */\n  fetchMore = 3,\n\n  /**\n   * Similar to the `setVariables` network status. It means that `refetch` was called on a query\n   * and the refetch request is currently in flight.\n   */\n  refetch = 4,\n\n  /**\n   * Indicates that a polling query is currently in flight. So for example if you are polling a\n   * query every 10 seconds then the network status will switch to `poll` every 10 seconds whenever\n   * a poll request has been sent but not resolved.\n   */\n  poll = 6,\n\n  /**\n   * No request is in flight for this query, and no errors happened. Everything is OK.\n   */\n  ready = 7,\n\n  /**\n   * No request is in flight for this query, but one or more errors were detected.\n   */\n  error = 8,\n}\n\n/**\n * Returns true if there is currently a network request in flight according to a given network\n * status.\n */\nexport function isNetworkRequestInFlight(\n  networkStatus: NetworkStatus,\n): boolean {\n  return networkStatus < 7;\n}\n","import zenObservable from 'zen-observable';\n\nnamespace Observable {\n\n}\n\nimport { ZenObservable } from './types';\n\nexport { ZenObservable };\n\nexport type Observer<T> = ZenObservable.Observer<T>;\nexport type Subscriber<T> = ZenObservable.Subscriber<T>;\nexport type ObservableLike<T> = ZenObservable.ObservableLike<T>;\n\nexport const Observable: {\n  new <T>(subscriber: Subscriber<T>): Observable<T>;\n  from<R>(\n    observable: Observable<R> | ZenObservable.ObservableLike<R> | ArrayLike<R>,\n  ): Observable<R>;\n  of<R>(...args: Array<R>): Observable<R>;\n} = <any>zenObservable;\n\nexport interface Observable<T> {\n  subscribe(\n    observerOrNext: ((value: T) => void) | ZenObservable.Observer<T>,\n    error?: (error: any) => void,\n    complete?: () => void,\n  ): ZenObservable.Subscription;\n\n  forEach(fn: (value: T) => void): Promise<void>;\n\n  map<R>(fn: (value: T) => R): Observable<R>;\n\n  filter(fn: (value: T) => boolean): Observable<T>;\n\n  reduce<R = T>(\n    fn: (previousValue: R | T, currentValue: T) => R | T,\n    initialValue?: R | T,\n  ): Observable<R | T>;\n\n  flatMap<R>(fn: (value: T) => ZenObservable.ObservableLike<R>): Observable<R>;\n\n  from<R>(\n    observable: Observable<R> | ZenObservable.ObservableLike<R> | ArrayLike<R>,\n  ): Observable<R>;\n  of<R>(...args: Array<R>): Observable<R>;\n}\n","import { getOperationName } from 'apollo-utilities';\nimport Observable from 'zen-observable-ts';\nimport { print } from 'graphql/language/printer';\n\nimport { GraphQLRequest, Operation } from './types';\nimport { ApolloLink } from './link';\n\nexport function validateOperation(operation: GraphQLRequest): GraphQLRequest {\n  const OPERATION_FIELDS = [\n    'query',\n    'operationName',\n    'variables',\n    'extensions',\n    'context',\n  ];\n  for (let key of Object.keys(operation)) {\n    if (OPERATION_FIELDS.indexOf(key) < 0) {\n      throw new Error(`illegal argument: ${key}`);\n    }\n  }\n\n  return operation;\n}\n\nexport class LinkError extends Error {\n  public link: ApolloLink;\n  constructor(message?: string, link?: ApolloLink) {\n    super(message);\n    this.link = link;\n  }\n}\n\nexport function isTerminating(link: ApolloLink): boolean {\n  return link.request.length <= 1;\n}\n\nexport function toPromise<R>(observable: Observable<R>): Promise<R> {\n  let completed = false;\n  return new Promise<R>((resolve, reject) => {\n    observable.subscribe({\n      next: data => {\n        if (completed) {\n          console.warn(\n            `Promise Wrapper does not support multiple results from Observable`,\n          );\n        } else {\n          completed = true;\n          resolve(data);\n        }\n      },\n      error: reject,\n    });\n  });\n}\n\n// backwards compat\nexport const makePromise = toPromise;\n\nexport function fromPromise<T>(promise: Promise<T>): Observable<T> {\n  return new Observable<T>(observer => {\n    promise\n      .then((value: T) => {\n        observer.next(value);\n        observer.complete();\n      })\n      .catch(observer.error.bind(observer));\n  });\n}\n\nexport function fromError<T>(errorValue: any): Observable<T> {\n  return new Observable<T>(observer => {\n    observer.error(errorValue);\n  });\n}\n\nexport function transformOperation(operation: GraphQLRequest): GraphQLRequest {\n  const transformedOperation: GraphQLRequest = {\n    variables: operation.variables || {},\n    extensions: operation.extensions || {},\n    operationName: operation.operationName,\n    query: operation.query,\n  };\n\n  // best guess at an operation name\n  if (!transformedOperation.operationName) {\n    transformedOperation.operationName =\n      typeof transformedOperation.query !== 'string'\n        ? getOperationName(transformedOperation.query)\n        : '';\n  }\n\n  return transformedOperation as Operation;\n}\n\nexport function createOperation(\n  starting: any,\n  operation: GraphQLRequest,\n): Operation {\n  let context = { ...starting };\n  const setContext = next => {\n    if (typeof next === 'function') {\n      context = { ...context, ...next(context) };\n    } else {\n      context = { ...context, ...next };\n    }\n  };\n  const getContext = () => ({ ...context });\n\n  Object.defineProperty(operation, 'setContext', {\n    enumerable: false,\n    value: setContext,\n  });\n\n  Object.defineProperty(operation, 'getContext', {\n    enumerable: false,\n    value: getContext,\n  });\n\n  Object.defineProperty(operation, 'toKey', {\n    enumerable: false,\n    value: () => getKey(operation),\n  });\n\n  return operation as Operation;\n}\n\nexport function getKey(operation: GraphQLRequest) {\n  // XXX we're assuming here that variables will be serialized in the same order.\n  // that might not always be true\n  return `${print(operation.query)}|${JSON.stringify(operation.variables)}|${\n    operation.operationName\n  }`;\n}\n","import Observable from 'zen-observable-ts';\n\nimport {\n  GraphQLRequest,\n  NextLink,\n  Operation,\n  RequestHandler,\n  FetchResult,\n} from './types';\n\nimport {\n  validateOperation,\n  isTerminating,\n  LinkError,\n  transformOperation,\n  createOperation,\n} from './linkUtils';\n\nconst passthrough = (op, forward) => (forward ? forward(op) : Observable.of());\n\nconst toLink = (handler: RequestHandler | ApolloLink) =>\n  typeof handler === 'function' ? new ApolloLink(handler) : handler;\n\nexport const empty = (): ApolloLink =>\n  new ApolloLink((op, forward) => Observable.of());\n\nexport const from = (links: ApolloLink[]): ApolloLink => {\n  if (links.length === 0) return empty();\n\n  return links.map(toLink).reduce((x, y) => x.concat(y));\n};\n\nexport const split = (\n  test: (op: Operation) => boolean,\n  left: ApolloLink | RequestHandler,\n  right: ApolloLink | RequestHandler = new ApolloLink(passthrough),\n): ApolloLink => {\n  const leftLink = toLink(left);\n  const rightLink = toLink(right);\n\n  if (isTerminating(leftLink) && isTerminating(rightLink)) {\n    return new ApolloLink(operation => {\n      return test(operation)\n        ? leftLink.request(operation) || Observable.of()\n        : rightLink.request(operation) || Observable.of();\n    });\n  } else {\n    return new ApolloLink((operation, forward) => {\n      return test(operation)\n        ? leftLink.request(operation, forward) || Observable.of()\n        : rightLink.request(operation, forward) || Observable.of();\n    });\n  }\n};\n\n// join two Links together\nexport const concat = (\n  first: ApolloLink | RequestHandler,\n  second: ApolloLink | RequestHandler,\n) => {\n  const firstLink = toLink(first);\n  if (isTerminating(firstLink)) {\n    console.warn(\n      new LinkError(\n        `You are calling concat on a terminating link, which will have no effect`,\n        firstLink,\n      ),\n    );\n    return firstLink;\n  }\n  const nextLink = toLink(second);\n\n  if (isTerminating(nextLink)) {\n    return new ApolloLink(\n      operation =>\n        firstLink.request(\n          operation,\n          op => nextLink.request(op) || Observable.of(),\n        ) || Observable.of(),\n    );\n  } else {\n    return new ApolloLink((operation, forward) => {\n      return (\n        firstLink.request(operation, op => {\n          return nextLink.request(op, forward) || Observable.of();\n        }) || Observable.of()\n      );\n    });\n  }\n};\n\nexport class ApolloLink {\n  constructor(request?: RequestHandler) {\n    if (request) this.request = request;\n  }\n\n  public static empty = empty;\n  public static from = from;\n  public static split = split;\n  public static execute = execute;\n\n  public split(\n    test: (op: Operation) => boolean,\n    left: ApolloLink | RequestHandler,\n    right: ApolloLink | RequestHandler = new ApolloLink(passthrough),\n  ): ApolloLink {\n    return this.concat(split(test, left, right));\n  }\n\n  public concat(next: ApolloLink | RequestHandler): ApolloLink {\n    return concat(this, next);\n  }\n\n  public request(\n    operation: Operation,\n    forward?: NextLink,\n  ): Observable<FetchResult> | null {\n    throw new Error('request is not implemented');\n  }\n}\n\nexport function execute(\n  link: ApolloLink,\n  operation: GraphQLRequest,\n): Observable<FetchResult> {\n  return (\n    link.request(\n      createOperation(\n        operation.context,\n        transformOperation(validateOperation(operation)),\n      ),\n    ) || Observable.of()\n  );\n}\n","// This simplified polyfill attempts to follow the ECMAScript Observable proposal.\n// See https://github.com/zenparsing/es-observable\nimport { Observable as LinkObservable } from 'apollo-link';\n\nexport type Subscription = ZenObservable.Subscription;\nexport type Observer<T> = ZenObservable.Observer<T>;\n\nimport $$observable from 'symbol-observable';\n\n// rxjs interopt\nexport class Observable<T> extends LinkObservable<T> {\n  public [$$observable]() {\n    return this;\n  }\n\n  public ['@@observable' as any]() {\n    return this;\n  }\n}\n","import { GraphQLError } from 'graphql';\n\nexport function isApolloError(err: Error): err is ApolloError {\n  return err.hasOwnProperty('graphQLErrors');\n}\n\n// Sets the error message on this error according to the\n// the GraphQL and network errors that are present.\n// If the error message has already been set through the\n// constructor or otherwise, this function is a nop.\nconst generateErrorMessage = (err: ApolloError) => {\n  let message = '';\n  // If we have GraphQL errors present, add that to the error message.\n  if (Array.isArray(err.graphQLErrors) && err.graphQLErrors.length !== 0) {\n    err.graphQLErrors.forEach((graphQLError: GraphQLError) => {\n      const errorMessage = graphQLError\n        ? graphQLError.message\n        : 'Error message not found.';\n      message += `GraphQL error: ${errorMessage}\\n`;\n    });\n  }\n\n  if (err.networkError) {\n    message += 'Network error: ' + err.networkError.message + '\\n';\n  }\n\n  // strip newline from the end of the message\n  message = message.replace(/\\n$/, '');\n  return message;\n};\n\nexport class ApolloError extends Error {\n  public message: string;\n  public graphQLErrors: GraphQLError[];\n  public networkError: Error | null;\n\n  // An object that can be used to provide some additional information\n  // about an error, e.g. specifying the type of error this is. Used\n  // internally within Apollo Client.\n  public extraInfo: any;\n\n  // Constructs an instance of ApolloError given a GraphQLError\n  // or a network error. Note that one of these has to be a valid\n  // value or the constructed error will be meaningless.\n  constructor({\n    graphQLErrors,\n    networkError,\n    errorMessage,\n    extraInfo,\n  }: {\n    graphQLErrors?: GraphQLError[];\n    networkError?: Error | null;\n    errorMessage?: string;\n    extraInfo?: any;\n  }) {\n    super(errorMessage);\n    this.graphQLErrors = graphQLErrors || [];\n    this.networkError = networkError || null;\n\n    if (!errorMessage) {\n      this.message = generateErrorMessage(this);\n    } else {\n      this.message = errorMessage;\n    }\n\n    this.extraInfo = extraInfo;\n\n    // We're not using `Object.setPrototypeOf` here as it isn't fully\n    // supported on Android (see issue #3236).\n    (this as any).__proto__ = ApolloError.prototype;\n  }\n}\n","import { DocumentNode, GraphQLError } from 'graphql';\nimport { QueryStoreValue } from '../data/queries';\nimport { NetworkStatus } from './networkStatus';\nimport { FetchResult } from 'apollo-link';\n\nexport type QueryListener = (\n  queryStoreValue: QueryStoreValue,\n  newData?: any,\n) => void;\n\nexport type OperationVariables = { [key: string]: any };\n\nexport type PureQueryOptions = {\n  query: DocumentNode;\n  variables?: { [key: string]: any };\n  context?: any;\n};\n\nexport type ApolloQueryResult<T> = {\n  data: T;\n  errors?: GraphQLError[];\n  loading: boolean;\n  networkStatus: NetworkStatus;\n  stale: boolean;\n};\n\nexport enum FetchType {\n  normal = 1,\n  refetch = 2,\n  poll = 3,\n}\n\n// This is part of the public API, people write these functions in `updateQueries`.\nexport type MutationQueryReducer<T> = (\n  previousResult: Record<string, any>,\n  options: {\n    mutationResult: FetchResult<T>;\n    queryName: string | undefined;\n    queryVariables: Record<string, any>;\n  },\n) => Record<string, any>;\n\nexport type MutationQueryReducersMap<T = { [key: string]: any }> = {\n  [queryName: string]: MutationQueryReducer<T>;\n};\n","import {\n  isEqual,\n  tryFunctionOrLogError,\n  maybeDeepFreeze,\n} from 'apollo-utilities';\nimport { GraphQLError } from 'graphql';\nimport { NetworkStatus, isNetworkRequestInFlight } from './networkStatus';\nimport { Observable, Observer, Subscription } from '../util/Observable';\n\nimport { QueryScheduler } from '../scheduler/scheduler';\n\nimport { ApolloError } from '../errors/ApolloError';\n\nimport { QueryManager } from './QueryManager';\nimport { ApolloQueryResult, FetchType, OperationVariables } from './types';\nimport {\n  ModifiableWatchQueryOptions,\n  WatchQueryOptions,\n  FetchMoreQueryOptions,\n  SubscribeToMoreOptions,\n  ErrorPolicy,\n  UpdateQueryFn,\n} from './watchQueryOptions';\n\nimport { QueryStoreValue } from '../data/queries';\n\nexport type ApolloCurrentResult<T> = {\n  data: T | {};\n  errors?: GraphQLError[];\n  loading: boolean;\n  networkStatus: NetworkStatus;\n  error?: ApolloError;\n  partial?: boolean;\n};\n\nexport interface FetchMoreOptions<\n  TData = any,\n  TVariables = OperationVariables\n> {\n  updateQuery: (\n    previousQueryResult: TData,\n    options: {\n      fetchMoreResult?: TData;\n      variables?: TVariables;\n    },\n  ) => TData;\n}\n\nexport interface UpdateQueryOptions<TVariables> {\n  variables?: TVariables;\n}\n\nexport const hasError = (\n  storeValue: QueryStoreValue,\n  policy: ErrorPolicy = 'none',\n) =>\n  storeValue &&\n  ((storeValue.graphQLErrors &&\n    storeValue.graphQLErrors.length > 0 &&\n    policy === 'none') ||\n    storeValue.networkError);\n\nexport class ObservableQuery<\n  TData = any,\n  TVariables = OperationVariables\n> extends Observable<ApolloQueryResult<TData>> {\n  public options: WatchQueryOptions<TVariables>;\n  public queryId: string;\n  /**\n   *\n   * The current value of the variables for this query. Can change.\n   */\n  public variables: TVariables;\n\n  private isCurrentlyPolling: boolean;\n  private shouldSubscribe: boolean;\n  private isTornDown: boolean;\n  private scheduler: QueryScheduler<any>;\n  private queryManager: QueryManager<any>;\n  private observers: Observer<ApolloQueryResult<TData>>[];\n  private subscriptionHandles: Subscription[];\n\n  private lastResult: ApolloQueryResult<TData>;\n  private lastError: ApolloError;\n\n  constructor({\n    scheduler,\n    options,\n    shouldSubscribe = true,\n  }: {\n    scheduler: QueryScheduler<any>;\n    options: WatchQueryOptions<TVariables>;\n    shouldSubscribe?: boolean;\n  }) {\n    super((observer: Observer<ApolloQueryResult<TData>>) =>\n      this.onSubscribe(observer),\n    );\n\n    // active state\n    this.isCurrentlyPolling = false;\n    this.isTornDown = false;\n\n    // query information\n    this.options = options;\n    this.variables = options.variables || ({} as TVariables);\n    this.queryId = scheduler.queryManager.generateQueryId();\n    this.shouldSubscribe = shouldSubscribe;\n\n    // related classes\n    this.scheduler = scheduler;\n    this.queryManager = scheduler.queryManager;\n\n    // interal data stores\n    this.observers = [];\n    this.subscriptionHandles = [];\n  }\n\n  public result(): Promise<ApolloQueryResult<TData>> {\n    const that = this;\n    return new Promise((resolve, reject) => {\n      let subscription: Subscription;\n      const observer: Observer<ApolloQueryResult<TData>> = {\n        next(result: ApolloQueryResult<TData>) {\n          resolve(result);\n\n          // Stop the query within the QueryManager if we can before\n          // this function returns.\n          //\n          // We do this in order to prevent observers piling up within\n          // the QueryManager. Notice that we only fully unsubscribe\n          // from the subscription in a setTimeout(..., 0)  call. This call can\n          // actually be handled by the browser at a much later time. If queries\n          // are fired in the meantime, observers that should have been removed\n          // from the QueryManager will continue to fire, causing an unnecessary\n          // performance hit.\n          if (!that.observers.some(obs => obs !== observer)) {\n            that.queryManager.removeQuery(that.queryId);\n          }\n\n          setTimeout(() => {\n            subscription.unsubscribe();\n          }, 0);\n        },\n        error(error: any) {\n          reject(error);\n        },\n      };\n      subscription = that.subscribe(observer);\n    });\n  }\n\n  /**\n   * Return the result of the query from the local cache as well as some fetching status\n   * `loading` and `networkStatus` allow to know if a request is in flight\n   * `partial` lets you know if the result from the local cache is complete or partial\n   * @return {data: Object, error: ApolloError, loading: boolean, networkStatus: number, partial: boolean}\n   */\n  public currentResult(): ApolloCurrentResult<TData> {\n    if (this.isTornDown) {\n      return {\n        data: this.lastError ? {} : this.lastResult ? this.lastResult.data : {},\n        error: this.lastError,\n        loading: false,\n        networkStatus: NetworkStatus.error,\n      };\n    }\n\n    const queryStoreValue = this.queryManager.queryStore.get(this.queryId);\n\n    if (hasError(queryStoreValue, this.options.errorPolicy)) {\n      return {\n        data: {},\n        loading: false,\n        networkStatus: queryStoreValue.networkStatus,\n        error: new ApolloError({\n          graphQLErrors: queryStoreValue.graphQLErrors,\n          networkError: queryStoreValue.networkError,\n        }),\n      };\n    }\n\n    const { data, partial } = this.queryManager.getCurrentQueryResult(this);\n\n    const queryLoading =\n      !queryStoreValue ||\n      queryStoreValue.networkStatus === NetworkStatus.loading;\n\n    // We need to be careful about the loading state we show to the user, to try\n    // and be vaguely in line with what the user would have seen from .subscribe()\n    // but to still provide useful information synchronously when the query\n    // will not end up hitting the server.\n    // See more: https://github.com/apollostack/apollo-client/issues/707\n    // Basically: is there a query in flight right now (modolo the next tick)?\n    const loading =\n      (this.options.fetchPolicy === 'network-only' && queryLoading) ||\n      (partial && this.options.fetchPolicy !== 'cache-only');\n\n    // if there is nothing in the query store, it means this query hasn't fired yet or it has been cleaned up. Therefore the\n    // network status is dependent on queryLoading.\n    let networkStatus: NetworkStatus;\n    if (queryStoreValue) {\n      networkStatus = queryStoreValue.networkStatus;\n    } else {\n      networkStatus = loading ? NetworkStatus.loading : NetworkStatus.ready;\n    }\n\n    const result = {\n      data,\n      loading: isNetworkRequestInFlight(networkStatus),\n      networkStatus,\n    } as ApolloQueryResult<TData>;\n\n    if (\n      queryStoreValue &&\n      queryStoreValue.graphQLErrors &&\n      this.options.errorPolicy === 'all'\n    ) {\n      result.errors = queryStoreValue.graphQLErrors;\n    }\n\n    if (!partial) {\n      const stale = false;\n      this.lastResult = { ...result, stale };\n    }\n\n    return { ...result, partial } as ApolloCurrentResult<TData>;\n  }\n\n  // Returns the last result that observer.next was called with. This is not the same as\n  // currentResult! If you're not sure which you need, then you probably need currentResult.\n  public getLastResult(): ApolloQueryResult<TData> {\n    return this.lastResult;\n  }\n\n  public getLastError(): ApolloError {\n    return this.lastError;\n  }\n\n  public resetLastResults(): void {\n    delete this.lastResult;\n    delete this.lastError;\n    this.isTornDown = false;\n  }\n\n  /**\n   * Update the variables of this observable query, and fetch the new results.\n   * This method should be preferred over `setVariables` in most use cases.\n   *\n   * @param variables: The new set of variables. If there are missing variables,\n   * the previous values of those variables will be used.\n   */\n  public refetch(variables?: TVariables): Promise<ApolloQueryResult<TData>> {\n    const { fetchPolicy } = this.options;\n    // early return if trying to read from cache during refetch\n    if (fetchPolicy === 'cache-only') {\n      return Promise.reject(\n        new Error(\n          'cache-only fetchPolicy option should not be used together with query refetch.',\n        ),\n      );\n    }\n\n    if (!isEqual(this.variables, variables)) {\n      // update observable variables\n      this.variables = Object.assign({}, this.variables, variables);\n    }\n\n    if (!isEqual(this.options.variables, this.variables)) {\n      // Update the existing options with new variables\n      this.options.variables = Object.assign(\n        {},\n        this.options.variables,\n        this.variables,\n      );\n    }\n\n    // Override fetchPolicy for this call only\n    // only network-only and no-cache are safe to use\n    const isNetworkFetchPolicy =\n      fetchPolicy === 'network-only' || fetchPolicy === 'no-cache';\n\n    const combinedOptions: WatchQueryOptions = {\n      ...this.options,\n      fetchPolicy: isNetworkFetchPolicy ? fetchPolicy : 'network-only',\n    };\n\n    return this.queryManager\n      .fetchQuery(this.queryId, combinedOptions, FetchType.refetch)\n      .then(result => maybeDeepFreeze(result));\n  }\n\n  public fetchMore<K extends keyof TVariables>(\n    fetchMoreOptions: FetchMoreQueryOptions<TVariables, K> &\n      FetchMoreOptions<TData, TVariables>,\n  ): Promise<ApolloQueryResult<TData>> {\n    // early return if no update Query\n    if (!fetchMoreOptions.updateQuery) {\n      throw new Error(\n        'updateQuery option is required. This function defines how to update the query data with the new results.',\n      );\n    }\n\n    let combinedOptions: any;\n\n    return Promise.resolve()\n      .then(() => {\n        const qid = this.queryManager.generateQueryId();\n\n        if (fetchMoreOptions.query) {\n          // fetch a new query\n          combinedOptions = fetchMoreOptions;\n        } else {\n          // fetch the same query with a possibly new variables\n          combinedOptions = {\n            ...this.options,\n            ...fetchMoreOptions,\n            variables: Object.assign(\n              {},\n              this.variables,\n              fetchMoreOptions.variables,\n            ),\n          };\n        }\n\n        combinedOptions.fetchPolicy = 'network-only';\n\n        return this.queryManager.fetchQuery(\n          qid,\n          combinedOptions as WatchQueryOptions,\n          FetchType.normal,\n          this.queryId,\n        );\n      })\n      .then(fetchMoreResult => {\n        this.updateQuery((previousResult: any) =>\n          fetchMoreOptions.updateQuery(previousResult, {\n            fetchMoreResult: fetchMoreResult.data as TData,\n            variables: combinedOptions.variables,\n          }),\n        );\n\n        return fetchMoreResult as ApolloQueryResult<TData>;\n      });\n  }\n\n  // XXX the subscription variables are separate from the query variables.\n  // if you want to update subscription variables, right now you have to do that separately,\n  // and you can only do it by stopping the subscription and then subscribing again with new variables.\n  public subscribeToMore(options: SubscribeToMoreOptions<TData, TVariables>) {\n    const subscription = this.queryManager\n      .startGraphQLSubscription({\n        query: options.document,\n        variables: options.variables,\n      })\n      .subscribe({\n        next: (subscriptionData: { data: TData }) => {\n          if (options.updateQuery) {\n            this.updateQuery((previous, { variables }) =>\n              (options.updateQuery as UpdateQueryFn<TData, TVariables>)(\n                previous,\n                {\n                  subscriptionData,\n                  variables,\n                },\n              ),\n            );\n          }\n        },\n        error: (err: any) => {\n          if (options.onError) {\n            options.onError(err);\n            return;\n          }\n          console.error('Unhandled GraphQL subscription error', err);\n        },\n      });\n\n    this.subscriptionHandles.push(subscription);\n\n    return () => {\n      const i = this.subscriptionHandles.indexOf(subscription);\n      if (i >= 0) {\n        this.subscriptionHandles.splice(i, 1);\n        subscription.unsubscribe();\n      }\n    };\n  }\n\n  // Note: if the query is not active (there are no subscribers), the promise\n  // will return null immediately.\n  public setOptions(\n    opts: ModifiableWatchQueryOptions,\n  ): Promise<ApolloQueryResult<TData>> {\n    const oldOptions = this.options;\n    this.options = Object.assign({}, this.options, opts) as WatchQueryOptions<\n      TVariables\n    >;\n\n    if (opts.pollInterval) {\n      this.startPolling(opts.pollInterval);\n    } else if (opts.pollInterval === 0) {\n      this.stopPolling();\n    }\n\n    // If fetchPolicy went from cache-only to something else, or from something else to network-only\n    const tryFetch: boolean =\n      (oldOptions.fetchPolicy !== 'network-only' &&\n        opts.fetchPolicy === 'network-only') ||\n      (oldOptions.fetchPolicy === 'cache-only' &&\n        opts.fetchPolicy !== 'cache-only') ||\n      (oldOptions.fetchPolicy === 'standby' &&\n        opts.fetchPolicy !== 'standby') ||\n      false;\n\n    return this.setVariables(\n      this.options.variables as TVariables,\n      tryFetch,\n      opts.fetchResults,\n    );\n  }\n\n  /**\n   * This is for *internal* use only. Most users should instead use `refetch`\n   * in order to be properly notified of results even when they come from cache.\n   *\n   * Update the variables of this observable query, and fetch the new results\n   * if they've changed. If you want to force new results, use `refetch`.\n   *\n   * Note: the `next` callback will *not* fire if the variables have not changed\n   * or if the result is coming from cache.\n   *\n   * Note: the promise will return the old results immediately if the variables\n   * have not changed.\n   *\n   * Note: the promise will return null immediately if the query is not active\n   * (there are no subscribers).\n   *\n   * @private\n   *\n   * @param variables: The new set of variables. If there are missing variables,\n   * the previous values of those variables will be used.\n   *\n   * @param tryFetch: Try and fetch new results even if the variables haven't\n   * changed (we may still just hit the store, but if there's nothing in there\n   * this will refetch)\n   *\n   * @param fetchResults: Option to ignore fetching results when updating variables\n   */\n  public setVariables(\n    variables: TVariables,\n    tryFetch: boolean = false,\n    fetchResults = true,\n  ): Promise<ApolloQueryResult<TData>> {\n    // since setVariables restarts the subscription, we reset the tornDown status\n    this.isTornDown = false;\n\n    const newVariables = variables ? variables : this.variables;\n\n    if (isEqual(newVariables, this.variables) && !tryFetch) {\n      // If we have no observers, then we don't actually want to make a network\n      // request. As soon as someone observes the query, the request will kick\n      // off. For now, we just store any changes. (See #1077)\n      if (this.observers.length === 0 || !fetchResults) {\n        return new Promise(resolve => resolve());\n      }\n      return this.result();\n    } else {\n      this.variables = newVariables;\n      this.options.variables = newVariables;\n\n      // See comment above\n      if (this.observers.length === 0) {\n        return new Promise(resolve => resolve());\n      }\n\n      // Use the same options as before, but with new variables\n      return this.queryManager\n        .fetchQuery(this.queryId, {\n          ...this.options,\n          variables: this.variables,\n        } as WatchQueryOptions)\n        .then(result => maybeDeepFreeze(result));\n    }\n  }\n\n  public updateQuery(\n    mapFn: (\n      previousQueryResult: TData,\n      options: UpdateQueryOptions<TVariables>,\n    ) => TData,\n  ): void {\n    const {\n      previousResult,\n      variables,\n      document,\n    } = this.queryManager.getQueryWithPreviousResult(this.queryId);\n\n    const newResult = tryFunctionOrLogError(() =>\n      mapFn(previousResult, { variables: variables as TVariables }),\n    );\n\n    if (newResult) {\n      this.queryManager.dataStore.markUpdateQueryResult(\n        document,\n        variables,\n        newResult,\n      );\n      this.queryManager.broadcastQueries();\n    }\n  }\n\n  public stopPolling() {\n    if (this.isCurrentlyPolling) {\n      this.scheduler.stopPollingQuery(this.queryId);\n      this.options.pollInterval = undefined;\n      this.isCurrentlyPolling = false;\n    }\n  }\n\n  public startPolling(pollInterval: number) {\n    if (\n      this.options.fetchPolicy === 'cache-first' ||\n      this.options.fetchPolicy === 'cache-only'\n    ) {\n      throw new Error(\n        'Queries that specify the cache-first and cache-only fetchPolicies cannot also be polling queries.',\n      );\n    }\n\n    if (this.isCurrentlyPolling) {\n      this.scheduler.stopPollingQuery(this.queryId);\n      this.isCurrentlyPolling = false;\n    }\n    this.options.pollInterval = pollInterval;\n    this.isCurrentlyPolling = true;\n    this.scheduler.startPollingQuery(this.options, this.queryId);\n  }\n\n  private onSubscribe(observer: Observer<ApolloQueryResult<TData>>) {\n    // Zen Observable has its own error function, in order to log correctly\n    // we need to declare a custom error if nothing is passed\n    if (\n      (observer as any)._subscription &&\n      (observer as any)._subscription._observer &&\n      !(observer as any)._subscription._observer.error\n    ) {\n      (observer as any)._subscription._observer.error = (\n        error: ApolloError,\n      ) => {\n        console.error('Unhandled error', error.message, error.stack);\n      };\n    }\n\n    this.observers.push(observer);\n\n    // Deliver initial result\n    if (observer.next && this.lastResult) observer.next(this.lastResult);\n    if (observer.error && this.lastError) observer.error(this.lastError);\n\n    // setup the query if it hasn't been done before\n    if (this.observers.length === 1) this.setUpQuery();\n\n    return () => {\n      this.observers = this.observers.filter(obs => obs !== observer);\n\n      if (this.observers.length === 0) {\n        this.tearDownQuery();\n      }\n    };\n  }\n\n  private setUpQuery() {\n    if (this.shouldSubscribe) {\n      this.queryManager.addObservableQuery<TData>(this.queryId, this);\n    }\n\n    if (!!this.options.pollInterval) {\n      if (\n        this.options.fetchPolicy === 'cache-first' ||\n        this.options.fetchPolicy === 'cache-only'\n      ) {\n        throw new Error(\n          'Queries that specify the cache-first and cache-only fetchPolicies cannot also be polling queries.',\n        );\n      }\n\n      this.isCurrentlyPolling = true;\n      this.scheduler.startPollingQuery<TData>(this.options, this.queryId);\n    }\n\n    const observer: Observer<ApolloQueryResult<TData>> = {\n      next: (result: ApolloQueryResult<TData>) => {\n        this.lastResult = result;\n        this.observers.forEach(obs => obs.next && obs.next(result));\n      },\n      error: (error: ApolloError) => {\n        this.lastError = error;\n        this.observers.forEach(obs => obs.error && obs.error(error));\n      },\n    };\n\n    this.queryManager.startQuery<TData>(\n      this.queryId,\n      this.options,\n      this.queryManager.queryListenerForObserver(\n        this.queryId,\n        this.options,\n        observer,\n      ),\n    );\n  }\n\n  private tearDownQuery() {\n    this.isTornDown = true;\n\n    if (this.isCurrentlyPolling) {\n      this.scheduler.stopPollingQuery(this.queryId);\n      this.isCurrentlyPolling = false;\n    }\n\n    // stop all active GraphQL subscriptions\n    this.subscriptionHandles.forEach(sub => sub.unsubscribe());\n    this.subscriptionHandles = [];\n\n    this.queryManager.removeObservableQuery(this.queryId);\n\n    this.queryManager.stopQuery(this.queryId);\n\n    this.observers = [];\n  }\n}\n","import {\n  ApolloLink,\n  Operation,\n  NextLink,\n  FetchResult,\n  Observable,\n} from 'apollo-link';\n\n/*\n * Expects context to contain the forceFetch field if no dedup\n */\nexport class DedupLink extends ApolloLink {\n  private inFlightRequestObservables: Map<\n    string,\n    Observable<FetchResult>\n  > = new Map();\n  private subscribers: Map<string, any> = new Map();\n\n  public request(\n    operation: Operation,\n    forward: NextLink,\n  ): Observable<FetchResult> {\n    // sometimes we might not want to deduplicate a request, for example when we want to force fetch it.\n    if (operation.getContext().forceFetch) {\n      return forward(operation);\n    }\n\n    const key = operation.toKey();\n\n    const cleanup = key => {\n      this.inFlightRequestObservables.delete(key);\n      const prev = this.subscribers.get(key);\n      return prev;\n    };\n\n    if (!this.inFlightRequestObservables.get(key)) {\n      // this is a new request, i.e. we haven't deduplicated it yet\n      // call the next link\n      const singleObserver = forward(operation);\n      let subscription;\n\n      const sharedObserver = new Observable(observer => {\n        // this will still be called by each subscriber regardless of\n        // deduplication status\n        let prev = this.subscribers.get(key);\n        if (!prev) prev = { next: [], error: [], complete: [] };\n\n        this.subscribers.set(key, {\n          next: prev.next.concat([observer.next.bind(observer)]),\n          error: prev.error.concat([observer.error.bind(observer)]),\n          complete: prev.complete.concat([observer.complete.bind(observer)]),\n        });\n\n        if (!subscription) {\n          subscription = singleObserver.subscribe({\n            next: result => {\n              const prev = cleanup(key);\n              this.subscribers.delete(key);\n              if (prev) {\n                prev.next.forEach(next => next(result));\n                prev.complete.forEach(complete => complete());\n              }\n            },\n            error: error => {\n              const prev = cleanup(key);\n              this.subscribers.delete(key);\n              if (prev) prev.error.forEach(err => err(error));\n            },\n          });\n        }\n\n        return () => {\n          if (subscription) subscription.unsubscribe();\n          this.inFlightRequestObservables.delete(key);\n        };\n      });\n\n      this.inFlightRequestObservables.set(key, sharedObserver);\n    }\n\n    // return shared Observable\n    return this.inFlightRequestObservables.get(key);\n  }\n}\n","// The QueryScheduler is supposed to be a mechanism that schedules polling queries such that\n// they are clustered into the time slots of the QueryBatcher and are batched together. It\n// also makes sure that for a given polling query, if one instance of the query is inflight,\n// another instance will not be fired until the query returns or times out. We do this because\n// another query fires while one is already in flight, the data will stay in the \"loading\" state\n// even after the first query has returned.\n\n// At the moment, the QueryScheduler implements the one-polling-instance-at-a-time logic and\n// adds queries to the QueryBatcher queue.\n\nimport { QueryManager } from '../core/QueryManager';\n\nimport { FetchType, QueryListener } from '../core/types';\n\nimport { ObservableQuery } from '../core/ObservableQuery';\n\nimport { WatchQueryOptions } from '../core/watchQueryOptions';\n\nimport { NetworkStatus } from '../core/networkStatus';\n\nexport class QueryScheduler<TCacheShape> {\n  // Map going from queryIds to query options that are in flight.\n  public inFlightQueries: { [queryId: string]: WatchQueryOptions } = {};\n\n  // Map going from query ids to the query options associated with those queries. Contains all of\n  // the queries, both in flight and not in flight.\n  public registeredQueries: { [queryId: string]: WatchQueryOptions } = {};\n\n  // Map going from polling interval with to the query ids that fire on that interval.\n  // These query ids are associated with a set of options in the this.registeredQueries.\n  public intervalQueries: { [interval: number]: string[] } = {};\n\n  // We use this instance to actually fire queries (i.e. send them to the batching\n  // mechanism).\n  public queryManager: QueryManager<TCacheShape>;\n\n  // Map going from polling interval widths to polling timers.\n  private pollingTimers: { [interval: number]: any } = {};\n\n  private ssrMode: boolean = false;\n\n  constructor({\n    queryManager,\n    ssrMode,\n  }: {\n    queryManager: QueryManager<TCacheShape>;\n    ssrMode?: boolean;\n  }) {\n    this.queryManager = queryManager;\n    this.ssrMode = ssrMode || false;\n  }\n\n  public checkInFlight(queryId: string) {\n    const query = this.queryManager.queryStore.get(queryId);\n\n    return (\n      query &&\n      query.networkStatus !== NetworkStatus.ready &&\n      query.networkStatus !== NetworkStatus.error\n    );\n  }\n\n  public fetchQuery<T>(\n    queryId: string,\n    options: WatchQueryOptions,\n    fetchType: FetchType,\n  ) {\n    return new Promise((resolve, reject) => {\n      this.queryManager\n        .fetchQuery<T>(queryId, options, fetchType)\n        .then(result => {\n          resolve(result);\n        })\n        .catch(error => {\n          reject(error);\n        });\n    });\n  }\n\n  public startPollingQuery<T>(\n    options: WatchQueryOptions,\n    queryId: string,\n    listener?: QueryListener,\n  ): string {\n    if (!options.pollInterval) {\n      throw new Error(\n        'Attempted to start a polling query without a polling interval.',\n      );\n    }\n\n    // Do not poll in SSR mode\n    if (this.ssrMode) return queryId;\n\n    this.registeredQueries[queryId] = options;\n\n    if (listener) {\n      this.queryManager.addQueryListener(queryId, listener);\n    }\n    this.addQueryOnInterval<T>(queryId, options);\n\n    return queryId;\n  }\n\n  public stopPollingQuery(queryId: string) {\n    // Remove the query options from one of the registered queries.\n    // The polling function will then take care of not firing it anymore.\n    delete this.registeredQueries[queryId];\n  }\n\n  // Fires the all of the queries on a particular interval. Called on a setInterval.\n  public fetchQueriesOnInterval<T>(interval: number) {\n    // XXX this \"filter\" here is nasty, because it does two things at the same time.\n    // 1. remove queries that have stopped polling\n    // 2. call fetchQueries for queries that are polling and not in flight.\n    // TODO: refactor this to make it cleaner\n    this.intervalQueries[interval] = this.intervalQueries[interval].filter(\n      queryId => {\n        // If queryOptions can't be found from registeredQueries or if it has a\n        // different interval, it means that this queryId is no longer registered\n        // and should be removed from the list of queries firing on this interval.\n        //\n        // We don't remove queries from intervalQueries immediately in\n        // stopPollingQuery so that we can keep the timer consistent when queries\n        // are removed and replaced, and to avoid quadratic behavior when stopping\n        // many queries.\n        if (\n          !(\n            this.registeredQueries.hasOwnProperty(queryId) &&\n            this.registeredQueries[queryId].pollInterval === interval\n          )\n        ) {\n          return false;\n        }\n\n        // Don't fire this instance of the polling query is one of the instances is already in\n        // flight.\n        if (this.checkInFlight(queryId)) {\n          return true;\n        }\n\n        const queryOptions = this.registeredQueries[queryId];\n        const pollingOptions = { ...queryOptions } as WatchQueryOptions;\n        pollingOptions.fetchPolicy = 'network-only';\n        // don't let unhandled rejections happen\n        this.fetchQuery<T>(queryId, pollingOptions, FetchType.poll).catch(\n          () => {},\n        );\n        return true;\n      },\n    );\n\n    if (this.intervalQueries[interval].length === 0) {\n      clearInterval(this.pollingTimers[interval]);\n      delete this.intervalQueries[interval];\n    }\n  }\n\n  // Adds a query on a particular interval to this.intervalQueries and then fires\n  // that query with all the other queries executing on that interval. Note that the query id\n  // and query options must have been added to this.registeredQueries before this function is called.\n  public addQueryOnInterval<T>(\n    queryId: string,\n    queryOptions: WatchQueryOptions,\n  ) {\n    const interval = queryOptions.pollInterval;\n\n    if (!interval) {\n      throw new Error(\n        `A poll interval is required to start polling query with id '${queryId}'.`,\n      );\n    }\n\n    // If there are other queries on this interval, this query will just fire with those\n    // and we don't need to create a new timer.\n    if (\n      this.intervalQueries.hasOwnProperty(interval.toString()) &&\n      this.intervalQueries[interval].length > 0\n    ) {\n      this.intervalQueries[interval].push(queryId);\n    } else {\n      this.intervalQueries[interval] = [queryId];\n      // set up the timer for the function that will handle this interval\n      this.pollingTimers[interval] = setInterval(() => {\n        this.fetchQueriesOnInterval<T>(interval);\n      }, interval);\n    }\n  }\n\n  // Used only for unit testing.\n  public registerPollingQuery<T>(\n    queryOptions: WatchQueryOptions,\n  ): ObservableQuery<T> {\n    if (!queryOptions.pollInterval) {\n      throw new Error(\n        'Attempted to register a non-polling query with the scheduler.',\n      );\n    }\n    return new ObservableQuery<T>({\n      scheduler: this,\n      options: queryOptions,\n    });\n  }\n}\n","export class MutationStore {\n  private store: { [mutationId: string]: MutationStoreValue } = {};\n\n  public getStore(): { [mutationId: string]: MutationStoreValue } {\n    return this.store;\n  }\n\n  public get(mutationId: string): MutationStoreValue {\n    return this.store[mutationId];\n  }\n\n  public initMutation(\n    mutationId: string,\n    mutationString: string,\n    variables: Object | undefined,\n  ) {\n    this.store[mutationId] = {\n      mutationString: mutationString,\n      variables: variables || {},\n      loading: true,\n      error: null,\n    };\n  }\n\n  public markMutationError(mutationId: string, error: Error) {\n    const mutation = this.store[mutationId];\n\n    if (!mutation) {\n      return;\n    }\n\n    mutation.loading = false;\n    mutation.error = error;\n  }\n\n  public markMutationResult(mutationId: string) {\n    const mutation = this.store[mutationId];\n\n    if (!mutation) {\n      return;\n    }\n\n    mutation.loading = false;\n    mutation.error = null;\n  }\n\n  public reset() {\n    this.store = {};\n  }\n}\n\nexport interface MutationStoreValue {\n  mutationString: string;\n  variables: Object;\n  loading: boolean;\n  error: Error | null;\n}\n","import { DocumentNode, GraphQLError, ExecutionResult } from 'graphql';\nimport { print } from 'graphql/language/printer';\nimport { isEqual } from 'apollo-utilities';\n\nimport { NetworkStatus } from '../core/networkStatus';\n\nexport type QueryStoreValue = {\n  document: DocumentNode;\n  variables: Object;\n  previousVariables?: Object | null;\n  networkStatus: NetworkStatus;\n  networkError?: Error | null;\n  graphQLErrors?: GraphQLError[];\n  metadata: any;\n};\n\nexport class QueryStore {\n  private store: { [queryId: string]: QueryStoreValue } = {};\n\n  public getStore(): { [queryId: string]: QueryStoreValue } {\n    return this.store;\n  }\n\n  public get(queryId: string): QueryStoreValue {\n    return this.store[queryId];\n  }\n\n  public initQuery(query: {\n    queryId: string;\n    document: DocumentNode;\n    storePreviousVariables: boolean;\n    variables: Object;\n    isPoll: boolean;\n    isRefetch: boolean;\n    metadata: any;\n    fetchMoreForQueryId: string | undefined;\n  }) {\n    const previousQuery = this.store[query.queryId];\n\n    if (\n      previousQuery &&\n      previousQuery.document !== query.document &&\n      print(previousQuery.document) !== print(query.document)\n    ) {\n      // XXX we're throwing an error here to catch bugs where a query gets overwritten by a new one.\n      // we should implement a separate action for refetching so that QUERY_INIT may never overwrite\n      // an existing query (see also: https://github.com/apollostack/apollo-client/issues/732)\n      throw new Error(\n        'Internal Error: may not update existing query string in store',\n      );\n    }\n\n    let isSetVariables = false;\n\n    let previousVariables: Object | null = null;\n    if (\n      query.storePreviousVariables &&\n      previousQuery &&\n      previousQuery.networkStatus !== NetworkStatus.loading\n      // if the previous query was still loading, we don't want to remember it at all.\n    ) {\n      if (!isEqual(previousQuery.variables, query.variables)) {\n        isSetVariables = true;\n        previousVariables = previousQuery.variables;\n      }\n    }\n\n    // TODO break this out into a separate function\n    let networkStatus;\n    if (isSetVariables) {\n      networkStatus = NetworkStatus.setVariables;\n    } else if (query.isPoll) {\n      networkStatus = NetworkStatus.poll;\n    } else if (query.isRefetch) {\n      networkStatus = NetworkStatus.refetch;\n      // TODO: can we determine setVariables here if it's a refetch and the variables have changed?\n    } else {\n      networkStatus = NetworkStatus.loading;\n    }\n\n    let graphQLErrors: GraphQLError[] = [];\n    if (previousQuery && previousQuery.graphQLErrors) {\n      graphQLErrors = previousQuery.graphQLErrors;\n    }\n\n    // XXX right now if QUERY_INIT is fired twice, like in a refetch situation, we just overwrite\n    // the store. We probably want a refetch action instead, because I suspect that if you refetch\n    // before the initial fetch is done, you'll get an error.\n    this.store[query.queryId] = {\n      document: query.document,\n      variables: query.variables,\n      previousVariables,\n      networkError: null,\n      graphQLErrors: graphQLErrors,\n      networkStatus,\n      metadata: query.metadata,\n    };\n\n    // If the action had a `moreForQueryId` property then we need to set the\n    // network status on that query as well to `fetchMore`.\n    //\n    // We have a complement to this if statement in the query result and query\n    // error action branch, but importantly *not* in the client result branch.\n    // This is because the implementation of `fetchMore` *always* sets\n    // `fetchPolicy` to `network-only` so we would never have a client result.\n    if (\n      typeof query.fetchMoreForQueryId === 'string' &&\n      this.store[query.fetchMoreForQueryId]\n    ) {\n      this.store[query.fetchMoreForQueryId].networkStatus =\n        NetworkStatus.fetchMore;\n    }\n  }\n\n  public markQueryResult(\n    queryId: string,\n    result: ExecutionResult,\n    fetchMoreForQueryId: string | undefined,\n  ) {\n    if (!this.store[queryId]) return;\n\n    this.store[queryId].networkError = null;\n    this.store[queryId].graphQLErrors =\n      result.errors && result.errors.length ? result.errors : [];\n    this.store[queryId].previousVariables = null;\n    this.store[queryId].networkStatus = NetworkStatus.ready;\n\n    // If we have a `fetchMoreForQueryId` then we need to update the network\n    // status for that query. See the branch for query initialization for more\n    // explanation about this process.\n    if (\n      typeof fetchMoreForQueryId === 'string' &&\n      this.store[fetchMoreForQueryId]\n    ) {\n      this.store[fetchMoreForQueryId].networkStatus = NetworkStatus.ready;\n    }\n  }\n\n  public markQueryError(\n    queryId: string,\n    error: Error,\n    fetchMoreForQueryId: string | undefined,\n  ) {\n    if (!this.store[queryId]) return;\n\n    this.store[queryId].networkError = error;\n    this.store[queryId].networkStatus = NetworkStatus.error;\n\n    // If we have a `fetchMoreForQueryId` then we need to update the network\n    // status for that query. See the branch for query initialization for more\n    // explanation about this process.\n    if (typeof fetchMoreForQueryId === 'string') {\n      this.markQueryResultClient(fetchMoreForQueryId, true);\n    }\n  }\n\n  public markQueryResultClient(queryId: string, complete: boolean) {\n    if (!this.store[queryId]) return;\n\n    this.store[queryId].networkError = null;\n    this.store[queryId].previousVariables = null;\n    this.store[queryId].networkStatus = complete\n      ? NetworkStatus.ready\n      : NetworkStatus.loading;\n  }\n\n  public stopQuery(queryId: string) {\n    delete this.store[queryId];\n  }\n\n  public reset(observableQueryIds: string[]) {\n    // keep only the queries with query ids that are associated with observables\n    this.store = Object.keys(this.store)\n      .filter(queryId => {\n        return observableQueryIds.indexOf(queryId) > -1;\n      })\n      .reduce(\n        (res, key) => {\n          // XXX set loading to true so listeners don't trigger unless they want results with partial data\n          res[key] = {\n            ...this.store[key],\n            networkStatus: NetworkStatus.loading,\n          };\n\n          return res;\n        },\n        {} as { [queryId: string]: QueryStoreValue },\n      );\n  }\n}\n","import { execute, ApolloLink, FetchResult } from 'apollo-link';\nimport { ExecutionResult, DocumentNode } from 'graphql';\nimport { print } from 'graphql/language/printer';\nimport { DedupLink as Deduplicator } from 'apollo-link-dedup';\nimport { Cache } from 'apollo-cache';\nimport {\n  assign,\n  getDefaultValues,\n  getMutationDefinition,\n  getOperationDefinition,\n  getOperationName,\n  getQueryDefinition,\n  isProduction,\n  maybeDeepFreeze,\n  hasDirectives,\n} from 'apollo-utilities';\n\nimport { QueryScheduler } from '../scheduler/scheduler';\n\nimport { isApolloError, ApolloError } from '../errors/ApolloError';\n\nimport { Observer, Subscription, Observable } from '../util/Observable';\n\nimport { QueryWithUpdater, DataStore } from '../data/store';\nimport { MutationStore } from '../data/mutations';\nimport { QueryStore, QueryStoreValue } from '../data/queries';\n\nimport {\n  QueryOptions,\n  WatchQueryOptions,\n  SubscriptionOptions,\n  MutationOptions,\n} from './watchQueryOptions';\nimport { ObservableQuery } from './ObservableQuery';\nimport { NetworkStatus, isNetworkRequestInFlight } from './networkStatus';\nimport {\n  QueryListener,\n  ApolloQueryResult,\n  FetchType,\n  OperationVariables,\n} from './types';\nimport { graphQLResultHasError } from 'apollo-utilities';\n\nexport interface QueryInfo {\n  listeners: QueryListener[];\n  invalidated: boolean;\n  newData: Cache.DiffResult<any> | null;\n  document: DocumentNode | null;\n  lastRequestId: number | null;\n  // A map going from queryId to an observer for a query issued by watchQuery. We use\n  // these to keep track of queries that are inflight and error on the observers associated\n  // with them in case of some destabalizing action (e.g. reset of the Apollo store).\n  observableQuery: ObservableQuery<any> | null;\n  subscriptions: Subscription[];\n  cancel?: (() => void);\n}\n\nconst defaultQueryInfo = {\n  listeners: [],\n  invalidated: false,\n  document: null,\n  newData: null,\n  lastRequestId: null,\n  observableQuery: null,\n  subscriptions: [],\n};\n\nexport interface QueryPromise {\n  resolve: (result: ApolloQueryResult<any>) => void;\n  reject: (error: Error) => void;\n}\n\nexport class QueryManager<TStore> {\n  public scheduler: QueryScheduler<TStore>;\n  public link: ApolloLink;\n  public mutationStore: MutationStore = new MutationStore();\n  public queryStore: QueryStore = new QueryStore();\n  public dataStore: DataStore<TStore>;\n\n  private deduplicator: ApolloLink;\n  private queryDeduplication: boolean;\n\n  private onBroadcast: () => void;\n\n  // let's not start at zero to avoid pain with bad checks\n  private idCounter = 1;\n\n  // XXX merge with ObservableQuery but that needs to be expanded to support mutations and\n  // subscriptions as well\n  private queries: Map<string, QueryInfo> = new Map();\n\n  // A map going from a requestId to a promise that has not yet been resolved. We use this to keep\n  // track of queries that are inflight and reject them in case some\n  // destabalizing action occurs (e.g. reset of the Apollo store).\n  private fetchQueryPromises: Map<string, QueryPromise> = new Map();\n\n  // A map going from the name of a query to an observer issued for it by watchQuery. This is\n  // generally used to refetches for refetchQueries and to update mutation results through\n  // updateQueries.\n  private queryIdsByName: { [queryName: string]: string[] } = {};\n\n  constructor({\n    link,\n    queryDeduplication = false,\n    store,\n    onBroadcast = () => undefined,\n    ssrMode = false,\n  }: {\n    link: ApolloLink;\n    queryDeduplication?: boolean;\n    store: DataStore<TStore>;\n    onBroadcast?: () => void;\n    ssrMode?: boolean;\n  }) {\n    this.link = link;\n    this.deduplicator = ApolloLink.from([new Deduplicator(), link]);\n    this.queryDeduplication = queryDeduplication;\n    this.dataStore = store;\n    this.onBroadcast = onBroadcast;\n\n    this.scheduler = new QueryScheduler({ queryManager: this, ssrMode });\n  }\n\n  public mutate<T>({\n    mutation,\n    variables,\n    optimisticResponse,\n    updateQueries: updateQueriesByName,\n    refetchQueries = [],\n    awaitRefetchQueries = false,\n    update: updateWithProxyFn,\n    errorPolicy = 'none',\n    fetchPolicy,\n    context = {},\n  }: MutationOptions): Promise<FetchResult<T>> {\n    if (!mutation) {\n      throw new Error(\n        'mutation option is required. You must specify your GraphQL document in the mutation option.',\n      );\n    }\n\n    if (fetchPolicy && fetchPolicy !== 'no-cache') {\n      throw new Error(\n        \"fetchPolicy for mutations currently only supports the 'no-cache' policy\",\n      );\n    }\n\n    const mutationId = this.generateQueryId();\n    const cache = this.dataStore.getCache();\n    (mutation = cache.transformDocument(mutation)),\n      (variables = assign(\n        {},\n        getDefaultValues(getMutationDefinition(mutation)),\n        variables,\n      ));\n    const mutationString = print(mutation);\n\n    this.setQuery(mutationId, () => ({ document: mutation }));\n\n    // Create a map of update queries by id to the query instead of by name.\n    const generateUpdateQueriesInfo: () => {\n      [queryId: string]: QueryWithUpdater;\n    } = () => {\n      const ret: { [queryId: string]: QueryWithUpdater } = {};\n\n      if (updateQueriesByName) {\n        Object.keys(updateQueriesByName).forEach(queryName =>\n          (this.queryIdsByName[queryName] || []).forEach(queryId => {\n            ret[queryId] = {\n              updater: updateQueriesByName[queryName],\n              query: this.queryStore.get(queryId),\n            };\n          }),\n        );\n      }\n\n      return ret;\n    };\n\n    this.mutationStore.initMutation(mutationId, mutationString, variables);\n\n    this.dataStore.markMutationInit({\n      mutationId,\n      document: mutation,\n      variables: variables || {},\n      updateQueries: generateUpdateQueriesInfo(),\n      update: updateWithProxyFn,\n      optimisticResponse,\n    });\n\n    this.broadcastQueries();\n\n    return new Promise((resolve, reject) => {\n      let storeResult: FetchResult<T> | null;\n      let error: ApolloError;\n\n      const operation = this.buildOperationForLink(mutation, variables, {\n        ...context,\n        optimisticResponse,\n      });\n\n      const completeMutation = async () => {\n        if (error) {\n          this.mutationStore.markMutationError(mutationId, error);\n        }\n\n        this.dataStore.markMutationComplete({\n          mutationId,\n          optimisticResponse,\n        });\n\n        this.broadcastQueries();\n\n        if (error) {\n          throw error;\n        }\n\n        // allow for conditional refetches\n        // XXX do we want to make this the only API one day?\n        if (typeof refetchQueries === 'function') {\n          refetchQueries = refetchQueries(storeResult as ExecutionResult);\n        }\n\n        const refetchQueryPromises: Promise<\n          ApolloQueryResult<any>[] | ApolloQueryResult<{}>\n        >[] = [];\n\n        for (const refetchQuery of refetchQueries) {\n          if (typeof refetchQuery === 'string') {\n            const promise = this.refetchQueryByName(refetchQuery);\n            if (promise) {\n              refetchQueryPromises.push(promise);\n            }\n            continue;\n          }\n\n          const queryOptions: QueryOptions = {\n            query: refetchQuery.query,\n            variables: refetchQuery.variables,\n            fetchPolicy: 'network-only',\n          };\n\n          if (refetchQuery.context) {\n            queryOptions.context = refetchQuery.context;\n          }\n\n          refetchQueryPromises.push(this.query(queryOptions));\n        }\n\n        if (awaitRefetchQueries) {\n          await Promise.all(refetchQueryPromises);\n        }\n\n        this.setQuery(mutationId, () => ({ document: undefined }));\n        if (\n          errorPolicy === 'ignore' &&\n          storeResult &&\n          graphQLResultHasError(storeResult)\n        ) {\n          delete storeResult.errors;\n        }\n\n        return storeResult as FetchResult<T>;\n      };\n\n      execute(this.link, operation).subscribe({\n        next: (result: ExecutionResult) => {\n          if (graphQLResultHasError(result) && errorPolicy === 'none') {\n            error = new ApolloError({\n              graphQLErrors: result.errors,\n            });\n            return;\n          }\n\n          this.mutationStore.markMutationResult(mutationId);\n\n          if (fetchPolicy !== 'no-cache') {\n            this.dataStore.markMutationResult({\n              mutationId,\n              result,\n              document: mutation,\n              variables: variables || {},\n              updateQueries: generateUpdateQueriesInfo(),\n              update: updateWithProxyFn,\n            });\n          }\n          storeResult = result as FetchResult<T>;\n        },\n\n        error: (err: Error) => {\n          this.mutationStore.markMutationError(mutationId, err);\n          this.dataStore.markMutationComplete({\n            mutationId,\n            optimisticResponse,\n          });\n          this.broadcastQueries();\n\n          this.setQuery(mutationId, () => ({ document: undefined }));\n          reject(\n            new ApolloError({\n              networkError: err,\n            }),\n          );\n        },\n\n        complete: () => completeMutation().then(resolve, reject),\n      });\n    });\n  }\n\n  public fetchQuery<T>(\n    queryId: string,\n    options: WatchQueryOptions,\n    fetchType?: FetchType,\n    // This allows us to track if this is a query spawned by a `fetchMore`\n    // call for another query. We need this data to compute the `fetchMore`\n    // network status for the query this is fetching for.\n    fetchMoreForQueryId?: string,\n  ): Promise<FetchResult<T>> {\n    const {\n      variables = {},\n      metadata = null,\n      fetchPolicy = 'cache-first', // cache-first is the default fetch policy.\n    } = options;\n    const cache = this.dataStore.getCache();\n\n    const query = cache.transformDocument(options.query);\n\n    let storeResult: any;\n    let needToFetch: boolean =\n      fetchPolicy === 'network-only' || fetchPolicy === 'no-cache';\n\n    // If this is not a force fetch, we want to diff the query against the\n    // store before we fetch it from the network interface.\n    // TODO we hit the cache even if the policy is network-first. This could be unnecessary if the network is up.\n    if (\n      fetchType !== FetchType.refetch &&\n      fetchPolicy !== 'network-only' &&\n      fetchPolicy !== 'no-cache'\n    ) {\n      const { complete, result } = this.dataStore.getCache().diff({\n        query,\n        variables,\n        returnPartialData: true,\n        optimistic: false,\n      });\n\n      // If we're in here, only fetch if we have missing fields\n      needToFetch = !complete || fetchPolicy === 'cache-and-network';\n      storeResult = result;\n    }\n\n    let shouldFetch =\n      needToFetch && fetchPolicy !== 'cache-only' && fetchPolicy !== 'standby';\n\n    // we need to check to see if this is an operation that uses the @live directive\n    if (hasDirectives(['live'], query)) shouldFetch = true;\n\n    const requestId = this.generateRequestId();\n\n    // set up a watcher to listen to cache updates\n    const cancel = this.updateQueryWatch(queryId, query, options);\n\n    // Initialize query in store with unique requestId\n    this.setQuery(queryId, () => ({\n      document: query,\n      lastRequestId: requestId,\n      invalidated: true,\n      cancel,\n    }));\n\n    this.invalidate(true, fetchMoreForQueryId);\n\n    this.queryStore.initQuery({\n      queryId,\n      document: query,\n      storePreviousVariables: shouldFetch,\n      variables,\n      isPoll: fetchType === FetchType.poll,\n      isRefetch: fetchType === FetchType.refetch,\n      metadata,\n      fetchMoreForQueryId,\n    });\n\n    this.broadcastQueries();\n\n    // If there is no part of the query we need to fetch from the server (or,\n    // fetchPolicy is cache-only), we just write the store result as the final result.\n    const shouldDispatchClientResult =\n      !shouldFetch || fetchPolicy === 'cache-and-network';\n\n    if (shouldDispatchClientResult) {\n      this.queryStore.markQueryResultClient(queryId, !shouldFetch);\n\n      this.invalidate(true, queryId, fetchMoreForQueryId);\n\n      this.broadcastQueries();\n    }\n\n    if (shouldFetch) {\n      const networkResult = this.fetchRequest({\n        requestId,\n        queryId,\n        document: query,\n        options,\n        fetchMoreForQueryId,\n      }).catch(error => {\n        // This is for the benefit of `refetch` promises, which currently don't get their errors\n        // through the store like watchQuery observers do\n        if (isApolloError(error)) {\n          throw error;\n        } else {\n          const { lastRequestId } = this.getQuery(queryId);\n          if (requestId >= (lastRequestId || 1)) {\n            this.queryStore.markQueryError(queryId, error, fetchMoreForQueryId);\n\n            this.invalidate(true, queryId, fetchMoreForQueryId);\n\n            this.broadcastQueries();\n          }\n\n          this.removeFetchQueryPromise(requestId);\n\n          throw new ApolloError({ networkError: error });\n        }\n      });\n\n      // we don't return the promise for cache-and-network since it is already\n      // returned below from the cache\n      if (fetchPolicy !== 'cache-and-network') {\n        return networkResult;\n      } else {\n        // however we need to catch the error so it isn't unhandled in case of\n        // network error\n        networkResult.catch(() => {});\n      }\n    }\n\n    // If we have no query to send to the server, we should return the result\n    // found within the store.\n    return Promise.resolve<ExecutionResult>({ data: storeResult });\n  }\n\n  // Returns a query listener that will update the given observer based on the\n  // results (or lack thereof) for a particular query.\n  public queryListenerForObserver<T>(\n    queryId: string,\n    options: WatchQueryOptions,\n    observer: Observer<ApolloQueryResult<T>>,\n  ): QueryListener {\n    let previouslyHadError: boolean = false;\n    return (\n      queryStoreValue: QueryStoreValue,\n      newData?: Cache.DiffResult<T>,\n    ) => {\n      // we're going to take a look at the data, so the query is no longer invalidated\n      this.invalidate(false, queryId);\n\n      // The query store value can be undefined in the event of a store\n      // reset.\n      if (!queryStoreValue) return;\n\n      const { observableQuery } = this.getQuery(queryId);\n\n      const fetchPolicy = observableQuery\n        ? observableQuery.options.fetchPolicy\n        : options.fetchPolicy;\n\n      // don't watch the store for queries on standby\n      if (fetchPolicy === 'standby') return;\n\n      const errorPolicy = observableQuery\n        ? observableQuery.options.errorPolicy\n        : options.errorPolicy;\n\n      const lastResult = observableQuery\n        ? observableQuery.getLastResult()\n        : null;\n\n      const lastError = observableQuery ? observableQuery.getLastError() : null;\n\n      let shouldNotifyIfLoading =\n        (!newData && queryStoreValue.previousVariables != null) ||\n        fetchPolicy === 'cache-only' ||\n        fetchPolicy === 'cache-and-network';\n\n      // if this caused by a cache broadcast but the query is still in flight\n      // don't notify the observer\n      // if (\n      //   isCacheBroadcast &&\n      //   isNetworkRequestInFlight(queryStoreValue.networkStatus)\n      // ) {\n      //   shouldNotifyIfLoading = false;\n      // }\n\n      const networkStatusChanged = Boolean(\n        lastResult &&\n          queryStoreValue.networkStatus !== lastResult.networkStatus,\n      );\n\n      const errorStatusChanged =\n        errorPolicy &&\n        (lastError && lastError.graphQLErrors) !==\n          queryStoreValue.graphQLErrors &&\n        errorPolicy !== 'none';\n\n      if (\n        !isNetworkRequestInFlight(queryStoreValue.networkStatus) ||\n        (networkStatusChanged && options.notifyOnNetworkStatusChange) ||\n        shouldNotifyIfLoading\n      ) {\n        // If we have either a GraphQL error or a network error, we create\n        // an error and tell the observer about it.\n        if (\n          ((!errorPolicy || errorPolicy === 'none') &&\n            queryStoreValue.graphQLErrors &&\n            queryStoreValue.graphQLErrors.length > 0) ||\n          queryStoreValue.networkError\n        ) {\n          const apolloError = new ApolloError({\n            graphQLErrors: queryStoreValue.graphQLErrors,\n            networkError: queryStoreValue.networkError,\n          });\n          previouslyHadError = true;\n          if (observer.error) {\n            try {\n              observer.error(apolloError);\n            } catch (e) {\n              // Throw error outside this control flow to avoid breaking Apollo's state\n              setTimeout(() => {\n                throw e;\n              }, 0);\n            }\n          } else {\n            // Throw error outside this control flow to avoid breaking Apollo's state\n            setTimeout(() => {\n              throw apolloError;\n            }, 0);\n            if (!isProduction()) {\n              /* tslint:disable-next-line */\n              console.info(\n                'An unhandled error was thrown because no error handler is registered ' +\n                  'for the query ' +\n                  print(queryStoreValue.document),\n              );\n            }\n          }\n          return;\n        }\n\n        try {\n          let data: any;\n          let isMissing: boolean;\n\n          if (newData) {\n            // As long as we're using the cache, clear out the latest\n            // `newData`, since it will now become the current data. We need\n            // to keep the `newData` stored with the query when using\n            // `no-cache` since `getCurrentQueryResult` attemps to pull from\n            // `newData` first, following by trying the cache (which won't\n            // find a hit for `no-cache`).\n            if (fetchPolicy !== 'no-cache') {\n              this.setQuery(queryId, () => ({ newData: null }));\n            }\n\n            data = newData.result;\n            isMissing = !newData.complete || false;\n          } else {\n            if (lastResult && lastResult.data && !errorStatusChanged) {\n              data = lastResult.data;\n              isMissing = false;\n            } else {\n              const { document } = this.getQuery(queryId);\n              const readResult = this.dataStore.getCache().diff({\n                query: document as DocumentNode,\n                variables:\n                  queryStoreValue.previousVariables ||\n                  queryStoreValue.variables,\n                optimistic: true,\n              });\n\n              data = readResult.result;\n              isMissing = !readResult.complete;\n            }\n          }\n\n          let resultFromStore: ApolloQueryResult<T>;\n\n          // If there is some data missing and the user has told us that they\n          // do not tolerate partial data then we want to return the previous\n          // result and mark it as stale.\n          if (isMissing && fetchPolicy !== 'cache-only') {\n            resultFromStore = {\n              data: lastResult && lastResult.data,\n              loading: isNetworkRequestInFlight(queryStoreValue.networkStatus),\n              networkStatus: queryStoreValue.networkStatus,\n              stale: true,\n            };\n          } else {\n            resultFromStore = {\n              data,\n              loading: isNetworkRequestInFlight(queryStoreValue.networkStatus),\n              networkStatus: queryStoreValue.networkStatus,\n              stale: false,\n            };\n          }\n\n          // if the query wants updates on errors we need to add it to the result\n          if (\n            errorPolicy === 'all' &&\n            queryStoreValue.graphQLErrors &&\n            queryStoreValue.graphQLErrors.length > 0\n          ) {\n            resultFromStore.errors = queryStoreValue.graphQLErrors;\n          }\n\n          if (observer.next) {\n            const isDifferentResult = !(\n              lastResult &&\n              resultFromStore &&\n              lastResult.networkStatus === resultFromStore.networkStatus &&\n              lastResult.stale === resultFromStore.stale &&\n              // We can do a strict equality check here because we include a `previousResult`\n              // with `readQueryFromStore`. So if the results are the same they will be\n              // referentially equal.\n              lastResult.data === resultFromStore.data\n            );\n\n            if (isDifferentResult || previouslyHadError) {\n              try {\n                observer.next(maybeDeepFreeze(resultFromStore));\n              } catch (e) {\n                // Throw error outside this control flow to avoid breaking Apollo's state\n                setTimeout(() => {\n                  throw e;\n                }, 0);\n              }\n            }\n          }\n          previouslyHadError = false;\n        } catch (error) {\n          previouslyHadError = true;\n          if (observer.error)\n            observer.error(new ApolloError({ networkError: error }));\n          return;\n        }\n      }\n    };\n  }\n\n  // The shouldSubscribe option is a temporary fix that tells us whether watchQuery was called\n  // directly (i.e. through ApolloClient) or through the query method within QueryManager.\n  // Currently, the query method uses watchQuery in order to handle non-network errors correctly\n  // but we don't want to keep track observables issued for the query method since those aren't\n  // supposed to be refetched in the event of a store reset. Once we unify error handling for\n  // network errors and non-network errors, the shouldSubscribe option will go away.\n\n  public watchQuery<T>(\n    options: WatchQueryOptions,\n    shouldSubscribe = true,\n  ): ObservableQuery<T> {\n    if (options.fetchPolicy === 'standby') {\n      throw new Error(\n        'client.watchQuery cannot be called with fetchPolicy set to \"standby\"',\n      );\n    }\n\n    // get errors synchronously\n    const queryDefinition = getQueryDefinition(options.query);\n\n    // assign variable default values if supplied\n    if (\n      queryDefinition.variableDefinitions &&\n      queryDefinition.variableDefinitions.length\n    ) {\n      const defaultValues = getDefaultValues(queryDefinition);\n\n      options.variables = assign({}, defaultValues, options.variables);\n    }\n\n    if (typeof options.notifyOnNetworkStatusChange === 'undefined') {\n      options.notifyOnNetworkStatusChange = false;\n    }\n\n    let transformedOptions = { ...options } as WatchQueryOptions;\n\n    return new ObservableQuery<T>({\n      scheduler: this.scheduler,\n      options: transformedOptions,\n      shouldSubscribe: shouldSubscribe,\n    });\n  }\n\n  public query<T>(options: QueryOptions): Promise<ApolloQueryResult<T>> {\n    if (!options.query) {\n      throw new Error(\n        'query option is required. You must specify your GraphQL document ' +\n          'in the query option.',\n      );\n    }\n\n    if (options.query.kind !== 'Document') {\n      throw new Error('You must wrap the query string in a \"gql\" tag.');\n    }\n\n    if ((options as any).returnPartialData) {\n      throw new Error('returnPartialData option only supported on watchQuery.');\n    }\n\n    if ((options as any).pollInterval) {\n      throw new Error('pollInterval option only supported on watchQuery.');\n    }\n\n    const requestId = this.idCounter;\n\n    return new Promise<ApolloQueryResult<T>>((resolve, reject) => {\n      this.addFetchQueryPromise<T>(requestId, resolve, reject);\n\n      return this.watchQuery<T>(options, false)\n        .result()\n        .then(result => {\n          this.removeFetchQueryPromise(requestId);\n          resolve(result);\n        })\n        .catch(error => {\n          this.removeFetchQueryPromise(requestId);\n          reject(error);\n        });\n    });\n  }\n\n  public generateQueryId() {\n    const queryId = this.idCounter.toString();\n    this.idCounter++;\n    return queryId;\n  }\n\n  public stopQueryInStore(queryId: string) {\n    this.queryStore.stopQuery(queryId);\n    this.invalidate(true, queryId);\n    this.broadcastQueries();\n  }\n\n  public addQueryListener(queryId: string, listener: QueryListener) {\n    this.setQuery(queryId, ({ listeners = [] }) => ({\n      listeners: listeners.concat([listener]),\n      invalidate: false,\n    }));\n  }\n\n  public updateQueryWatch(\n    queryId: string,\n    document: DocumentNode,\n    options: WatchQueryOptions,\n  ) {\n    const { cancel } = this.getQuery(queryId);\n    if (cancel) cancel();\n    const previousResult = () => {\n      let previousResult = null;\n      const { observableQuery } = this.getQuery(queryId);\n      if (observableQuery) {\n        const lastResult = observableQuery.getLastResult();\n        if (lastResult) {\n          previousResult = lastResult.data;\n        }\n      }\n\n      return previousResult;\n    };\n    return this.dataStore.getCache().watch({\n      query: document as DocumentNode,\n      variables: options.variables,\n      optimistic: true,\n      previousResult,\n      callback: (newData: ApolloQueryResult<any>) => {\n        this.setQuery(queryId, () => ({ invalidated: true, newData }));\n      },\n    });\n  }\n\n  // Adds a promise to this.fetchQueryPromises for a given request ID.\n  public addFetchQueryPromise<T>(\n    requestId: number,\n    resolve: (result: ApolloQueryResult<T>) => void,\n    reject: (error: Error) => void,\n  ) {\n    this.fetchQueryPromises.set(requestId.toString(), {\n      resolve,\n      reject,\n    });\n  }\n\n  // Removes the promise in this.fetchQueryPromises for a particular request ID.\n  public removeFetchQueryPromise(requestId: number) {\n    this.fetchQueryPromises.delete(requestId.toString());\n  }\n\n  // Adds an ObservableQuery to this.observableQueries and to this.observableQueriesByName.\n  public addObservableQuery<T>(\n    queryId: string,\n    observableQuery: ObservableQuery<T>,\n  ) {\n    this.setQuery(queryId, () => ({ observableQuery }));\n\n    // Insert the ObservableQuery into this.observableQueriesByName if the query has a name\n    const queryDef = getQueryDefinition(observableQuery.options.query);\n    if (queryDef.name && queryDef.name.value) {\n      const queryName = queryDef.name.value;\n\n      // XXX we may we want to warn the user about query name conflicts in the future\n      this.queryIdsByName[queryName] = this.queryIdsByName[queryName] || [];\n      this.queryIdsByName[queryName].push(observableQuery.queryId);\n    }\n  }\n\n  public removeObservableQuery(queryId: string) {\n    const { observableQuery, cancel } = this.getQuery(queryId);\n    if (cancel) cancel();\n    if (!observableQuery) return;\n\n    const definition = getQueryDefinition(observableQuery.options.query);\n    const queryName = definition.name ? definition.name.value : null;\n    this.setQuery(queryId, () => ({ observableQuery: null }));\n    if (queryName) {\n      this.queryIdsByName[queryName] = this.queryIdsByName[queryName].filter(\n        val => {\n          return !(observableQuery.queryId === val);\n        },\n      );\n    }\n  }\n\n  public clearStore(): Promise<void> {\n    // Before we have sent the reset action to the store,\n    // we can no longer rely on the results returned by in-flight\n    // requests since these may depend on values that previously existed\n    // in the data portion of the store. So, we cancel the promises and observers\n    // that we have issued so far and not yet resolved (in the case of\n    // queries).\n    this.fetchQueryPromises.forEach(({ reject }) => {\n      reject(\n        new Error(\n          'Store reset while query was in flight(not completed in link chain)',\n        ),\n      );\n    });\n\n    const resetIds: string[] = [];\n    this.queries.forEach(({ observableQuery }, queryId) => {\n      if (observableQuery) resetIds.push(queryId);\n    });\n\n    this.queryStore.reset(resetIds);\n    this.mutationStore.reset();\n\n    // begin removing data from the store\n    const reset = this.dataStore.reset();\n    return reset;\n  }\n\n  public resetStore(): Promise<ApolloQueryResult<any>[]> {\n    // Similarly, we have to have to refetch each of the queries currently being\n    // observed. We refetch instead of error'ing on these since the assumption is that\n    // resetting the store doesn't eliminate the need for the queries currently being\n    // watched. If there is an existing query in flight when the store is reset,\n    // the promise for it will be rejected and its results will not be written to the\n    // store.\n    return this.clearStore().then(() => {\n      return this.reFetchObservableQueries();\n    });\n  }\n\n  public reFetchObservableQueries(\n    includeStandby?: boolean,\n  ): Promise<ApolloQueryResult<any>[]> {\n    const observableQueryPromises: Promise<\n      ApolloQueryResult<any>\n    >[] = this.getObservableQueryPromises(includeStandby);\n\n    this.broadcastQueries();\n\n    return Promise.all(observableQueryPromises);\n  }\n\n  public startQuery<T>(\n    queryId: string,\n    options: WatchQueryOptions,\n    listener: QueryListener,\n  ) {\n    this.addQueryListener(queryId, listener);\n\n    this.fetchQuery<T>(queryId, options)\n      // `fetchQuery` returns a Promise. In case of a failure it should be caucht or else the\n      // console will show an `Uncaught (in promise)` message. Ignore the error for now.\n      .catch(() => undefined);\n\n    return queryId;\n  }\n\n  public startGraphQLSubscription(\n    options: SubscriptionOptions,\n  ): Observable<any> {\n    const { query } = options;\n    const isCacheEnabled = !(\n      options.fetchPolicy && options.fetchPolicy === 'no-cache'\n    );\n    const cache = this.dataStore.getCache();\n    let transformedDoc = cache.transformDocument(query);\n\n    const variables = assign(\n      {},\n      getDefaultValues(getOperationDefinition(query)),\n      options.variables,\n    );\n\n    let sub: Subscription;\n    let observers: Observer<any>[] = [];\n\n    return new Observable(observer => {\n      observers.push(observer);\n\n      // If this is the first observer, actually initiate the network\n      // subscription.\n      if (observers.length === 1) {\n        const handler = {\n          next: (result: FetchResult) => {\n            if (isCacheEnabled) {\n              this.dataStore.markSubscriptionResult(\n                result,\n                transformedDoc,\n                variables,\n              );\n              this.broadcastQueries();\n            }\n\n            observers.forEach(obs => {\n              // If an error exists and a `error` handler has been defined on\n              // the observer, call that `error` handler and make sure the\n              // `next` handler is skipped. If no `error` handler exists, we're\n              // still passing any errors that might occur into the `next`\n              // handler, to give that handler a chance to deal with the\n              // error (we're doing this for backwards compatibilty).\n              if (graphQLResultHasError(result) && obs.error) {\n                obs.error(\n                  new ApolloError({\n                    graphQLErrors: result.errors,\n                  }),\n                );\n              } else if (obs.next) {\n                obs.next(result);\n              }\n            });\n          },\n          error: (error: Error) => {\n            observers.forEach(obs => {\n              if (obs.error) {\n                obs.error(error);\n              }\n            });\n          },\n        };\n\n        // TODO: Should subscriptions also accept a `context` option to pass\n        // through to links?\n        const operation = this.buildOperationForLink(transformedDoc, variables);\n        sub = execute(this.link, operation).subscribe(handler);\n      }\n\n      return () => {\n        observers = observers.filter(obs => obs !== observer);\n\n        // If we removed the last observer, tear down the network subscription\n        if (observers.length === 0 && sub) {\n          sub.unsubscribe();\n        }\n      };\n    });\n  }\n\n  public stopQuery(queryId: string) {\n    this.stopQueryInStore(queryId);\n    this.removeQuery(queryId);\n  }\n\n  public removeQuery(queryId: string) {\n    const { subscriptions } = this.getQuery(queryId);\n    // teardown all links\n    subscriptions.forEach(x => x.unsubscribe());\n    this.queries.delete(queryId);\n  }\n\n  public getCurrentQueryResult<T>(\n    observableQuery: ObservableQuery<T>,\n    optimistic: boolean = true,\n  ) {\n    const { variables, query } = observableQuery.options;\n    const lastResult = observableQuery.getLastResult();\n    const { newData } = this.getQuery(observableQuery.queryId);\n    // XXX test this\n    if (newData) {\n      return maybeDeepFreeze({ data: newData.result, partial: false });\n    } else {\n      try {\n        // the query is brand new, so we read from the store to see if anything is there\n        const data = this.dataStore.getCache().read({\n          query,\n          variables,\n          previousResult: lastResult ? lastResult.data : undefined,\n          optimistic,\n        });\n\n        return maybeDeepFreeze({ data, partial: false });\n      } catch (e) {\n        return maybeDeepFreeze({ data: {}, partial: true });\n      }\n    }\n  }\n\n  public getQueryWithPreviousResult<T>(\n    queryIdOrObservable: string | ObservableQuery<T>,\n  ): {\n    previousResult: any;\n    variables: OperationVariables | undefined;\n    document: DocumentNode;\n  } {\n    let observableQuery: ObservableQuery<T>;\n    if (typeof queryIdOrObservable === 'string') {\n      const { observableQuery: foundObserveableQuery } = this.getQuery(\n        queryIdOrObservable,\n      );\n      if (!foundObserveableQuery) {\n        throw new Error(\n          `ObservableQuery with this id doesn't exist: ${queryIdOrObservable}`,\n        );\n      }\n      observableQuery = foundObserveableQuery;\n    } else {\n      observableQuery = queryIdOrObservable;\n    }\n\n    const { variables, query } = observableQuery.options;\n\n    const { data } = this.getCurrentQueryResult(observableQuery, false);\n\n    return {\n      previousResult: data,\n      variables,\n      document: query,\n    };\n  }\n\n  public broadcastQueries() {\n    this.onBroadcast();\n    this.queries.forEach((info, id) => {\n      if (!info.invalidated || !info.listeners) return;\n      info.listeners\n        // it's possible for the listener to be undefined if the query is being stopped\n        // See here for more detail: https://github.com/apollostack/apollo-client/issues/231\n        .filter((x: QueryListener) => !!x)\n        .forEach((listener: QueryListener) => {\n          listener(this.queryStore.get(id), info.newData);\n        });\n    });\n  }\n\n  private getObservableQueryPromises(\n    includeStandby?: boolean,\n  ): Promise<ApolloQueryResult<any>>[] {\n    const observableQueryPromises: Promise<ApolloQueryResult<any>>[] = [];\n    this.queries.forEach(({ observableQuery }, queryId) => {\n      if (!observableQuery) return;\n      const fetchPolicy = observableQuery.options.fetchPolicy;\n\n      observableQuery.resetLastResults();\n      if (\n        fetchPolicy !== 'cache-only' &&\n        (includeStandby || fetchPolicy !== 'standby')\n      ) {\n        observableQueryPromises.push(observableQuery.refetch());\n      }\n\n      this.setQuery(queryId, () => ({ newData: null }));\n      this.invalidate(true, queryId);\n    });\n\n    return observableQueryPromises;\n  }\n\n  // Takes a request id, query id, a query document and information associated with the query\n  // and send it to the network interface. Returns\n  // a promise for the result associated with that request.\n  private fetchRequest<T>({\n    requestId,\n    queryId,\n    document,\n    options,\n    fetchMoreForQueryId,\n  }: {\n    requestId: number;\n    queryId: string;\n    document: DocumentNode;\n    options: WatchQueryOptions;\n    fetchMoreForQueryId?: string;\n  }): Promise<ExecutionResult> {\n    const { variables, context, errorPolicy = 'none', fetchPolicy } = options;\n    const operation = this.buildOperationForLink(document, variables, {\n      ...context,\n      // TODO: Should this be included for all entry points via\n      // buildOperationForLink?\n      forceFetch: !this.queryDeduplication,\n    });\n\n    let resultFromStore: any;\n    let errorsFromStore: any;\n\n    return new Promise<ApolloQueryResult<T>>((resolve, reject) => {\n      this.addFetchQueryPromise<T>(requestId, resolve, reject);\n      const subscription = execute(this.deduplicator, operation).subscribe({\n        next: (result: ExecutionResult) => {\n          // default the lastRequestId to 1\n          const { lastRequestId } = this.getQuery(queryId);\n          if (requestId >= (lastRequestId || 1)) {\n            if (fetchPolicy !== 'no-cache') {\n              try {\n                this.dataStore.markQueryResult(\n                  result,\n                  document,\n                  variables,\n                  fetchMoreForQueryId,\n                  errorPolicy === 'ignore' || errorPolicy === 'all',\n                );\n              } catch (e) {\n                reject(e);\n                return;\n              }\n            } else {\n              this.setQuery(queryId, () => ({\n                newData: { result: result.data, complete: true },\n              }));\n            }\n\n            this.queryStore.markQueryResult(\n              queryId,\n              result,\n              fetchMoreForQueryId,\n            );\n\n            this.invalidate(true, queryId, fetchMoreForQueryId);\n\n            this.broadcastQueries();\n          }\n\n          if (result.errors && errorPolicy === 'none') {\n            reject(\n              new ApolloError({\n                graphQLErrors: result.errors,\n              }),\n            );\n            return;\n          } else if (errorPolicy === 'all') {\n            errorsFromStore = result.errors;\n          }\n\n          if (fetchMoreForQueryId || fetchPolicy === 'no-cache') {\n            // We don't write fetchMore results to the store because this would overwrite\n            // the original result in case an @connection directive is used.\n            resultFromStore = result.data;\n          } else {\n            try {\n              // ensure result is combined with data already in store\n              resultFromStore = this.dataStore.getCache().read({\n                variables,\n                query: document,\n                optimistic: false,\n              });\n              // this will throw an error if there are missing fields in\n              // the results which can happen with errors from the server.\n              // tslint:disable-next-line\n            } catch (e) {}\n          }\n        },\n        error: (error: ApolloError) => {\n          this.removeFetchQueryPromise(requestId);\n          this.setQuery(queryId, ({ subscriptions }) => ({\n            subscriptions: subscriptions.filter(x => x !== subscription),\n          }));\n\n          reject(error);\n        },\n        complete: () => {\n          this.removeFetchQueryPromise(requestId);\n          this.setQuery(queryId, ({ subscriptions }) => ({\n            subscriptions: subscriptions.filter(x => x !== subscription),\n          }));\n\n          resolve({\n            data: resultFromStore,\n            errors: errorsFromStore,\n            loading: false,\n            networkStatus: NetworkStatus.ready,\n            stale: false,\n          });\n        },\n      });\n\n      this.setQuery(queryId, ({ subscriptions }) => ({\n        subscriptions: subscriptions.concat([subscription]),\n      }));\n    });\n  }\n\n  // Refetches a query given that query's name. Refetches\n  // all ObservableQuery instances associated with the query name.\n  private refetchQueryByName(queryName: string) {\n    const refetchedQueries = this.queryIdsByName[queryName];\n    // early return if the query named does not exist (not yet fetched)\n    // this used to warn but it may be inteneded behavoir to try and refetch\n    // un called queries because they could be on different routes\n    if (refetchedQueries === undefined) return;\n    return Promise.all(\n      refetchedQueries\n        .map(id => this.getQuery(id).observableQuery)\n        .filter(x => !!x)\n        .map((x: ObservableQuery<any>) => x.refetch()),\n    );\n  }\n\n  private generateRequestId() {\n    const requestId = this.idCounter;\n    this.idCounter++;\n    return requestId;\n  }\n\n  private getQuery(queryId: string) {\n    return this.queries.get(queryId) || { ...defaultQueryInfo };\n  }\n\n  private setQuery(queryId: string, updater: (prev: QueryInfo) => any) {\n    const prev = this.getQuery(queryId);\n    const newInfo = { ...prev, ...updater(prev) };\n    this.queries.set(queryId, newInfo);\n  }\n\n  private invalidate(\n    invalidated: boolean,\n    queryId?: string,\n    fetchMoreForQueryId?: string,\n  ) {\n    if (queryId) this.setQuery(queryId, () => ({ invalidated }));\n\n    if (fetchMoreForQueryId) {\n      this.setQuery(fetchMoreForQueryId, () => ({ invalidated }));\n    }\n  }\n\n  private buildOperationForLink(\n    document: DocumentNode,\n    variables: any,\n    extraContext?: any,\n  ) {\n    const cache = this.dataStore.getCache();\n\n    return {\n      query: cache.transformForLink\n        ? cache.transformForLink(document)\n        : document,\n      variables,\n      operationName: getOperationName(document) || undefined,\n      context: {\n        ...extraContext,\n        cache,\n        // getting an entry's cache key is useful for cacheResolvers & state-link\n        getCacheKey: (obj: { __typename: string; id: string | number }) => {\n          if ((cache as any).config) {\n            // on the link, we just want the id string, not the full id value from toIdValue\n            return (cache as any).config.dataIdFromObject(obj);\n          } else {\n            throw new Error(\n              'To use context.getCacheKey, you need to use a cache that has a configurable dataIdFromObject, like apollo-cache-inmemory.',\n            );\n          }\n        },\n      },\n    };\n  }\n}\n","import { ExecutionResult, DocumentNode } from 'graphql';\nimport { ApolloCache, Cache, DataProxy } from 'apollo-cache';\n\nimport { QueryStoreValue } from '../data/queries';\nimport {\n  getOperationName,\n  tryFunctionOrLogError,\n  graphQLResultHasError,\n} from 'apollo-utilities';\nimport { MutationQueryReducer } from '../core/types';\n\nexport type QueryWithUpdater = {\n  updater: MutationQueryReducer<Object>;\n  query: QueryStoreValue;\n};\n\nexport interface DataWrite {\n  rootId: string;\n  result: any;\n  document: DocumentNode;\n  operationName: string | null;\n  variables: Object;\n}\n\nexport class DataStore<TSerialized> {\n  private cache: ApolloCache<TSerialized>;\n\n  constructor(initialCache: ApolloCache<TSerialized>) {\n    this.cache = initialCache;\n  }\n\n  public getCache(): ApolloCache<TSerialized> {\n    return this.cache;\n  }\n\n  public markQueryResult(\n    result: ExecutionResult,\n    document: DocumentNode,\n    variables: any,\n    fetchMoreForQueryId: string | undefined,\n    ignoreErrors: boolean = false,\n  ) {\n    let writeWithErrors = !graphQLResultHasError(result);\n    if (ignoreErrors && graphQLResultHasError(result) && result.data) {\n      writeWithErrors = true;\n    }\n    if (!fetchMoreForQueryId && writeWithErrors) {\n      this.cache.write({\n        result: result.data,\n        dataId: 'ROOT_QUERY',\n        query: document,\n        variables: variables,\n      });\n    }\n  }\n\n  public markSubscriptionResult(\n    result: ExecutionResult,\n    document: DocumentNode,\n    variables: any,\n  ) {\n    // the subscription interface should handle not sending us results we no longer subscribe to.\n    // XXX I don't think we ever send in an object with errors, but we might in the future...\n    if (!graphQLResultHasError(result)) {\n      this.cache.write({\n        result: result.data,\n        dataId: 'ROOT_SUBSCRIPTION',\n        query: document,\n        variables: variables,\n      });\n    }\n  }\n\n  public markMutationInit(mutation: {\n    mutationId: string;\n    document: DocumentNode;\n    variables: any;\n    updateQueries: { [queryId: string]: QueryWithUpdater };\n    update: ((proxy: DataProxy, mutationResult: Object) => void) | undefined;\n    optimisticResponse: Object | Function | undefined;\n  }) {\n    if (mutation.optimisticResponse) {\n      let optimistic: Object;\n      if (typeof mutation.optimisticResponse === 'function') {\n        optimistic = mutation.optimisticResponse(mutation.variables);\n      } else {\n        optimistic = mutation.optimisticResponse;\n      }\n\n      const changeFn = () => {\n        this.markMutationResult({\n          mutationId: mutation.mutationId,\n          result: { data: optimistic },\n          document: mutation.document,\n          variables: mutation.variables,\n          updateQueries: mutation.updateQueries,\n          update: mutation.update,\n        });\n      };\n\n      this.cache.recordOptimisticTransaction(c => {\n        const orig = this.cache;\n        this.cache = c;\n\n        try {\n          changeFn();\n        } finally {\n          this.cache = orig;\n        }\n      }, mutation.mutationId);\n    }\n  }\n\n  public markMutationResult(mutation: {\n    mutationId: string;\n    result: ExecutionResult;\n    document: DocumentNode;\n    variables: any;\n    updateQueries: { [queryId: string]: QueryWithUpdater };\n    update: ((proxy: DataProxy, mutationResult: Object) => void) | undefined;\n  }) {\n    // Incorporate the result from this mutation into the store\n    if (!graphQLResultHasError(mutation.result)) {\n      const cacheWrites: Cache.WriteOptions[] = [];\n      cacheWrites.push({\n        result: mutation.result.data,\n        dataId: 'ROOT_MUTATION',\n        query: mutation.document,\n        variables: mutation.variables,\n      });\n\n      if (mutation.updateQueries) {\n        Object.keys(mutation.updateQueries)\n          .filter(id => mutation.updateQueries[id])\n          .forEach(queryId => {\n            const { query, updater } = mutation.updateQueries[queryId];\n            // Read the current query result from the store.\n            const { result: currentQueryResult, complete } = this.cache.diff({\n              query: query.document,\n              variables: query.variables,\n              returnPartialData: true,\n              optimistic: false,\n            });\n\n            if (!complete) {\n              return;\n            }\n\n            // Run our reducer using the current query result and the mutation result.\n            const nextQueryResult = tryFunctionOrLogError(() =>\n              updater(currentQueryResult, {\n                mutationResult: mutation.result,\n                queryName: getOperationName(query.document) || undefined,\n                queryVariables: query.variables,\n              }),\n            );\n\n            // Write the modified result back into the store if we got a new result.\n            if (nextQueryResult) {\n              cacheWrites.push({\n                result: nextQueryResult,\n                dataId: 'ROOT_QUERY',\n                query: query.document,\n                variables: query.variables,\n              });\n            }\n          });\n      }\n\n      this.cache.performTransaction(c => {\n        cacheWrites.forEach(write => c.write(write));\n      });\n\n      // If the mutation has some writes associated with it then we need to\n      // apply those writes to the store by running this reducer again with a\n      // write action.\n      const update = mutation.update;\n      if (update) {\n        this.cache.performTransaction(c => {\n          tryFunctionOrLogError(() => update(c, mutation.result));\n        });\n      }\n    }\n  }\n\n  public markMutationComplete({\n    mutationId,\n    optimisticResponse,\n  }: {\n    mutationId: string;\n    optimisticResponse?: any;\n  }) {\n    if (!optimisticResponse) return;\n    this.cache.removeOptimistic(mutationId);\n  }\n\n  public markUpdateQueryResult(\n    document: DocumentNode,\n    variables: any,\n    newResult: any,\n  ) {\n    this.cache.write({\n      result: newResult,\n      dataId: 'ROOT_QUERY',\n      variables,\n      query: document,\n    });\n  }\n\n  public reset(): Promise<void> {\n    return this.cache.reset();\n  }\n}\n","export const version = 'local';\n","import {\n  ApolloLink,\n  Operation,\n  NextLink,\n  FetchResult,\n  GraphQLRequest,\n  execute,\n} from 'apollo-link';\nimport { ExecutionResult } from 'graphql';\nimport { ApolloCache, DataProxy } from 'apollo-cache';\nimport {\n  isProduction,\n  removeConnectionDirectiveFromDocument,\n} from 'apollo-utilities';\n\nimport { QueryManager } from './core/QueryManager';\nimport { ApolloQueryResult, OperationVariables } from './core/types';\nimport { ObservableQuery } from './core/ObservableQuery';\n\nimport { Observable } from './util/Observable';\n\nimport {\n  QueryBaseOptions,\n  QueryOptions,\n  WatchQueryOptions,\n  SubscriptionOptions,\n  MutationOptions,\n  ModifiableWatchQueryOptions,\n  MutationBaseOptions,\n} from './core/watchQueryOptions';\n\nimport { DataStore } from './data/store';\n\nimport { version } from './version';\n\nexport interface DefaultOptions {\n  watchQuery?: ModifiableWatchQueryOptions;\n  query?: QueryBaseOptions;\n  mutate?: MutationBaseOptions;\n}\n\nlet hasSuggestedDevtools = false;\n\nexport type ApolloClientOptions<TCacheShape> = {\n  link: ApolloLink;\n  cache: ApolloCache<TCacheShape>;\n  ssrMode?: boolean;\n  ssrForceFetchDelay?: number;\n  connectToDevTools?: boolean;\n  queryDeduplication?: boolean;\n  defaultOptions?: DefaultOptions;\n};\n\nconst supportedDirectives = new ApolloLink(\n  (operation: Operation, forward: NextLink) => {\n    operation.query = removeConnectionDirectiveFromDocument(operation.query);\n    return forward(operation);\n  },\n);\n\n/**\n * This is the primary Apollo Client class. It is used to send GraphQL documents (i.e. queries\n * and mutations) to a GraphQL spec-compliant server over a {@link NetworkInterface} instance,\n * receive results from the server and cache the results in a store. It also delivers updates\n * to GraphQL queries through {@link Observable} instances.\n */\nexport default class ApolloClient<TCacheShape> implements DataProxy {\n  public link: ApolloLink;\n  public store: DataStore<TCacheShape>;\n  public cache: ApolloCache<TCacheShape>;\n  public queryManager: QueryManager<TCacheShape> | undefined;\n  public disableNetworkFetches: boolean;\n  public version: string;\n  public queryDeduplication: boolean;\n  public defaultOptions: DefaultOptions = {};\n\n  private devToolsHookCb: Function;\n  private proxy: ApolloCache<TCacheShape> | undefined;\n  private ssrMode: boolean;\n  private resetStoreCallbacks: Array<() => Promise<any>> = [];\n\n  /**\n   * Constructs an instance of {@link ApolloClient}.\n   *\n   * @param link The {@link ApolloLink} over which GraphQL documents will be resolved into a response.\n   *\n   * @param cache The initial cache to use in the data store.\n   *\n   * @param ssrMode Determines whether this is being run in Server Side Rendering (SSR) mode.\n   *\n   * @param ssrForceFetchDelay Determines the time interval before we force fetch queries for a\n   * server side render.\n   *\n   * @param queryDeduplication If set to false, a query will still be sent to the server even if a query\n   * with identical parameters (query, variables, operationName) is already in flight.\n   *\n   */\n\n  constructor(options: ApolloClientOptions<TCacheShape>) {\n    const {\n      link,\n      cache,\n      ssrMode = false,\n      ssrForceFetchDelay = 0,\n      connectToDevTools,\n      queryDeduplication = true,\n      defaultOptions,\n    } = options;\n\n    if (!link || !cache) {\n      throw new Error(`\n        In order to initialize Apollo Client, you must specify link & cache properties on the config object.\n        This is part of the required upgrade when migrating from Apollo Client 1.0 to Apollo Client 2.0.\n        For more information, please visit:\n          https://www.apollographql.com/docs/react/basics/setup.html\n        to help you get started.\n      `);\n    }\n\n    // remove apollo-client supported directives\n    this.link = supportedDirectives.concat(link);\n    this.cache = cache;\n    this.store = new DataStore(cache);\n    this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;\n    this.queryDeduplication = queryDeduplication;\n    this.ssrMode = ssrMode;\n    this.defaultOptions = defaultOptions || {};\n\n    if (ssrForceFetchDelay) {\n      setTimeout(\n        () => (this.disableNetworkFetches = false),\n        ssrForceFetchDelay,\n      );\n    }\n\n    this.watchQuery = this.watchQuery.bind(this);\n    this.query = this.query.bind(this);\n    this.mutate = this.mutate.bind(this);\n    this.resetStore = this.resetStore.bind(this);\n    this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);\n\n    // Attach the client instance to window to let us be found by chrome devtools, but only in\n    // development mode\n    const defaultConnectToDevTools =\n      !isProduction() &&\n      typeof window !== 'undefined' &&\n      !(window as any).__APOLLO_CLIENT__;\n\n    if (\n      typeof connectToDevTools === 'undefined'\n        ? defaultConnectToDevTools\n        : connectToDevTools && typeof window !== 'undefined'\n    ) {\n      (window as any).__APOLLO_CLIENT__ = this;\n    }\n\n    /**\n     * Suggest installing the devtools for developers who don't have them\n     */\n    if (!hasSuggestedDevtools && !isProduction()) {\n      hasSuggestedDevtools = true;\n      if (\n        typeof window !== 'undefined' &&\n        window.document &&\n        window.top === window.self\n      ) {\n        // First check if devtools is not installed\n        if (\n          typeof (window as any).__APOLLO_DEVTOOLS_GLOBAL_HOOK__ === 'undefined'\n        ) {\n          // Only for Chrome\n          if (\n            window.navigator &&\n            window.navigator.userAgent.indexOf('Chrome') > -1\n          ) {\n            // tslint:disable-next-line\n            console.debug(\n              'Download the Apollo DevTools ' +\n                'for a better development experience: ' +\n                'https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm',\n            );\n          }\n        }\n      }\n    }\n    this.version = version;\n  }\n  /**\n   * This watches the cache store of the query according to the options specified and\n   * returns an {@link ObservableQuery}. We can subscribe to this {@link ObservableQuery} and\n   * receive updated results through a GraphQL observer when the cache store changes.\n   * <p /><p />\n   * Note that this method is not an implementation of GraphQL subscriptions. Rather,\n   * it uses Apollo's store in order to reactively deliver updates to your query results.\n   * <p /><p />\n   * For example, suppose you call watchQuery on a GraphQL query that fetches a person's\n   * first and last name and this person has a particular object identifer, provided by\n   * dataIdFromObject. Later, a different query fetches that same person's\n   * first and last name and the first name has now changed. Then, any observers associated\n   * with the results of the first query will be updated with a new result object.\n   * <p /><p />\n   * Note that if the cache does not change, the subscriber will *not* be notified.\n   * <p /><p />\n   * See [here](https://medium.com/apollo-stack/the-concepts-of-graphql-bc68bd819be3#.3mb0cbcmc) for\n   * a description of store reactivity.\n   */\n  public watchQuery<T, TVariables = OperationVariables>(\n    options: WatchQueryOptions<TVariables>,\n  ): ObservableQuery<T> {\n    if (this.defaultOptions.watchQuery) {\n      options = {\n        ...this.defaultOptions.watchQuery,\n        ...options,\n      } as WatchQueryOptions<TVariables>;\n    }\n\n    // XXX Overwriting options is probably not the best way to do this long term...\n    if (\n      this.disableNetworkFetches &&\n      (options.fetchPolicy === 'network-only' ||\n        options.fetchPolicy === 'cache-and-network')\n    ) {\n      options = { ...options, fetchPolicy: 'cache-first' };\n    }\n\n    return this.initQueryManager().watchQuery<T>(options);\n  }\n\n  /**\n   * This resolves a single query according to the options specified and\n   * returns a {@link Promise} which is either resolved with the resulting data\n   * or rejected with an error.\n   *\n   * @param options An object of type {@link QueryOptions} that allows us to\n   * describe how this query should be treated e.g. whether it should hit the\n   * server at all or just resolve from the cache, etc.\n   */\n  public query<T, TVariables = OperationVariables>(\n    options: QueryOptions<TVariables>,\n  ): Promise<ApolloQueryResult<T>> {\n    if (this.defaultOptions.query) {\n      options = { ...this.defaultOptions.query, ...options } as QueryOptions<\n        TVariables\n      >;\n    }\n\n    if (options.fetchPolicy === 'cache-and-network') {\n      throw new Error(\n        'cache-and-network fetchPolicy can only be used with watchQuery',\n      );\n    }\n\n    // XXX Overwriting options is probably not the best way to do this long\n    // term...\n    if (this.disableNetworkFetches && options.fetchPolicy === 'network-only') {\n      options = { ...options, fetchPolicy: 'cache-first' };\n    }\n\n    return this.initQueryManager().query<T>(options);\n  }\n\n  /**\n   * This resolves a single mutation according to the options specified and returns a\n   * {@link Promise} which is either resolved with the resulting data or rejected with an\n   * error.\n   *\n   * It takes options as an object with the following keys and values:\n   */\n  public mutate<T, TVariables = OperationVariables>(\n    options: MutationOptions<T, TVariables>,\n  ): Promise<FetchResult<T>> {\n    if (this.defaultOptions.mutate) {\n      options = {\n        ...this.defaultOptions.mutate,\n        ...options,\n      } as MutationOptions<T, TVariables>;\n    }\n\n    return this.initQueryManager().mutate<T>(options);\n  }\n\n  /**\n   * This subscribes to a graphql subscription according to the options specified and returns an\n   * {@link Observable} which either emits received data or an error.\n   */\n  public subscribe<T = any, TVariables = OperationVariables>(\n    options: SubscriptionOptions<TVariables>,\n  ): Observable<T> {\n    return this.initQueryManager().startGraphQLSubscription(options);\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL query without making a network request. This method will start at\n   * the root query. To start at a specific id returned by `dataIdFromObject`\n   * use `readFragment`.\n   *\n   * @param optimistic Set to `true` to allow `readQuery` to return\n   * optimisic results. Is `false` by default.\n   */\n  public readQuery<T, TVariables = OperationVariables>(\n    options: DataProxy.Query<TVariables>,\n    optimistic: boolean = false,\n  ): T | null {\n    return this.initProxy().readQuery<T>(options, optimistic);\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL fragment without making a network request. This method will read a\n   * GraphQL fragment from any arbitrary id that is currently cached, unlike\n   * `readQuery` which will only read from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are reading. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   *\n   * @param optimistic Set to `true` to allow `readFragment` to return\n   * optimisic results. Is `false` by default.\n   */\n  public readFragment<T, TVariables = OperationVariables>(\n    options: DataProxy.Fragment<TVariables>,\n    optimistic: boolean = false,\n  ): T | null {\n    return this.initProxy().readFragment<T>(options, optimistic);\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL query directly to\n   * the store. This method will start at the root query. To start at a a\n   * specific id returned by `dataIdFromObject` then use `writeFragment`.\n   */\n  public writeQuery<TData = any, TVariables = OperationVariables>(\n    options: DataProxy.WriteQueryOptions<TData, TVariables>,\n  ): void {\n    const result = this.initProxy().writeQuery(options);\n    this.initQueryManager().broadcastQueries();\n    return result;\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL fragment directly to\n   * the store. This method will write to a GraphQL fragment from any arbitrary\n   * id that is currently cached, unlike `writeQuery` which will only write\n   * from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are writing. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   */\n  public writeFragment<TData = any, TVariables = OperationVariables>(\n    options: DataProxy.WriteFragmentOptions<TData, TVariables>,\n  ): void {\n    const result = this.initProxy().writeFragment(options);\n    this.initQueryManager().broadcastQueries();\n    return result;\n  }\n\n  /**\n   * Sugar for writeQuery & writeFragment\n   * This method will construct a query from the data object passed in.\n   * If no id is supplied, writeData will write the data to the root.\n   * If an id is supplied, writeData will write a fragment to the object\n   * specified by the id in the store.\n   *\n   * Since you aren't passing in a query to check the shape of the data,\n   * you must pass in an object that conforms to the shape of valid GraphQL data.\n   */\n  public writeData<TData = any>(\n    options: DataProxy.WriteDataOptions<TData>,\n  ): void {\n    const result = this.initProxy().writeData(options);\n    this.initQueryManager().broadcastQueries();\n    return result;\n  }\n\n  public __actionHookForDevTools(cb: () => any) {\n    this.devToolsHookCb = cb;\n  }\n\n  public __requestRaw(payload: GraphQLRequest): Observable<ExecutionResult> {\n    return execute(this.link, payload);\n  }\n\n  /**\n   * This initializes the query manager that tracks queries and the cache\n   */\n  public initQueryManager(): QueryManager<TCacheShape> {\n    if (!this.queryManager) {\n      this.queryManager = new QueryManager({\n        link: this.link,\n        store: this.store,\n        queryDeduplication: this.queryDeduplication,\n        ssrMode: this.ssrMode,\n        onBroadcast: () => {\n          if (this.devToolsHookCb) {\n            this.devToolsHookCb({\n              action: {},\n              state: {\n                queries: this.queryManager\n                  ? this.queryManager.queryStore.getStore()\n                  : {},\n                mutations: this.queryManager\n                  ? this.queryManager.mutationStore.getStore()\n                  : {},\n              },\n              dataWithOptimisticResults: this.cache.extract(true),\n            });\n          }\n        },\n      });\n    }\n    return this.queryManager;\n  }\n\n  /**\n   * Resets your entire store by clearing out your cache and then re-executing\n   * all of your active queries. This makes it so that you may guarantee that\n   * there is no data left in your store from a time before you called this\n   * method.\n   *\n   * `resetStore()` is useful when your user just logged out. Youâ€™ve removed the\n   * user session, and you now want to make sure that any references to data you\n   * might have fetched while the user session was active is gone.\n   *\n   * It is important to remember that `resetStore()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  public resetStore(): Promise<ApolloQueryResult<any>[] | null> {\n    return Promise.resolve()\n      .then(() => {\n        return this.queryManager\n          ? this.queryManager.clearStore()\n          : Promise.resolve(null);\n      })\n      .then(() => Promise.all(this.resetStoreCallbacks.map(fn => fn())))\n      .then(() => {\n        return this.queryManager && this.queryManager.reFetchObservableQueries\n          ? this.queryManager.reFetchObservableQueries()\n          : Promise.resolve(null);\n      });\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed with the store is reset.\n   * onResetStore returns an unsubscribe function for removing your registered callbacks.\n   */\n\n  public onResetStore(cb: () => Promise<any>): () => void {\n    this.resetStoreCallbacks.push(cb);\n    return () => {\n      this.resetStoreCallbacks = this.resetStoreCallbacks.filter(c => c !== cb);\n    };\n  }\n\n  /**\n   * Refetches all of your active queries.\n   *\n   * `reFetchObservableQueries()` is useful if you want to bring the client back to proper state in case of a network outage\n   *\n   * It is important to remember that `reFetchObservableQueries()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   * Takes optional parameter `includeStandby` which will include queries in standby-mode when refetching.\n   */\n  public reFetchObservableQueries(\n    includeStandby?: boolean,\n  ): Promise<ApolloQueryResult<any>[]> | Promise<null> {\n    return this.queryManager\n      ? this.queryManager.reFetchObservableQueries(includeStandby)\n      : Promise.resolve(null);\n  }\n\n  /**\n   * Exposes the cache's complete state, in a serializable format for later restoration.\n   */\n  public extract(optimistic?: boolean): TCacheShape {\n    return this.initProxy().extract(optimistic);\n  }\n\n  /**\n   * Replaces existing state in the cache (if any) with the values expressed by\n   * `serializedState`.\n   *\n   * Called when hydrating a cache (server side rendering, or offline storage),\n   * and also (potentially) during hot reloads.\n   */\n  public restore(serializedState: TCacheShape): ApolloCache<TCacheShape> {\n    return this.initProxy().restore(serializedState);\n  }\n\n  /**\n   * Initializes a data proxy for this client instance if one does not already\n   * exist and returns either a previously initialized proxy instance or the\n   * newly initialized instance.\n   */\n  private initProxy(): ApolloCache<TCacheShape> {\n    if (!this.proxy) {\n      this.initQueryManager();\n      this.proxy = this.cache;\n    }\n    return this.proxy;\n  }\n}\n","import zenObservable from 'zen-observable';\n\nnamespace Observable {\n\n}\n\nimport { ZenObservable } from './types';\n\nexport { ZenObservable };\n\nexport type Observer<T> = ZenObservable.Observer<T>;\nexport type Subscriber<T> = ZenObservable.Subscriber<T>;\nexport type ObservableLike<T> = ZenObservable.ObservableLike<T>;\n\nexport const Observable: {\n  new <T>(subscriber: Subscriber<T>): Observable<T>;\n  from<R>(\n    observable: Observable<R> | ZenObservable.ObservableLike<R> | ArrayLike<R>,\n  ): Observable<R>;\n  of<R>(...args: Array<R>): Observable<R>;\n} = <any>zenObservable;\n\nexport interface Observable<T> {\n  subscribe(\n    observerOrNext: ((value: T) => void) | ZenObservable.Observer<T>,\n    error?: (error: any) => void,\n    complete?: () => void,\n  ): ZenObservable.Subscription;\n\n  forEach(fn: (value: T) => void): Promise<void>;\n\n  map<R>(fn: (value: T) => R): Observable<R>;\n\n  filter(fn: (value: T) => boolean): Observable<T>;\n\n  reduce<R = T>(\n    fn: (previousValue: R | T, currentValue: T) => R | T,\n    initialValue?: R | T,\n  ): Observable<R | T>;\n\n  flatMap<R>(fn: (value: T) => ZenObservable.ObservableLike<R>): Observable<R>;\n\n  from<R>(\n    observable: Observable<R> | ZenObservable.ObservableLike<R> | ArrayLike<R>,\n  ): Observable<R>;\n  of<R>(...args: Array<R>): Observable<R>;\n}\n","import { getOperationName } from 'apollo-utilities';\nimport Observable from 'zen-observable-ts';\nimport { print } from 'graphql/language/printer';\n\nimport { GraphQLRequest, Operation } from './types';\nimport { ApolloLink } from './link';\n\nexport function validateOperation(operation: GraphQLRequest): GraphQLRequest {\n  const OPERATION_FIELDS = [\n    'query',\n    'operationName',\n    'variables',\n    'extensions',\n    'context',\n  ];\n  for (let key of Object.keys(operation)) {\n    if (OPERATION_FIELDS.indexOf(key) < 0) {\n      throw new Error(`illegal argument: ${key}`);\n    }\n  }\n\n  return operation;\n}\n\nexport class LinkError extends Error {\n  public link: ApolloLink;\n  constructor(message?: string, link?: ApolloLink) {\n    super(message);\n    this.link = link;\n  }\n}\n\nexport function isTerminating(link: ApolloLink): boolean {\n  return link.request.length <= 1;\n}\n\nexport function toPromise<R>(observable: Observable<R>): Promise<R> {\n  let completed = false;\n  return new Promise<R>((resolve, reject) => {\n    observable.subscribe({\n      next: data => {\n        if (completed) {\n          console.warn(\n            `Promise Wrapper does not support multiple results from Observable`,\n          );\n        } else {\n          completed = true;\n          resolve(data);\n        }\n      },\n      error: reject,\n    });\n  });\n}\n\n// backwards compat\nexport const makePromise = toPromise;\n\nexport function fromPromise<T>(promise: Promise<T>): Observable<T> {\n  return new Observable<T>(observer => {\n    promise\n      .then((value: T) => {\n        observer.next(value);\n        observer.complete();\n      })\n      .catch(observer.error.bind(observer));\n  });\n}\n\nexport function fromError<T>(errorValue: any): Observable<T> {\n  return new Observable<T>(observer => {\n    observer.error(errorValue);\n  });\n}\n\nexport function transformOperation(operation: GraphQLRequest): GraphQLRequest {\n  const transformedOperation: GraphQLRequest = {\n    variables: operation.variables || {},\n    extensions: operation.extensions || {},\n    operationName: operation.operationName,\n    query: operation.query,\n  };\n\n  // best guess at an operation name\n  if (!transformedOperation.operationName) {\n    transformedOperation.operationName =\n      typeof transformedOperation.query !== 'string'\n        ? getOperationName(transformedOperation.query)\n        : '';\n  }\n\n  return transformedOperation as Operation;\n}\n\nexport function createOperation(\n  starting: any,\n  operation: GraphQLRequest,\n): Operation {\n  let context = { ...starting };\n  const setContext = next => {\n    if (typeof next === 'function') {\n      context = { ...context, ...next(context) };\n    } else {\n      context = { ...context, ...next };\n    }\n  };\n  const getContext = () => ({ ...context });\n\n  Object.defineProperty(operation, 'setContext', {\n    enumerable: false,\n    value: setContext,\n  });\n\n  Object.defineProperty(operation, 'getContext', {\n    enumerable: false,\n    value: getContext,\n  });\n\n  Object.defineProperty(operation, 'toKey', {\n    enumerable: false,\n    value: () => getKey(operation),\n  });\n\n  return operation as Operation;\n}\n\nexport function getKey(operation: GraphQLRequest) {\n  // XXX we're assuming here that variables will be serialized in the same order.\n  // that might not always be true\n  return `${print(operation.query)}|${JSON.stringify(operation.variables)}|${\n    operation.operationName\n  }`;\n}\n","import Observable from 'zen-observable-ts';\n\nimport {\n  GraphQLRequest,\n  NextLink,\n  Operation,\n  RequestHandler,\n  FetchResult,\n} from './types';\n\nimport {\n  validateOperation,\n  isTerminating,\n  LinkError,\n  transformOperation,\n  createOperation,\n} from './linkUtils';\n\nconst passthrough = (op, forward) => (forward ? forward(op) : Observable.of());\n\nconst toLink = (handler: RequestHandler | ApolloLink) =>\n  typeof handler === 'function' ? new ApolloLink(handler) : handler;\n\nexport const empty = (): ApolloLink =>\n  new ApolloLink((op, forward) => Observable.of());\n\nexport const from = (links: ApolloLink[]): ApolloLink => {\n  if (links.length === 0) return empty();\n\n  return links.map(toLink).reduce((x, y) => x.concat(y));\n};\n\nexport const split = (\n  test: (op: Operation) => boolean,\n  left: ApolloLink | RequestHandler,\n  right: ApolloLink | RequestHandler = new ApolloLink(passthrough),\n): ApolloLink => {\n  const leftLink = toLink(left);\n  const rightLink = toLink(right);\n\n  if (isTerminating(leftLink) && isTerminating(rightLink)) {\n    return new ApolloLink(operation => {\n      return test(operation)\n        ? leftLink.request(operation) || Observable.of()\n        : rightLink.request(operation) || Observable.of();\n    });\n  } else {\n    return new ApolloLink((operation, forward) => {\n      return test(operation)\n        ? leftLink.request(operation, forward) || Observable.of()\n        : rightLink.request(operation, forward) || Observable.of();\n    });\n  }\n};\n\n// join two Links together\nexport const concat = (\n  first: ApolloLink | RequestHandler,\n  second: ApolloLink | RequestHandler,\n) => {\n  const firstLink = toLink(first);\n  if (isTerminating(firstLink)) {\n    console.warn(\n      new LinkError(\n        `You are calling concat on a terminating link, which will have no effect`,\n        firstLink,\n      ),\n    );\n    return firstLink;\n  }\n  const nextLink = toLink(second);\n\n  if (isTerminating(nextLink)) {\n    return new ApolloLink(\n      operation =>\n        firstLink.request(\n          operation,\n          op => nextLink.request(op) || Observable.of(),\n        ) || Observable.of(),\n    );\n  } else {\n    return new ApolloLink((operation, forward) => {\n      return (\n        firstLink.request(operation, op => {\n          return nextLink.request(op, forward) || Observable.of();\n        }) || Observable.of()\n      );\n    });\n  }\n};\n\nexport class ApolloLink {\n  constructor(request?: RequestHandler) {\n    if (request) this.request = request;\n  }\n\n  public static empty = empty;\n  public static from = from;\n  public static split = split;\n  public static execute = execute;\n\n  public split(\n    test: (op: Operation) => boolean,\n    left: ApolloLink | RequestHandler,\n    right: ApolloLink | RequestHandler = new ApolloLink(passthrough),\n  ): ApolloLink {\n    return this.concat(split(test, left, right));\n  }\n\n  public concat(next: ApolloLink | RequestHandler): ApolloLink {\n    return concat(this, next);\n  }\n\n  public request(\n    operation: Operation,\n    forward?: NextLink,\n  ): Observable<FetchResult> | null {\n    throw new Error('request is not implemented');\n  }\n}\n\nexport function execute(\n  link: ApolloLink,\n  operation: GraphQLRequest,\n): Observable<FetchResult> {\n  return (\n    link.request(\n      createOperation(\n        operation.context,\n        transformOperation(validateOperation(operation)),\n      ),\n    ) || Observable.of()\n  );\n}\n","import {\n  DocumentNode,\n  OperationDefinitionNode,\n  SelectionSetNode,\n  FieldNode,\n  FragmentDefinitionNode,\n} from 'graphql';\n\nexport function queryFromPojo(obj: any): DocumentNode {\n  const op: OperationDefinitionNode = {\n    kind: 'OperationDefinition',\n    operation: 'query',\n    name: {\n      kind: 'Name',\n      value: 'GeneratedClientQuery',\n    },\n    selectionSet: selectionSetFromObj(obj),\n  };\n\n  const out: DocumentNode = {\n    kind: 'Document',\n    definitions: [op],\n  };\n\n  return out;\n}\n\nexport function fragmentFromPojo(obj: any, typename?: string): DocumentNode {\n  const frag: FragmentDefinitionNode = {\n    kind: 'FragmentDefinition',\n    typeCondition: {\n      kind: 'NamedType',\n      name: {\n        kind: 'Name',\n        value: typename || '__FakeType',\n      },\n    },\n    name: {\n      kind: 'Name',\n      value: 'GeneratedClientQuery',\n    },\n    selectionSet: selectionSetFromObj(obj),\n  };\n\n  const out: DocumentNode = {\n    kind: 'Document',\n    definitions: [frag],\n  };\n\n  return out;\n}\n\nfunction selectionSetFromObj(obj: any): SelectionSetNode {\n  if (\n    typeof obj === 'number' ||\n    typeof obj === 'boolean' ||\n    typeof obj === 'string' ||\n    typeof obj === 'undefined' ||\n    obj === null\n  ) {\n    // No selection set here\n    return null;\n  }\n\n  if (Array.isArray(obj)) {\n    // GraphQL queries don't include arrays\n    return selectionSetFromObj(obj[0]);\n  }\n\n  // Now we know it's an object\n  const selections: FieldNode[] = [];\n\n  Object.keys(obj).forEach(key => {\n    const field: FieldNode = {\n      kind: 'Field',\n      name: {\n        kind: 'Name',\n        value: key,\n      },\n    };\n\n    // Recurse\n    const nestedSelSet: SelectionSetNode = selectionSetFromObj(obj[key]);\n\n    if (nestedSelSet) {\n      field.selectionSet = nestedSelSet;\n    }\n\n    selections.push(field);\n  });\n\n  const selectionSet: SelectionSetNode = {\n    kind: 'SelectionSet',\n    selections,\n  };\n\n  return selectionSet;\n}\n\nexport const justTypenameQuery: DocumentNode = {\n  kind: 'Document',\n  definitions: [\n    {\n      kind: 'OperationDefinition',\n      operation: 'query',\n      name: null,\n      variableDefinitions: null,\n      directives: [],\n      selectionSet: {\n        kind: 'SelectionSet',\n        selections: [\n          {\n            kind: 'Field',\n            alias: null,\n            name: {\n              kind: 'Name',\n              value: '__typename',\n            },\n            arguments: [],\n            directives: [],\n            selectionSet: null,\n          },\n        ],\n      },\n    },\n  ],\n};\n","import { DocumentNode } from 'graphql';\nimport { getFragmentQueryDocument } from 'apollo-utilities';\n\nimport { DataProxy, Cache } from './types';\nimport { justTypenameQuery, queryFromPojo, fragmentFromPojo } from './utils';\n\nexport type Transaction<T> = (c: ApolloCache<T>) => void;\n\nexport abstract class ApolloCache<TSerialized> implements DataProxy {\n  // required to implement\n  // core API\n  public abstract read<T, TVariables = any>(\n    query: Cache.ReadOptions<TVariables>,\n  ): T | null;\n  public abstract write<TResult = any, TVariables = any>(\n    write: Cache.WriteOptions<TResult, TVariables>,\n  ): void;\n  public abstract diff<T>(query: Cache.DiffOptions): Cache.DiffResult<T>;\n  public abstract watch(watch: Cache.WatchOptions): () => void;\n  public abstract evict<TVariables = any>(\n    query: Cache.EvictOptions<TVariables>,\n  ): Cache.EvictionResult;\n  public abstract reset(): Promise<void>;\n\n  // intializer / offline / ssr API\n  /**\n   * Replaces existing state in the cache (if any) with the values expressed by\n   * `serializedState`.\n   *\n   * Called when hydrating a cache (server side rendering, or offline storage),\n   * and also (potentially) during hot reloads.\n   */\n  public abstract restore(\n    serializedState: TSerialized,\n  ): ApolloCache<TSerialized>;\n\n  /**\n   * Exposes the cache's complete state, in a serializable format for later restoration.\n   */\n  public abstract extract(optimistic?: boolean): TSerialized;\n\n  // optimistic API\n  public abstract removeOptimistic(id: string): void;\n\n  // transactional API\n  public abstract performTransaction(\n    transaction: Transaction<TSerialized>,\n  ): void;\n  public abstract recordOptimisticTransaction(\n    transaction: Transaction<TSerialized>,\n    id: string,\n  ): void;\n\n  // optional API\n  public transformDocument(document: DocumentNode): DocumentNode {\n    return document;\n  }\n  // experimental\n  public transformForLink(document: DocumentNode): DocumentNode {\n    return document;\n  }\n\n  // DataProxy API\n  /**\n   *\n   * @param options\n   * @param optimistic\n   */\n  public readQuery<QueryType, TVariables = any>(\n    options: DataProxy.Query<TVariables>,\n    optimistic: boolean = false,\n  ): QueryType | null {\n    return this.read({\n      query: options.query,\n      variables: options.variables,\n      optimistic,\n    });\n  }\n\n  public readFragment<FragmentType, TVariables = any>(\n    options: DataProxy.Fragment<TVariables>,\n    optimistic: boolean = false,\n  ): FragmentType | null {\n    return this.read({\n      query: getFragmentQueryDocument(options.fragment, options.fragmentName),\n      variables: options.variables,\n      rootId: options.id,\n      optimistic,\n    });\n  }\n\n  public writeQuery<TData = any, TVariables = any>(\n    options: Cache.WriteQueryOptions<TData, TVariables>,\n  ): void {\n    this.write({\n      dataId: 'ROOT_QUERY',\n      result: options.data,\n      query: options.query,\n      variables: options.variables,\n    });\n  }\n\n  public writeFragment<TData = any, TVariables = any>(\n    options: Cache.WriteFragmentOptions<TData, TVariables>,\n  ): void {\n    this.write({\n      dataId: options.id,\n      result: options.data,\n      variables: options.variables,\n      query: getFragmentQueryDocument(options.fragment, options.fragmentName),\n    });\n  }\n\n  public writeData<TData = any>({\n    id,\n    data,\n  }: Cache.WriteDataOptions<TData>): void {\n    if (typeof id !== 'undefined') {\n      let typenameResult = null;\n      // Since we can't use fragments without having a typename in the store,\n      // we need to make sure we have one.\n      // To avoid overwriting an existing typename, we need to read it out first\n      // and generate a fake one if none exists.\n      try {\n        typenameResult = this.read({\n          rootId: id,\n          optimistic: false,\n          query: justTypenameQuery,\n        });\n      } catch (e) {\n        // Do nothing, since an error just means no typename exists\n      }\n\n      // tslint:disable-next-line\n      const __typename =\n        (typenameResult && typenameResult.__typename) || '__ClientData';\n\n      // Add a type here to satisfy the inmemory cache\n      const dataToWrite = Object.assign({ __typename }, data);\n\n      this.writeFragment({\n        id,\n        fragment: fragmentFromPojo(dataToWrite, __typename),\n        data: dataToWrite,\n      });\n    } else {\n      this.writeQuery({ query: queryFromPojo(data), data });\n    }\n  }\n}\n","import { isTest, warnOnceInDevelopment, IdValue } from 'apollo-utilities';\n\nimport {\n  ReadStoreContext,\n  FragmentMatcherInterface,\n  PossibleTypesMap,\n  IntrospectionResultData,\n} from './types';\n\nlet haveWarned = false;\n\n/**\n * This fragment matcher is very basic and unable to match union or interface type conditions\n */\nexport class HeuristicFragmentMatcher implements FragmentMatcherInterface {\n  constructor() {\n    // do nothing\n  }\n\n  public ensureReady() {\n    return Promise.resolve();\n  }\n\n  public canBypassInit() {\n    return true; // we don't need to initialize this fragment matcher.\n  }\n\n  public match(\n    idValue: IdValue,\n    typeCondition: string,\n    context: ReadStoreContext,\n  ): boolean {\n    const obj = context.store.get(idValue.id);\n\n    if (!obj && idValue.id === 'ROOT_QUERY') {\n      return true;\n    }\n\n    if (!obj) {\n      return false;\n    }\n\n    if (!obj.__typename) {\n      if (!haveWarned) {\n        console.warn(`You're using fragments in your queries, but either don't have the addTypename:\n  true option set in Apollo Client, or you are trying to write a fragment to the store without the __typename.\n   Please turn on the addTypename option and include __typename when writing fragments so that Apollo Client\n   can accurately match fragments.`);\n        console.warn(\n          'Could not find __typename on Fragment ',\n          typeCondition,\n          obj,\n        );\n        console.warn(\n          `DEPRECATION WARNING: using fragments without __typename is unsupported behavior ` +\n            `and will be removed in future versions of Apollo client. You should fix this and set addTypename to true now.`,\n        );\n\n        /* istanbul ignore if */\n        if (!isTest()) {\n          // When running tests, we want to print the warning every time\n          haveWarned = true;\n        }\n      }\n\n      context.returnPartialData = true;\n      return true;\n    }\n\n    if (obj.__typename === typeCondition) {\n      return true;\n    }\n\n    // XXX here we reach an issue - we don't know if this fragment should match or not. It's either:\n    // 1. A fragment on a non-matching concrete type or interface or union\n    // 2. A fragment on a matching interface or union\n    // If it's 1, we don't want to return anything, if it's 2 we want to match. We can't tell the\n    // difference, so we warn the user, but still try to match it (backcompat).\n    warnOnceInDevelopment(\n      'You are using the simple (heuristic) fragment matcher, but your ' +\n        'queries contain union or interface types. Apollo Client will not be ' +\n        'able to accurately map fragments. To make this error go away, use ' +\n        'the `IntrospectionFragmentMatcher` as described in the docs: ' +\n        'https://www.apollographql.com/docs/react/recipes/fragment-matching.html',\n      'error',\n    );\n\n    context.returnPartialData = true;\n    return true;\n  }\n}\n\nexport class IntrospectionFragmentMatcher implements FragmentMatcherInterface {\n  private isReady: boolean;\n  private possibleTypesMap: PossibleTypesMap;\n\n  constructor(options?: {\n    introspectionQueryResultData?: IntrospectionResultData;\n  }) {\n    if (options && options.introspectionQueryResultData) {\n      this.possibleTypesMap = this.parseIntrospectionResult(\n        options.introspectionQueryResultData,\n      );\n      this.isReady = true;\n    } else {\n      this.isReady = false;\n    }\n\n    this.match = this.match.bind(this);\n  }\n\n  public match(\n    idValue: IdValue,\n    typeCondition: string,\n    context: ReadStoreContext,\n  ) {\n    if (!this.isReady) {\n      // this should basically never happen in proper use.\n      throw new Error(\n        'FragmentMatcher.match() was called before FragmentMatcher.init()',\n      );\n    }\n\n    const obj = context.store.get(idValue.id);\n\n    if (!obj) {\n      return false;\n    }\n\n    if (!obj.__typename) {\n      throw new Error(\n        `Cannot match fragment because __typename property is missing: ${JSON.stringify(\n          obj,\n        )}`,\n      );\n    }\n\n    if (obj.__typename === typeCondition) {\n      return true;\n    }\n\n    const implementingTypes = this.possibleTypesMap[typeCondition];\n    if (implementingTypes && implementingTypes.indexOf(obj.__typename) > -1) {\n      return true;\n    }\n\n    return false;\n  }\n\n  private parseIntrospectionResult(\n    introspectionResultData: IntrospectionResultData,\n  ): PossibleTypesMap {\n    const typeMap: PossibleTypesMap = {};\n    introspectionResultData.__schema.types.forEach(type => {\n      if (type.kind === 'UNION' || type.kind === 'INTERFACE') {\n        typeMap[type.name] = type.possibleTypes.map(\n          implementingType => implementingType.name,\n        );\n      }\n    });\n    return typeMap;\n  }\n}\n","import { NormalizedCache, NormalizedCacheObject, StoreObject } from './types';\n\nexport class ObjectCache implements NormalizedCache {\n  constructor(private data: NormalizedCacheObject = Object.create(null)) {}\n  public toObject(): NormalizedCacheObject {\n    return this.data;\n  }\n  public get(dataId: string): StoreObject {\n    return this.data[dataId];\n  }\n  public set(dataId: string, value: StoreObject) {\n    this.data[dataId] = value;\n  }\n  public delete(dataId: string): void {\n    this.data[dataId] = undefined;\n  }\n  public clear(): void {\n    this.data = Object.create(null);\n  }\n  public replace(newData: NormalizedCacheObject): void {\n    this.data = newData || Object.create(null);\n  }\n}\n\nexport function defaultNormalizedCacheFactory(\n  seed?: NormalizedCacheObject,\n): NormalizedCache {\n  return new ObjectCache(seed);\n}\n","import {\n  SelectionSetNode,\n  FieldNode,\n  DocumentNode,\n  InlineFragmentNode,\n  OperationDefinitionNode,\n  FragmentDefinitionNode,\n} from 'graphql';\nimport { print } from 'graphql/language/printer';\nimport { FragmentMatcher } from 'graphql-anywhere';\n\nimport {\n  assign,\n  createFragmentMap,\n  FragmentMap,\n  getDefaultValues,\n  getFragmentDefinitions,\n  getOperationDefinition,\n  IdValue,\n  isField,\n  isIdValue,\n  isInlineFragment,\n  isProduction,\n  resultKeyNameFromField,\n  shouldInclude,\n  storeKeyNameFromField,\n  getQueryDefinition,\n  StoreValue,\n  toIdValue,\n} from 'apollo-utilities';\n\nimport { defaultNormalizedCacheFactory, ObjectCache } from './objectCache';\n\nimport {\n  IdGetter,\n  NormalizedCache,\n  NormalizedCacheFactory,\n  ReadStoreContext,\n  StoreObject,\n} from './types';\n\nexport class WriteError extends Error {\n  public type = 'WriteError';\n}\n\nexport function enhanceErrorWithDocument(error: Error, document: DocumentNode) {\n  // XXX A bit hacky maybe ...\n  const enhancedError = new WriteError(\n    `Error writing result to store for query:\\n ${print(document)}`,\n  );\n  enhancedError.message += '\\n' + error.message;\n  enhancedError.stack = error.stack;\n  return enhancedError;\n}\n\n/**\n * Writes the result of a query to the store.\n *\n * @param result The result object returned for the query document.\n *\n * @param query The query document whose result we are writing to the store.\n *\n * @param store The {@link NormalizedCache} used by Apollo for the `data` portion of the store.\n *\n * @param variables A map from the name of a variable to its value. These variables can be\n * referenced by the query document.\n *\n * @param dataIdFromObject A function that returns an object identifier given a particular result\n * object. See the store documentation for details and an example of this function.\n *\n * @param fragmentMap A map from the name of a fragment to its fragment definition. These fragments\n * can be referenced within the query document.\n *\n * @param fragmentMatcherFunction A function to use for matching fragment conditions in GraphQL documents\n */\nexport function writeQueryToStore({\n  result,\n  query,\n  storeFactory = defaultNormalizedCacheFactory,\n  store = storeFactory(),\n  variables,\n  dataIdFromObject,\n  fragmentMap = {} as FragmentMap,\n  fragmentMatcherFunction,\n}: {\n  result: Object;\n  query: DocumentNode;\n  store?: NormalizedCache;\n  storeFactory?: NormalizedCacheFactory;\n  variables?: Object;\n  dataIdFromObject?: IdGetter;\n  fragmentMap?: FragmentMap;\n  fragmentMatcherFunction?: FragmentMatcher;\n}): NormalizedCache {\n  const queryDefinition: OperationDefinitionNode = getQueryDefinition(query);\n\n  variables = assign({}, getDefaultValues(queryDefinition), variables);\n\n  try {\n    return writeSelectionSetToStore({\n      dataId: 'ROOT_QUERY',\n      result,\n      selectionSet: queryDefinition.selectionSet,\n      context: {\n        store,\n        storeFactory,\n        processedData: {},\n        variables,\n        dataIdFromObject,\n        fragmentMap,\n        fragmentMatcherFunction,\n      },\n    });\n  } catch (e) {\n    throw enhanceErrorWithDocument(e, query);\n  }\n}\n\nexport type WriteContext = {\n  store: NormalizedCache;\n  storeFactory: NormalizedCacheFactory;\n  processedData?: { [x: string]: FieldNode[] };\n  variables?: any;\n  dataIdFromObject?: IdGetter;\n  fragmentMap?: FragmentMap;\n  fragmentMatcherFunction?: FragmentMatcher;\n};\n\nexport function writeResultToStore({\n  dataId,\n  result,\n  document,\n  storeFactory = defaultNormalizedCacheFactory,\n  store = storeFactory(),\n  variables,\n  dataIdFromObject,\n  fragmentMatcherFunction,\n}: {\n  dataId: string;\n  result: any;\n  document: DocumentNode;\n  store?: NormalizedCache;\n  storeFactory?: NormalizedCacheFactory;\n  variables?: Object;\n  dataIdFromObject?: IdGetter;\n  fragmentMatcherFunction?: FragmentMatcher;\n}): NormalizedCache {\n  // XXX TODO REFACTOR: this is a temporary workaround until query normalization is made to work with documents.\n  const operationDefinition = getOperationDefinition(document);\n  const selectionSet = operationDefinition.selectionSet;\n  const fragmentMap = createFragmentMap(getFragmentDefinitions(document));\n\n  variables = assign({}, getDefaultValues(operationDefinition), variables);\n\n  try {\n    return writeSelectionSetToStore({\n      result,\n      dataId,\n      selectionSet,\n      context: {\n        store,\n        storeFactory,\n        processedData: {},\n        variables,\n        dataIdFromObject,\n        fragmentMap,\n        fragmentMatcherFunction,\n      },\n    });\n  } catch (e) {\n    throw enhanceErrorWithDocument(e, document);\n  }\n}\n\nexport function writeSelectionSetToStore({\n  result,\n  dataId,\n  selectionSet,\n  context,\n}: {\n  dataId: string;\n  result: any;\n  selectionSet: SelectionSetNode;\n  context: WriteContext;\n}): NormalizedCache {\n  const { variables, store, fragmentMap } = context;\n\n  selectionSet.selections.forEach(selection => {\n    const included = shouldInclude(selection, variables);\n\n    if (isField(selection)) {\n      const resultFieldKey: string = resultKeyNameFromField(selection);\n      const value: any = result[resultFieldKey];\n\n      if (included) {\n        if (typeof value !== 'undefined') {\n          writeFieldToStore({\n            dataId,\n            value,\n            field: selection,\n            context,\n          });\n        } else {\n          // if this is a defered field we don't need to throw / warn\n          const isDefered =\n            selection.directives &&\n            selection.directives.length &&\n            selection.directives.some(\n              directive => directive.name && directive.name.value === 'defer',\n            );\n\n          if (!isDefered && context.fragmentMatcherFunction) {\n            // XXX We'd like to throw an error, but for backwards compatibility's sake\n            // we just print a warning for the time being.\n            //throw new WriteError(`Missing field ${resultFieldKey} in ${JSON.stringify(result, null, 2).substring(0, 100)}`);\n            if (!isProduction()) {\n              console.warn(\n                `Missing field ${resultFieldKey} in ${JSON.stringify(\n                  result,\n                  null,\n                  2,\n                ).substring(0, 100)}`,\n              );\n            }\n          }\n        }\n      }\n    } else {\n      // This is not a field, so it must be a fragment, either inline or named\n      let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n      if (isInlineFragment(selection)) {\n        fragment = selection;\n      } else {\n        // Named fragment\n        fragment = (fragmentMap || {})[selection.name.value];\n\n        if (!fragment) {\n          throw new Error(`No fragment named ${selection.name.value}.`);\n        }\n      }\n\n      let matches = true;\n      if (context.fragmentMatcherFunction && fragment.typeCondition) {\n        // TODO we need to rewrite the fragment matchers for this to work properly and efficiently\n        // Right now we have to pretend that we're passing in an idValue and that there's a store\n        // on the context.\n        const idValue = toIdValue({ id: 'self', typename: undefined });\n        const fakeContext: ReadStoreContext = {\n          // NOTE: fakeContext always uses ObjectCache\n          // since this is only to ensure the return value of 'matches'\n          store: new ObjectCache({ self: result }),\n          returnPartialData: false,\n          hasMissingField: false,\n          cacheRedirects: {},\n        };\n        matches = context.fragmentMatcherFunction(\n          idValue,\n          fragment.typeCondition.name.value,\n          fakeContext,\n        );\n        if (!isProduction() && fakeContext.returnPartialData) {\n          console.error('WARNING: heuristic fragment matching going on!');\n        }\n      }\n\n      if (included && matches) {\n        writeSelectionSetToStore({\n          result,\n          selectionSet: fragment.selectionSet,\n          dataId,\n          context,\n        });\n      }\n    }\n  });\n\n  return store;\n}\n\n// Checks if the id given is an id that was generated by Apollo\n// rather than by dataIdFromObject.\nfunction isGeneratedId(id: string): boolean {\n  return id[0] === '$';\n}\n\nfunction mergeWithGenerated(\n  generatedKey: string,\n  realKey: string,\n  cache: NormalizedCache,\n) {\n  const generated = cache.get(generatedKey);\n  const real = cache.get(realKey);\n\n  Object.keys(generated).forEach(key => {\n    const value = generated[key];\n    const realValue = real[key];\n    if (isIdValue(value) && isGeneratedId(value.id) && isIdValue(realValue)) {\n      mergeWithGenerated(value.id, realValue.id, cache);\n    }\n    cache.delete(generatedKey);\n    cache.set(realKey, { ...generated, ...real } as StoreObject);\n  });\n}\n\nfunction isDataProcessed(\n  dataId: string,\n  field: FieldNode | SelectionSetNode,\n  processedData?: { [x: string]: (FieldNode | SelectionSetNode)[] },\n): boolean {\n  if (!processedData) {\n    return false;\n  }\n\n  if (processedData[dataId]) {\n    if (processedData[dataId].indexOf(field) >= 0) {\n      return true;\n    } else {\n      processedData[dataId].push(field);\n    }\n  } else {\n    processedData[dataId] = [field];\n  }\n\n  return false;\n}\n\nfunction writeFieldToStore({\n  field,\n  value,\n  dataId,\n  context,\n}: {\n  field: FieldNode;\n  value: any;\n  dataId: string;\n  context: WriteContext;\n}) {\n  const { variables, dataIdFromObject, store } = context;\n\n  let storeValue: StoreValue;\n  let storeObject: StoreObject;\n\n  const storeFieldName: string = storeKeyNameFromField(field, variables);\n  // specifies if we need to merge existing keys in the store\n  let shouldMerge = false;\n  // If we merge, this will be the generatedKey\n  let generatedKey: string = '';\n\n  // If this is a scalar value...\n  if (!field.selectionSet || value === null) {\n    storeValue =\n      value != null && typeof value === 'object'\n        ? // If the scalar value is a JSON blob, we have to \"escape\" it so it canâ€™t pretend to be\n          // an id.\n          { type: 'json', json: value }\n        : // Otherwise, just store the scalar directly in the store.\n          value;\n  } else if (Array.isArray(value)) {\n    const generatedId = `${dataId}.${storeFieldName}`;\n\n    storeValue = processArrayValue(\n      value,\n      generatedId,\n      field.selectionSet,\n      context,\n    );\n  } else {\n    // It's an object\n    let valueDataId = `${dataId}.${storeFieldName}`;\n    let generated = true;\n\n    // We only prepend the '$' if the valueDataId isn't already a generated\n    // id.\n    if (!isGeneratedId(valueDataId)) {\n      valueDataId = '$' + valueDataId;\n    }\n\n    if (dataIdFromObject) {\n      const semanticId = dataIdFromObject(value);\n\n      // We throw an error if the first character of the id is '$. This is\n      // because we use that character to designate an Apollo-generated id\n      // and we use the distinction between user-desiginated and application-provided\n      // ids when managing overwrites.\n      if (semanticId && isGeneratedId(semanticId)) {\n        throw new Error(\n          'IDs returned by dataIdFromObject cannot begin with the \"$\" character.',\n        );\n      }\n\n      if (semanticId || (typeof semanticId === 'number' && semanticId === 0)) {\n        valueDataId = semanticId;\n        generated = false;\n      }\n    }\n\n    if (!isDataProcessed(valueDataId, field, context.processedData)) {\n      writeSelectionSetToStore({\n        dataId: valueDataId,\n        result: value,\n        selectionSet: field.selectionSet,\n        context,\n      });\n    }\n\n    // We take the id and escape it (i.e. wrap it with an enclosing object).\n    // This allows us to distinguish IDs from normal scalars.\n    const typename = value.__typename;\n    storeValue = toIdValue({ id: valueDataId, typename }, generated);\n\n    // check if there was a generated id at the location where we're\n    // about to place this new id. If there was, we have to merge the\n    // data from that id with the data we're about to write in the store.\n    storeObject = store.get(dataId);\n    const escapedId =\n      storeObject && (storeObject[storeFieldName] as IdValue | undefined);\n    if (escapedId !== storeValue && isIdValue(escapedId)) {\n      const hadTypename = escapedId.typename !== undefined;\n      const hasTypename = typename !== undefined;\n      const typenameChanged =\n        hadTypename && hasTypename && escapedId.typename !== typename;\n\n      // If there is already a real id in the store and the current id we\n      // are dealing with is generated, we throw an error.\n      // One exception we allow is when the typename has changed, which occurs\n      // when schema defines a union, both with and without an ID in the same place.\n      // checks if we \"lost\" the read id\n      if (generated && !escapedId.generated && !typenameChanged) {\n        throw new Error(\n          `Store error: the application attempted to write an object with no provided id` +\n            ` but the store already contains an id of ${\n              escapedId.id\n            } for this object. The selectionSet` +\n            ` that was trying to be written is:\\n` +\n            print(field),\n        );\n      }\n      // checks if we \"lost\" the typename\n      if (hadTypename && !hasTypename) {\n        throw new Error(\n          `Store error: the application attempted to write an object with no provided typename` +\n            ` but the store already contains an object with typename of ${\n              escapedId.typename\n            } for the object of id ${escapedId.id}. The selectionSet` +\n            ` that was trying to be written is:\\n` +\n            print(field),\n        );\n      }\n\n      if (escapedId.generated) {\n        generatedKey = escapedId.id;\n        // We should only merge if it's an object of the same type,\n        // otherwise we should delete the generated object\n        if (typenameChanged) {\n          // Only delete the generated object when the old object was\n          // inlined, and the new object is not. This is indicated by\n          // the old id being generated, and the new id being real.\n          if (!generated) {\n            store.delete(generatedKey);\n          }\n        } else {\n          shouldMerge = true;\n        }\n      }\n    }\n  }\n\n  const newStoreObj = {\n    ...store.get(dataId),\n    [storeFieldName]: storeValue,\n  } as StoreObject;\n\n  if (shouldMerge) {\n    mergeWithGenerated(generatedKey, (storeValue as IdValue).id, store);\n  }\n\n  storeObject = store.get(dataId);\n  if (!storeObject || storeValue !== storeObject[storeFieldName]) {\n    store.set(dataId, newStoreObj);\n  }\n}\n\nfunction processArrayValue(\n  value: any[],\n  generatedId: string,\n  selectionSet: SelectionSetNode,\n  context: WriteContext,\n): any[] {\n  return value.map((item: any, index: any) => {\n    if (item === null) {\n      return null;\n    }\n\n    let itemDataId = `${generatedId}.${index}`;\n\n    if (Array.isArray(item)) {\n      return processArrayValue(item, itemDataId, selectionSet, context);\n    }\n\n    let generated = true;\n\n    if (context.dataIdFromObject) {\n      const semanticId = context.dataIdFromObject(item);\n\n      if (semanticId) {\n        itemDataId = semanticId;\n        generated = false;\n      }\n    }\n\n    if (!isDataProcessed(itemDataId, selectionSet, context.processedData)) {\n      writeSelectionSetToStore({\n        dataId: itemDataId,\n        result: item,\n        selectionSet,\n        context,\n      });\n    }\n\n    return toIdValue({ id: itemDataId, typename: item.__typename }, generated);\n  });\n}\n","import {\n  DocumentNode,\n  SelectionSetNode,\n  FieldNode,\n  FragmentDefinitionNode,\n  InlineFragmentNode,\n} from 'graphql';\n\nimport {\n  getMainDefinition,\n  getFragmentDefinitions,\n  createFragmentMap,\n  FragmentMap,\n  DirectiveInfo,\n  shouldInclude,\n  getDirectiveInfoFromField,\n  isField,\n  isInlineFragment,\n  resultKeyNameFromField,\n  argumentsObjectFromField,\n} from 'apollo-utilities';\n\nexport type Resolver = (\n  fieldName: string,\n  rootValue: any,\n  args: any,\n  context: any,\n  info: ExecInfo,\n) => any;\n\nexport type VariableMap = { [name: string]: any };\n\nexport type ResultMapper = (\n  values: { [fieldName: string]: any },\n  rootValue: any,\n) => any;\nexport type FragmentMatcher = (\n  rootValue: any,\n  typeCondition: string,\n  context: any,\n) => boolean;\n\nexport type ExecContext = {\n  fragmentMap: FragmentMap;\n  contextValue: any;\n  variableValues: VariableMap;\n  resultMapper: ResultMapper;\n  resolver: Resolver;\n  fragmentMatcher: FragmentMatcher;\n};\n\nexport type ExecInfo = {\n  isLeaf: boolean;\n  resultKey: string;\n  directives: DirectiveInfo;\n};\n\nexport type ExecOptions = {\n  resultMapper?: ResultMapper;\n  fragmentMatcher?: FragmentMatcher;\n};\n\n/* Based on graphql function from graphql-js:\n *\n * graphql(\n *   schema: GraphQLSchema,\n *   requestString: string,\n *   rootValue?: ?any,\n *   contextValue?: ?any,\n *   variableValues?: ?{[key: string]: any},\n *   operationName?: ?string\n * ): Promise<GraphQLResult>\n *\n * The default export as of graphql-anywhere is sync as of 4.0,\n * but below is an exported alternative that is async.\n * In the 5.0 version, this will be the only export again\n * and it will be async\n */\nexport function graphql(\n  resolver: Resolver,\n  document: DocumentNode,\n  rootValue?: any,\n  contextValue?: any,\n  variableValues?: VariableMap,\n  execOptions: ExecOptions = {},\n) {\n  const mainDefinition = getMainDefinition(document);\n\n  const fragments = getFragmentDefinitions(document);\n  const fragmentMap = createFragmentMap(fragments);\n\n  const resultMapper = execOptions.resultMapper;\n\n  // Default matcher always matches all fragments\n  const fragmentMatcher = execOptions.fragmentMatcher || (() => true);\n\n  const execContext: ExecContext = {\n    fragmentMap,\n    contextValue,\n    variableValues,\n    resultMapper,\n    resolver,\n    fragmentMatcher,\n  };\n\n  return executeSelectionSet(\n    mainDefinition.selectionSet,\n    rootValue,\n    execContext,\n  );\n}\n\nfunction executeSelectionSet(\n  selectionSet: SelectionSetNode,\n  rootValue: any,\n  execContext: ExecContext,\n) {\n  const { fragmentMap, contextValue, variableValues: variables } = execContext;\n\n  const result = {};\n\n  selectionSet.selections.forEach(selection => {\n    if (!shouldInclude(selection, variables)) {\n      // Skip this entirely\n      return;\n    }\n\n    if (isField(selection)) {\n      const fieldResult = executeField(selection, rootValue, execContext);\n\n      const resultFieldKey = resultKeyNameFromField(selection);\n\n      if (fieldResult !== undefined) {\n        if (result[resultFieldKey] === undefined) {\n          result[resultFieldKey] = fieldResult;\n        } else {\n          merge(result[resultFieldKey], fieldResult);\n        }\n      }\n    } else {\n      let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n      if (isInlineFragment(selection)) {\n        fragment = selection;\n      } else {\n        // This is a named fragment\n        fragment = fragmentMap[selection.name.value];\n\n        if (!fragment) {\n          throw new Error(`No fragment named ${selection.name.value}`);\n        }\n      }\n\n      const typeCondition = fragment.typeCondition.name.value;\n\n      if (execContext.fragmentMatcher(rootValue, typeCondition, contextValue)) {\n        const fragmentResult = executeSelectionSet(\n          fragment.selectionSet,\n          rootValue,\n          execContext,\n        );\n\n        merge(result, fragmentResult);\n      }\n    }\n  });\n\n  if (execContext.resultMapper) {\n    return execContext.resultMapper(result, rootValue);\n  }\n\n  return result;\n}\n\nfunction executeField(\n  field: FieldNode,\n  rootValue: any,\n  execContext: ExecContext,\n): any {\n  const { variableValues: variables, contextValue, resolver } = execContext;\n\n  const fieldName = field.name.value;\n  const args = argumentsObjectFromField(field, variables);\n\n  const info: ExecInfo = {\n    isLeaf: !field.selectionSet,\n    resultKey: resultKeyNameFromField(field),\n    directives: getDirectiveInfoFromField(field, variables),\n  };\n\n  const result = resolver(fieldName, rootValue, args, contextValue, info);\n\n  // Handle all scalar types here\n  if (!field.selectionSet) {\n    return result;\n  }\n\n  // From here down, the field has a selection set, which means it's trying to\n  // query a GraphQLObjectType\n  if (result == null) {\n    // Basically any field in a GraphQL response can be null, or missing\n    return result;\n  }\n\n  if (Array.isArray(result)) {\n    return executeSubSelectedArray(field, result, execContext);\n  }\n\n  // Returned value is an object, and the query has a sub-selection. Recurse.\n  return executeSelectionSet(field.selectionSet, result, execContext);\n}\n\nfunction executeSubSelectedArray(field, result, execContext) {\n  return result.map(item => {\n    // null value in array\n    if (item === null) {\n      return null;\n    }\n\n    // This is a nested array, recurse\n    if (Array.isArray(item)) {\n      return executeSubSelectedArray(field, item, execContext);\n    }\n\n    // This is an object, run the selection set on it\n    return executeSelectionSet(field.selectionSet, item, execContext);\n  });\n}\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nexport function merge(dest, src) {\n  if (src !== null && typeof src === 'object') {\n    Object.keys(src).forEach(key => {\n      const srcVal = src[key];\n      if (!hasOwn.call(dest, key)) {\n        dest[key] = srcVal;\n      } else {\n        merge(dest[key], srcVal);\n      }\n    });\n  }\n}\n","import graphqlAnywhere, { Resolver, ExecInfo } from 'graphql-anywhere';\n\nimport {\n  IdValue,\n  assign,\n  isEqual,\n  getDefaultValues,\n  getQueryDefinition,\n  isJsonValue,\n  isIdValue,\n  toIdValue,\n  getStoreKeyName,\n  StoreValue,\n} from 'apollo-utilities';\n\nimport { Cache } from 'apollo-cache';\n\nimport {\n  ReadQueryOptions,\n  IdValueWithPreviousResult,\n  ReadStoreContext,\n  DiffQueryAgainstStoreOptions,\n  StoreObject,\n} from './types';\n\n/**\n * The key which the cache id for a given value is stored in the result object. This key is private\n * and should not be used by Apollo client users.\n *\n * Uses a symbol if available in the environment.\n *\n * @private\n */\nexport const ID_KEY = typeof Symbol !== 'undefined' ? Symbol('id') : '@@id';\n\n/**\n * Resolves the result of a query solely from the store (i.e. never hits the server).\n *\n * @param {Store} store The {@link NormalizedCache} used by Apollo for the `data` portion of the\n * store.\n *\n * @param {DocumentNode} query The query document to resolve from the data available in the store.\n *\n * @param {Object} [variables] A map from the name of a variable to its value. These variables can\n * be referenced by the query document.\n *\n * @param {any} previousResult The previous result returned by this function for the same query.\n * If nothing in the store changed since that previous result then values from the previous result\n * will be returned to preserve referential equality.\n */\nexport function readQueryFromStore<QueryType>(\n  options: ReadQueryOptions,\n): QueryType {\n  const optsPatch = { returnPartialData: false };\n\n  return diffQueryAgainstStore<QueryType>({\n    ...options,\n    ...optsPatch,\n  }).result;\n}\n\nconst readStoreResolver: Resolver = (\n  fieldName: string,\n  idValue: IdValueWithPreviousResult,\n  args: any,\n  context: ReadStoreContext,\n  { resultKey, directives }: ExecInfo,\n) => {\n  assertIdValue(idValue);\n\n  const objId = idValue.id;\n  const obj = context.store.get(objId);\n\n  let storeKeyName = fieldName;\n  if (args || directives) {\n    // We happen to know here that getStoreKeyName returns its first\n    // argument unmodified if there are no args or directives, so we can\n    // avoid calling the function at all in that case, as a small but\n    // important optimization to this frequently executed code.\n    storeKeyName = getStoreKeyName(storeKeyName, args, directives);\n  }\n\n  let fieldValue: StoreValue | string | void = void 0;\n\n  if (obj) {\n    fieldValue = obj[storeKeyName];\n\n    if (\n      typeof fieldValue === 'undefined' &&\n      context.cacheRedirects &&\n      (obj.__typename || objId === 'ROOT_QUERY')\n    ) {\n      const typename = obj.__typename || 'Query';\n\n      // Look for the type in the custom resolver map\n      const type = context.cacheRedirects[typename];\n      if (type) {\n        // Look for the field in the custom resolver map\n        const resolver = type[fieldName];\n        if (resolver) {\n          fieldValue = resolver(obj, args, {\n            getCacheKey(storeObj: StoreObject) {\n              return toIdValue({\n                id: context.dataIdFromObject(storeObj),\n                typename: storeObj.__typename,\n              });\n            },\n          });\n        }\n      }\n    }\n  }\n\n  if (typeof fieldValue === 'undefined') {\n    if (!context.returnPartialData) {\n      throw new Error(\n        `Can't find field ${storeKeyName} on object (${objId}) ${JSON.stringify(\n          obj,\n          null,\n          2,\n        )}.`,\n      );\n    }\n\n    context.hasMissingField = true;\n\n    return fieldValue;\n  }\n\n  // if this is an object scalar, it must be a json blob and we have to unescape it\n  if (isJsonValue(fieldValue)) {\n    // If the JSON blob is the same now as in the previous result, return the previous result to\n    // maintain referential equality.\n    //\n    // `isEqual` will first perform a referential equality check (with `===`) in case the JSON\n    // value has not changed in the store, and then a deep equality check if that fails in case a\n    // new JSON object was returned by the API but that object may still be the same.\n    if (\n      idValue.previousResult &&\n      isEqual(idValue.previousResult[resultKey], fieldValue.json)\n    ) {\n      return idValue.previousResult[resultKey];\n    }\n    return fieldValue.json;\n  }\n\n  // If we had a previous result, try adding that previous result value for this field to our field\n  // value. This will create a new value without mutating the old one.\n  if (idValue.previousResult) {\n    fieldValue = addPreviousResultToIdValues(\n      fieldValue,\n      idValue.previousResult[resultKey],\n    );\n  }\n\n  return fieldValue;\n};\n\n/**\n * Given a store and a query, return as much of the result as possible and\n * identify if any data was missing from the store.\n * @param  {DocumentNode} query A parsed GraphQL query document\n * @param  {Store} store The Apollo Client store object\n * @param  {any} previousResult The previous result returned by this function for the same query\n * @return {result: Object, complete: [boolean]}\n */\nexport function diffQueryAgainstStore<T>({\n  store,\n  query,\n  variables,\n  previousResult,\n  returnPartialData = true,\n  rootId = 'ROOT_QUERY',\n  fragmentMatcherFunction,\n  config,\n}: DiffQueryAgainstStoreOptions): Cache.DiffResult<T> {\n  // Throw the right validation error by trying to find a query in the document\n  const queryDefinition = getQueryDefinition(query);\n\n  variables = assign({}, getDefaultValues(queryDefinition), variables);\n\n  const context: ReadStoreContext = {\n    // Global settings\n    store,\n    returnPartialData,\n    dataIdFromObject: (config && config.dataIdFromObject) || null,\n    cacheRedirects: (config && config.cacheRedirects) || {},\n    // Flag set during execution\n    hasMissingField: false,\n  };\n\n  const rootIdValue = {\n    type: 'id',\n    id: rootId,\n    previousResult,\n  };\n\n  const result = graphqlAnywhere(\n    readStoreResolver,\n    query,\n    rootIdValue,\n    context,\n    variables,\n    {\n      fragmentMatcher: fragmentMatcherFunction,\n      resultMapper,\n    },\n  );\n\n  return {\n    result: result as T,\n    complete: !context.hasMissingField,\n  };\n}\n\nexport function assertIdValue(idValue: IdValue) {\n  if (!isIdValue(idValue)) {\n    throw new Error(`Encountered a sub-selection on the query, but the store doesn't have \\\nan object reference. This should never happen during normal use unless you have custom code \\\nthat is directly manipulating the store; please file an issue.`);\n  }\n}\n\n/**\n * Adds a previous result value to id values in a nested array. For a single id value and a single\n * previous result then the previous value is added directly.\n *\n * For arrays we put all of the ids from the previous result array in a map and add them to id\n * values with the same id.\n *\n * This function does not mutate. Instead it returns new instances of modified values.\n *\n * @private\n */\nfunction addPreviousResultToIdValues(value: any, previousResult: any): any {\n  // If the value is an `IdValue`, add the previous result to it whether or not that\n  // `previousResult` is undefined.\n  //\n  // If the value is an array, recurse over each item trying to add the `previousResult` for that\n  // item.\n  if (isIdValue(value)) {\n    return {\n      ...value,\n      previousResult,\n    };\n  } else if (Array.isArray(value)) {\n    const idToPreviousResult: Map<string, any> = new Map();\n\n    // If the previous result was an array, we want to build up our map of ids to previous results\n    // using the private `ID_KEY` property that is added in `resultMapper`.\n    if (Array.isArray(previousResult)) {\n      previousResult.forEach(item => {\n        // item can be null\n        if (item && item[ID_KEY]) {\n          idToPreviousResult.set(item[ID_KEY], item);\n          // idToPreviousResult[item[ID_KEY]] = item;\n        }\n      });\n    }\n\n    // For every value we want to add the previous result.\n    return value.map((item, i) => {\n      // By default the previous result for this item will be in the same array position as this\n      // item.\n      let itemPreviousResult = previousResult && previousResult[i];\n\n      // If the item is an id value, we should check to see if there is a previous result for this\n      // specific id. If there is, that will be the value for `itemPreviousResult`.\n      if (isIdValue(item)) {\n        itemPreviousResult =\n          idToPreviousResult.get(item.id) || itemPreviousResult;\n      }\n\n      return addPreviousResultToIdValues(item, itemPreviousResult);\n    });\n  }\n  // Return the value, nothing changed.\n  return value;\n}\n\n/**\n * Maps a result from `graphql-anywhere` to a final result value.\n *\n * If the result and the previous result from the `idValue` pass a shallow equality test, we just\n * return the `previousResult` to maintain referential equality.\n *\n * We also add a private id property to the result that we can use later on.\n *\n * @private\n */\nfunction resultMapper(resultFields: any, idValue: IdValueWithPreviousResult) {\n  // If we had a previous result, we may be able to return that and preserve referential equality\n  if (idValue.previousResult) {\n    const currentResultKeys = Object.keys(resultFields);\n\n    const sameAsPreviousResult =\n      // Confirm that we have the same keys in both the current result and the previous result.\n      Object.keys(idValue.previousResult).every(\n        key => currentResultKeys.indexOf(key) > -1,\n      ) &&\n      // Perform a shallow comparison of the result fields with the previous result. If all of\n      // the shallow fields are referentially equal to the fields of the previous result we can\n      // just return the previous result.\n      //\n      // While we do a shallow comparison of objects, but we do a deep comparison of arrays.\n      currentResultKeys.every(key =>\n        areNestedArrayItemsStrictlyEqual(\n          resultFields[key],\n          idValue.previousResult[key],\n        ),\n      );\n\n    if (sameAsPreviousResult) {\n      return idValue.previousResult;\n    }\n  }\n\n  Object.defineProperty(resultFields, ID_KEY, {\n    enumerable: false,\n    configurable: true,\n    writable: false,\n    value: idValue.id,\n  });\n\n  return resultFields;\n}\n\ntype NestedArray<T> = T | Array<T | Array<T | Array<T>>>;\n\n/**\n * Compare all the items to see if they are all referentially equal in two arrays no matter how\n * deeply nested the arrays are.\n *\n * @private\n */\nfunction areNestedArrayItemsStrictlyEqual(\n  a: NestedArray<any>,\n  b: NestedArray<any>,\n): boolean {\n  // If `a` and `b` are referentially equal, return true.\n  if (a === b) {\n    return true;\n  }\n  // If either `a` or `b` are not an array or not of the same length return false. `a` and `b` are\n  // known to not be equal here, we checked above.\n  if (!Array.isArray(a) || !Array.isArray(b) || a.length !== b.length) {\n    return false;\n  }\n  // Otherwise let us compare all of the array items (which are potentially nested arrays!) to see\n  // if they are equal.\n  return a.every((item, i) => areNestedArrayItemsStrictlyEqual(item, b[i]));\n}\n","import { NormalizedCache, NormalizedCacheObject, StoreObject } from './types';\n\nexport class RecordingCache implements NormalizedCache {\n  private recordedData: NormalizedCacheObject = {};\n\n  constructor(private readonly data: NormalizedCacheObject = {}) {}\n\n  public record(\n    transaction: (recordingCache: RecordingCache) => void,\n  ): NormalizedCacheObject {\n    transaction(this);\n    const recordedData = this.recordedData;\n    this.recordedData = {};\n    return recordedData;\n  }\n\n  public toObject(): NormalizedCacheObject {\n    return { ...this.data, ...this.recordedData };\n  }\n\n  public get(dataId: string): StoreObject {\n    if (this.recordedData.hasOwnProperty(dataId)) {\n      // recording always takes precedence:\n      return this.recordedData[dataId];\n    }\n    return this.data[dataId];\n  }\n\n  public set(dataId: string, value: StoreObject) {\n    if (this.get(dataId) !== value) {\n      this.recordedData[dataId] = value;\n    }\n  }\n\n  public delete(dataId: string): void {\n    this.recordedData[dataId] = undefined;\n  }\n\n  public clear(): void {\n    Object.keys(this.data).forEach(dataId => this.delete(dataId));\n    this.recordedData = {};\n  }\n\n  public replace(newData: NormalizedCacheObject): void {\n    this.clear();\n    this.recordedData = { ...newData };\n  }\n}\n\nexport function record(\n  startingState: NormalizedCacheObject,\n  transaction: (recordingCache: RecordingCache) => void,\n): NormalizedCacheObject {\n  const recordingCache = new RecordingCache(startingState);\n  return recordingCache.record(transaction);\n}\n","import { DocumentNode } from 'graphql';\n\nimport { Cache, DataProxy, ApolloCache, Transaction } from 'apollo-cache';\n\nimport {\n  getFragmentQueryDocument,\n  addTypenameToDocument,\n} from 'apollo-utilities';\n\nimport { HeuristicFragmentMatcher } from './fragmentMatcher';\nimport {\n  OptimisticStoreItem,\n  ApolloReducerConfig,\n  NormalizedCache,\n  NormalizedCacheObject,\n} from './types';\nimport { writeResultToStore } from './writeToStore';\nimport { readQueryFromStore, diffQueryAgainstStore } from './readFromStore';\nimport { defaultNormalizedCacheFactory } from './objectCache';\nimport { record } from './recordingCache';\nconst defaultConfig: ApolloReducerConfig = {\n  fragmentMatcher: new HeuristicFragmentMatcher(),\n  dataIdFromObject: defaultDataIdFromObject,\n  addTypename: true,\n  storeFactory: defaultNormalizedCacheFactory,\n};\n\nexport function defaultDataIdFromObject(result: any): string | null {\n  if (result.__typename) {\n    if (result.id !== undefined) {\n      return `${result.__typename}:${result.id}`;\n    }\n    if (result._id !== undefined) {\n      return `${result.__typename}:${result._id}`;\n    }\n  }\n  return null;\n}\n\nexport class InMemoryCache extends ApolloCache<NormalizedCacheObject> {\n  protected data: NormalizedCache;\n  protected config: ApolloReducerConfig;\n  protected optimistic: OptimisticStoreItem[] = [];\n  private watches: Cache.WatchOptions[] = [];\n  private addTypename: boolean;\n  private typenameDocumentCache = new WeakMap<DocumentNode, DocumentNode>();\n\n  // Set this while in a transaction to prevent broadcasts...\n  // don't forget to turn it back on!\n  private silenceBroadcast: boolean = false;\n\n  constructor(config: ApolloReducerConfig = {}) {\n    super();\n    this.config = { ...defaultConfig, ...config };\n\n    // backwards compat\n    if ((this.config as any).customResolvers) {\n      console.warn(\n        'customResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating customResolvers in the next major version.',\n      );\n      this.config.cacheRedirects = (this.config as any).customResolvers;\n    }\n\n    if ((this.config as any).cacheResolvers) {\n      console.warn(\n        'cacheResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating cacheResolvers in the next major version.',\n      );\n      this.config.cacheRedirects = (this.config as any).cacheResolvers;\n    }\n\n    this.addTypename = this.config.addTypename;\n    this.data = this.config.storeFactory();\n  }\n\n  public restore(data: NormalizedCacheObject): this {\n    if (data) this.data.replace(data);\n    return this;\n  }\n\n  public extract(optimistic: boolean = false): NormalizedCacheObject {\n    if (optimistic && this.optimistic.length > 0) {\n      const patches = this.optimistic.map(opt => opt.data);\n      return Object.assign({}, this.data.toObject(), ...patches);\n    }\n\n    return this.data.toObject();\n  }\n\n  public read<T>(query: Cache.ReadOptions): T | null {\n    if (query.rootId && this.data.get(query.rootId) === undefined) {\n      return null;\n    }\n\n    return readQueryFromStore({\n      store: this.config.storeFactory(this.extract(query.optimistic)),\n      query: this.transformDocument(query.query),\n      variables: query.variables,\n      rootId: query.rootId,\n      fragmentMatcherFunction: this.config.fragmentMatcher.match,\n      previousResult: query.previousResult,\n      config: this.config,\n    });\n  }\n\n  public write(write: Cache.WriteOptions): void {\n    writeResultToStore({\n      dataId: write.dataId,\n      result: write.result,\n      variables: write.variables,\n      document: this.transformDocument(write.query),\n      store: this.data,\n      dataIdFromObject: this.config.dataIdFromObject,\n      fragmentMatcherFunction: this.config.fragmentMatcher.match,\n    });\n\n    this.broadcastWatches();\n  }\n\n  public diff<T>(query: Cache.DiffOptions): Cache.DiffResult<T> {\n    return diffQueryAgainstStore({\n      store: this.config.storeFactory(this.extract(query.optimistic)),\n      query: this.transformDocument(query.query),\n      variables: query.variables,\n      returnPartialData: query.returnPartialData,\n      previousResult: query.previousResult,\n      fragmentMatcherFunction: this.config.fragmentMatcher.match,\n      config: this.config,\n    });\n  }\n\n  public watch(watch: Cache.WatchOptions): () => void {\n    this.watches.push(watch);\n\n    return () => {\n      this.watches = this.watches.filter(c => c !== watch);\n    };\n  }\n\n  public evict(query: Cache.EvictOptions): Cache.EvictionResult {\n    throw new Error(`eviction is not implemented on InMemory Cache`);\n  }\n\n  public reset(): Promise<void> {\n    this.data.clear();\n    this.broadcastWatches();\n\n    return Promise.resolve();\n  }\n\n  public removeOptimistic(id: string) {\n    // Throw away optimistic changes of that particular mutation\n    const toPerform = this.optimistic.filter(item => item.id !== id);\n\n    this.optimistic = [];\n\n    // Re-run all of our optimistic data actions on top of one another.\n    toPerform.forEach(change => {\n      this.recordOptimisticTransaction(change.transaction, change.id);\n    });\n\n    this.broadcastWatches();\n  }\n\n  public performTransaction(transaction: Transaction<NormalizedCacheObject>) {\n    // TODO: does this need to be different, or is this okay for an in-memory cache?\n\n    let alreadySilenced = this.silenceBroadcast;\n    this.silenceBroadcast = true;\n\n    transaction(this);\n\n    if (!alreadySilenced) {\n      // Don't un-silence since this is a nested transaction\n      // (for example, a transaction inside an optimistic record)\n      this.silenceBroadcast = false;\n    }\n\n    this.broadcastWatches();\n  }\n\n  public recordOptimisticTransaction(\n    transaction: Transaction<NormalizedCacheObject>,\n    id: string,\n  ) {\n    this.silenceBroadcast = true;\n\n    const patch = record(this.extract(true), recordingCache => {\n      // swapping data instance on 'this' is currently necessary\n      // because of the current architecture\n      const dataCache = this.data;\n      this.data = recordingCache;\n      this.performTransaction(transaction);\n      this.data = dataCache;\n    });\n\n    this.optimistic.push({\n      id,\n      transaction,\n      data: patch,\n    });\n\n    this.silenceBroadcast = false;\n\n    this.broadcastWatches();\n  }\n\n  public transformDocument(document: DocumentNode): DocumentNode {\n    if (this.addTypename) {\n      let result = this.typenameDocumentCache.get(document);\n      if (!result) {\n        this.typenameDocumentCache.set(\n          document,\n          (result = addTypenameToDocument(document)),\n        );\n      }\n      return result;\n    }\n    return document;\n  }\n\n  public readQuery<QueryType, TVariables = any>(\n    options: DataProxy.Query<TVariables>,\n    optimistic: boolean = false,\n  ): QueryType {\n    return this.read({\n      query: options.query,\n      variables: options.variables,\n      optimistic,\n    });\n  }\n\n  public readFragment<FragmentType, TVariables = any>(\n    options: DataProxy.Fragment<TVariables>,\n    optimistic: boolean = false,\n  ): FragmentType | null {\n    return this.read({\n      query: this.transformDocument(\n        getFragmentQueryDocument(options.fragment, options.fragmentName),\n      ),\n      variables: options.variables,\n      rootId: options.id,\n      optimistic,\n    });\n  }\n\n  public writeQuery<TData = any, TVariables = any>(\n    options: DataProxy.WriteQueryOptions<TData, TVariables>,\n  ): void {\n    this.write({\n      dataId: 'ROOT_QUERY',\n      result: options.data,\n      query: this.transformDocument(options.query),\n      variables: options.variables,\n    });\n  }\n\n  public writeFragment<TData = any, TVariables = any>(\n    options: DataProxy.WriteFragmentOptions<TData, TVariables>,\n  ): void {\n    this.write({\n      dataId: options.id,\n      result: options.data,\n      query: this.transformDocument(\n        getFragmentQueryDocument(options.fragment, options.fragmentName),\n      ),\n      variables: options.variables,\n    });\n  }\n\n  protected broadcastWatches() {\n    // Skip this when silenced (like inside a transaction)\n    if (this.silenceBroadcast) return;\n\n    // right now, we invalidate all queries whenever anything changes\n    this.watches.forEach((c: Cache.WatchOptions) => {\n      const newData = this.diff({\n        query: c.query,\n        variables: c.variables,\n\n        // TODO: previousResult isn't in the types - this will only work\n        // with ObservableQuery which is in a different package\n        previousResult: (c as any).previousResult && c.previousResult(),\n        optimistic: c.optimistic,\n      });\n\n      c.callback(newData);\n    });\n  }\n}\n","import { Operation } from 'apollo-link';\nimport { print } from 'graphql/language/printer';\n\n/*\n * Http Utilities: shared across links that make http requests\n */\n\n// XXX replace with actual typings when available\ndeclare var AbortController: any;\n\n//Used for any Error for data from the server\n//on a request with a Status >= 300\n//response contains no data or errors\nexport type ServerError = Error & {\n  response: Response;\n  result: Record<string, any>;\n  statusCode: number;\n};\n\n//Thrown when server's resonse is cannot be parsed\nexport type ServerParseError = Error & {\n  response: Response;\n  statusCode: number;\n  bodyText: string;\n};\n\nexport type ClientParseError = Error & {\n  parseError: Error;\n};\n\nexport interface HttpQueryOptions {\n  includeQuery?: boolean;\n  includeExtensions?: boolean;\n}\n\nexport interface HttpConfig {\n  http?: HttpQueryOptions;\n  options?: any;\n  headers?: any; //overrides headers in options\n  credentials?: any;\n}\n\nexport interface UriFunction {\n  (operation: Operation): string;\n}\n\n// The body of a GraphQL-over-HTTP-POST request.\nexport interface Body {\n  query?: string;\n  operationName?: string;\n  variables?: Record<string, any>;\n  extensions?: Record<string, any>;\n}\n\nexport interface HttpOptions {\n  /**\n   * The URI to use when fetching operations.\n   *\n   * Defaults to '/graphql'.\n   */\n  uri?: string | UriFunction;\n\n  /**\n   * Passes the extensions field to your graphql server.\n   *\n   * Defaults to false.\n   */\n  includeExtensions?: boolean;\n\n  /**\n   * A `fetch`-compatible API to use when making requests.\n   */\n  fetch?: GlobalFetch['fetch'];\n\n  /**\n   * An object representing values to be sent as headers on the request.\n   */\n  headers?: any;\n\n  /**\n   * The credentials policy you want to use for the fetch call.\n   */\n  credentials?: string;\n\n  /**\n   * Any overrides of the fetch options argument to pass to the fetch call.\n   */\n  fetchOptions?: any;\n}\n\nconst defaultHttpOptions: HttpQueryOptions = {\n  includeQuery: true,\n  includeExtensions: false,\n};\n\nconst defaultHeaders = {\n  // headers are case insensitive (https://stackoverflow.com/a/5259004)\n  accept: '*/*',\n  'content-type': 'application/json',\n};\n\nconst defaultOptions = {\n  method: 'POST',\n};\n\nexport const fallbackHttpConfig = {\n  http: defaultHttpOptions,\n  headers: defaultHeaders,\n  options: defaultOptions,\n};\n\nexport const throwServerError = (response, result, message) => {\n  const error = new Error(message) as ServerError;\n\n  error.response = response;\n  error.statusCode = response.status;\n  error.result = result;\n\n  throw error;\n};\n\n//TODO: when conditional types come in ts 2.8, operations should be a generic type that extends Operation | Array<Operation>\nexport const parseAndCheckHttpResponse = operations => (response: Response) => {\n  return (\n    response\n      .text()\n      .then(bodyText => {\n        try {\n          return JSON.parse(bodyText);\n        } catch (err) {\n          const parseError = err as ServerParseError;\n          parseError.response = response;\n          parseError.statusCode = response.status;\n          parseError.bodyText = bodyText;\n          return Promise.reject(parseError);\n        }\n      })\n      //TODO: when conditional types come out then result should be T extends Array ? Array<FetchResult> : FetchResult\n      .then((result: any) => {\n        if (response.status >= 300) {\n          //Network error\n          throwServerError(\n            response,\n            result,\n            `Response not successful: Received status code ${response.status}`,\n          );\n        }\n        //TODO should really error per response in a Batch based on properties\n        //    - could be done in a validation link\n        if (\n          !Array.isArray(result) &&\n          !result.hasOwnProperty('data') &&\n          !result.hasOwnProperty('errors')\n        ) {\n          //Data error\n          throwServerError(\n            response,\n            result,\n            `Server response was missing for query '${\n              Array.isArray(operations)\n                ? operations.map(op => op.operationName)\n                : operations.operationName\n            }'.`,\n          );\n        }\n        return result;\n      })\n  );\n};\n\nexport const checkFetcher = (fetcher: GlobalFetch['fetch']) => {\n  if (!fetcher && typeof fetch === 'undefined') {\n    let library: string = 'unfetch';\n    if (typeof window === 'undefined') library = 'node-fetch';\n    throw new Error(`\nfetch is not found globally and no fetcher passed, to fix pass a fetch for\nyour environment like https://www.npmjs.com/package/${library}.\n\nFor example:\nimport fetch from '${library}';\nimport { createHttpLink } from 'apollo-link-http';\n\nconst link = createHttpLink({ uri: '/graphql', fetch: fetch });`);\n  }\n};\n\nexport const createSignalIfSupported = () => {\n  if (typeof AbortController === 'undefined')\n    return { controller: false, signal: false };\n\n  const controller = new AbortController();\n  const signal = controller.signal;\n  return { controller, signal };\n};\n\nexport const selectHttpOptionsAndBody = (\n  operation: Operation,\n  fallbackConfig: HttpConfig,\n  ...configs: Array<HttpConfig>\n) => {\n  let options: HttpConfig & Record<string, any> = {\n    ...fallbackConfig.options,\n    headers: fallbackConfig.headers,\n    credentials: fallbackConfig.credentials,\n  };\n  let http: HttpQueryOptions = fallbackConfig.http;\n\n  /*\n   * use the rest of the configs to populate the options\n   * configs later in the list will overwrite earlier fields\n   */\n  configs.forEach(config => {\n    options = {\n      ...options,\n      ...config.options,\n      headers: {\n        ...options.headers,\n        ...config.headers,\n      },\n    };\n    if (config.credentials) options.credentials = config.credentials;\n\n    http = {\n      ...http,\n      ...config.http,\n    };\n  });\n\n  //The body depends on the http options\n  const { operationName, extensions, variables, query } = operation;\n  const body: Body = { operationName, variables };\n\n  if (http.includeExtensions) (body as any).extensions = extensions;\n\n  // not sending the query (i.e persisted queries)\n  if (http.includeQuery) (body as any).query = print(query);\n\n  return {\n    options,\n    body,\n  };\n};\n\nexport const serializeFetchParameter = (p, label) => {\n  let serialized;\n  try {\n    serialized = JSON.stringify(p);\n  } catch (e) {\n    const parseError = new Error(\n      `Network request failed. ${label} is not serializable: ${e.message}`,\n    ) as ClientParseError;\n    parseError.parseError = e;\n    throw parseError;\n  }\n  return serialized;\n};\n\n//selects \"/graphql\" by default\nexport const selectURI = (\n  operation,\n  fallbackURI?: string | ((operation: Operation) => string),\n) => {\n  const context = operation.getContext();\n  const contextURI = context.uri;\n\n  if (contextURI) {\n    return contextURI;\n  } else if (typeof fallbackURI === 'function') {\n    return fallbackURI(operation);\n  } else {\n    return (fallbackURI as string) || '/graphql';\n  }\n};\n","import { ApolloLink, Observable, RequestHandler, fromError } from 'apollo-link';\nimport {\n  serializeFetchParameter,\n  selectURI,\n  parseAndCheckHttpResponse,\n  checkFetcher,\n  selectHttpOptionsAndBody,\n  createSignalIfSupported,\n  fallbackHttpConfig,\n  Body,\n  HttpOptions,\n  UriFunction as _UriFunction,\n} from 'apollo-link-http-common';\nimport { DefinitionNode } from 'graphql';\n\nexport namespace HttpLink {\n  //TODO Would much rather be able to export directly\n  export interface UriFunction extends _UriFunction {}\n  export interface Options extends HttpOptions {\n    /**\n     * If set to true, use the HTTP GET method for query operations. Mutations\n     * will still use the method specified in fetchOptions.method (which defaults\n     * to POST).\n     */\n    useGETForQueries?: boolean;\n  }\n}\n\n// For backwards compatibility.\nexport import FetchOptions = HttpLink.Options;\nexport import UriFunction = HttpLink.UriFunction;\n\nexport const createHttpLink = (linkOptions: HttpLink.Options = {}) => {\n  let {\n    uri = '/graphql',\n    // use default global fetch is nothing passed in\n    fetch: fetcher,\n    includeExtensions,\n    useGETForQueries,\n    ...requestOptions\n  } = linkOptions;\n\n  // dev warnings to ensure fetch is present\n  checkFetcher(fetcher);\n\n  //fetcher is set here rather than the destructuring to ensure fetch is\n  //declared before referencing it. Reference in the destructuring would cause\n  //a ReferenceError\n  if (!fetcher) {\n    fetcher = fetch;\n  }\n\n  const linkConfig = {\n    http: { includeExtensions },\n    options: requestOptions.fetchOptions,\n    credentials: requestOptions.credentials,\n    headers: requestOptions.headers,\n  };\n\n  return new ApolloLink(operation => {\n    let chosenURI = selectURI(operation, uri);\n\n    const context = operation.getContext();\n\n    const contextConfig = {\n      http: context.http,\n      options: context.fetchOptions,\n      credentials: context.credentials,\n      headers: context.headers,\n    };\n\n    //uses fallback, link, and then context to build options\n    const { options, body } = selectHttpOptionsAndBody(\n      operation,\n      fallbackHttpConfig,\n      linkConfig,\n      contextConfig,\n    );\n\n    let controller;\n    if (!(options as any).signal) {\n      const { controller: _controller, signal } = createSignalIfSupported();\n      controller = _controller;\n      if (controller) (options as any).signal = signal;\n    }\n\n    // If requested, set method to GET if there are no mutations.\n    const definitionIsMutation = (d: DefinitionNode) => {\n      return d.kind === 'OperationDefinition' && d.operation === 'mutation';\n    };\n    if (\n      useGETForQueries &&\n      !operation.query.definitions.some(definitionIsMutation)\n    ) {\n      options.method = 'GET';\n    }\n\n    if (options.method === 'GET') {\n      const { newURI, parseError } = rewriteURIForGET(chosenURI, body);\n      if (parseError) {\n        return fromError(parseError);\n      }\n      chosenURI = newURI;\n    } else {\n      try {\n        (options as any).body = serializeFetchParameter(body, 'Payload');\n      } catch (parseError) {\n        return fromError(parseError);\n      }\n    }\n\n    return new Observable(observer => {\n      fetcher(chosenURI, options)\n        .then(response => {\n          operation.setContext({ response });\n          return response;\n        })\n        .then(parseAndCheckHttpResponse(operation))\n        .then(result => {\n          // we have data and can send it to back up the link chain\n          observer.next(result);\n          observer.complete();\n          return result;\n        })\n        .catch(err => {\n          // fetch was cancelled so its already been cleaned up in the unsubscribe\n          if (err.name === 'AbortError') return;\n          // if it is a network error, BUT there is graphql result info\n          // fire the next observer before calling error\n          // this gives apollo-client (and react-apollo) the `graphqlErrors` and `networErrors`\n          // to pass to UI\n          // this should only happen if we *also* have data as part of the response key per\n          // the spec\n          if (err.result && err.result.errors && err.result.data) {\n            // if we dont' call next, the UI can only show networkError because AC didn't\n            // get andy graphqlErrors\n            // this is graphql execution result info (i.e errors and possibly data)\n            // this is because there is no formal spec how errors should translate to\n            // http status codes. So an auth error (401) could have both data\n            // from a public field, errors from a private field, and a status of 401\n            // {\n            //  user { // this will have errors\n            //    firstName\n            //  }\n            //  products { // this is public so will have data\n            //    cost\n            //  }\n            // }\n            //\n            // the result of above *could* look like this:\n            // {\n            //   data: { products: [{ cost: \"$10\" }] },\n            //   errors: [{\n            //      message: 'your session has timed out',\n            //      path: []\n            //   }]\n            // }\n            // status code of above would be a 401\n            // in the UI you want to show data where you can, errors as data where you can\n            // and use correct http status codes\n            observer.next(err.result);\n          }\n          observer.error(err);\n        });\n\n      return () => {\n        // XXX support canceling this request\n        // https://developers.google.com/web/updates/2017/09/abortable-fetch\n        if (controller) controller.abort();\n      };\n    });\n  });\n};\n\n// For GET operations, returns the given URI rewritten with parameters, or a\n// parse error.\nfunction rewriteURIForGET(chosenURI: string, body: Body) {\n  // Implement the standard HTTP GET serialization, plus 'extensions'. Note\n  // the extra level of JSON serialization!\n  const queryParams = [];\n  const addQueryParam = (key: string, value: string) => {\n    queryParams.push(`${key}=${encodeURIComponent(value)}`);\n  };\n\n  if ('query' in body) {\n    addQueryParam('query', body.query);\n  }\n  if (body.operationName) {\n    addQueryParam('operationName', body.operationName);\n  }\n  if (body.variables) {\n    let serializedVariables;\n    try {\n      serializedVariables = serializeFetchParameter(\n        body.variables,\n        'Variables map',\n      );\n    } catch (parseError) {\n      return { parseError };\n    }\n    addQueryParam('variables', serializedVariables);\n  }\n  if (body.extensions) {\n    let serializedExtensions;\n    try {\n      serializedExtensions = serializeFetchParameter(\n        body.extensions,\n        'Extensions map',\n      );\n    } catch (parseError) {\n      return { parseError };\n    }\n    addQueryParam('extensions', serializedExtensions);\n  }\n\n  // Reconstruct the URI with added query params.\n  // XXX This assumes that the URI is well-formed and that it doesn't\n  //     already contain any of these query params. We could instead use the\n  //     URL API and take a polyfill (whatwg-url@6) for older browsers that\n  //     don't support URLSearchParams. Note that some browsers (and\n  //     versions of whatwg-url) support URL but not URLSearchParams!\n  let fragment = '',\n    preFragment = chosenURI;\n  const fragmentStart = chosenURI.indexOf('#');\n  if (fragmentStart !== -1) {\n    fragment = chosenURI.substr(fragmentStart);\n    preFragment = chosenURI.substr(0, fragmentStart);\n  }\n  const queryParamsPrefix = preFragment.indexOf('?') === -1 ? '?' : '&';\n  const newURI =\n    preFragment + queryParamsPrefix + queryParams.join('&') + fragment;\n  return { newURI };\n}\n\nexport class HttpLink extends ApolloLink {\n  public requester: RequestHandler;\n  constructor(opts?: HttpLink.Options) {\n    super(createHttpLink(opts).request);\n  }\n}\n","import { DocumentNode, DirectiveNode } from 'graphql';\n\nimport {\n  checkDocument,\n  removeDirectivesFromDocument,\n} from 'apollo-utilities';\n\nconst connectionRemoveConfig = {\n  test: (directive: DirectiveNode) => directive.name.value === 'client',\n  remove: true,\n};\n\nconst removed = new Map();\nexport function removeClientSetsFromDocument(\n  query: DocumentNode,\n): DocumentNode {\n  // caching\n  const cached = removed.get(query);\n  if (cached) return cached;\n\n  checkDocument(query);\n\n  const docClone = removeDirectivesFromDocument(\n    [connectionRemoveConfig],\n    query,\n  );\n\n  // caching\n  removed.set(query, docClone);\n  return docClone;\n}\n","import {\n  ApolloLink,\n  Observable,\n  Operation,\n  NextLink,\n  FetchResult,\n} from 'apollo-link';\nimport { ApolloCache } from 'apollo-cache';\n\nimport { hasDirectives, getMainDefinition } from 'apollo-utilities';\nimport { graphql } from 'graphql-anywhere/lib/async';\n\nimport { removeClientSetsFromDocument } from './utils';\n\nconst capitalizeFirstLetter = str => str.charAt(0).toUpperCase() + str.slice(1);\n\nexport type ClientStateConfig = {\n  cache?: ApolloCache<any>;\n  resolvers: any;\n  defaults?: any;\n  typeDefs?: string | string[];\n};\n\nexport const withClientState = (\n  clientStateConfig: ClientStateConfig = { resolvers: {}, defaults: {} },\n) => {\n  const { resolvers, defaults, cache, typeDefs } = clientStateConfig;\n  if (cache && defaults) {\n    cache.writeData({ data: defaults });\n  }\n\n  return new class StateLink extends ApolloLink {\n    public writeDefaults() {\n      if (cache && defaults) {\n        cache.writeData({ data: defaults });\n      }\n    }\n\n    public request(\n      operation: Operation,\n      forward: NextLink = () => Observable.of({ data: {} }),\n    ): Observable<FetchResult> {\n      if (typeDefs) {\n        const directives = 'directive @client on FIELD';\n        const definition =\n          typeof typeDefs === 'string'\n            ? typeDefs\n            : typeDefs.map(typeDef => typeDef.trim()).join('\\n');\n\n        operation.setContext(({ schemas = [] }) => ({\n          schemas: schemas.concat([{ definition, directives }]),\n        }));\n      }\n\n      const isClient = hasDirectives(['client'], operation.query);\n\n      if (!isClient) return forward(operation);\n\n      const server = removeClientSetsFromDocument(operation.query);\n      const { query } = operation;\n      const type =\n        capitalizeFirstLetter(\n          (getMainDefinition(query) || ({} as any)).operation,\n        ) || 'Query';\n\n      const resolver = (fieldName, rootValue = {}, args, context, info) => {\n        //resultKey is where data under the field name is ultimately returned by the server\n        //https://github.com/apollographql/apollo-client/tree/master/packages/graphql-anywhere#resolver-info\n        const fieldValue = rootValue[info.resultKey];\n\n        //If fieldValue is defined, server returned a value\n        if (fieldValue !== undefined) return fieldValue;\n\n        // Look for the field in the custom resolver map\n        const resolverMap = resolvers[(rootValue as any).__typename || type];\n        if (resolverMap) {\n          const resolve = resolverMap[fieldName];\n          if (resolve) return resolve(rootValue, args, context, info);\n        }\n        //TODO: the proper thing to do here is throw an error saying to\n        //add `client.onResetStore(link.writeDefaults);`\n        //waiting on https://github.com/apollographql/apollo-client/pull/3010\n        //Currently with nested fields, this sort of return does not work\n        return defaults[fieldName];\n      };\n\n      return new Observable(observer => {\n        if (server) operation.query = server;\n        const obs =\n          server && forward\n            ? forward(operation)\n            : Observable.of({\n                data: {},\n              });\n\n        const observerErrorHandler = observer.error.bind(observer);\n\n        const sub = obs.subscribe({\n          next: ({ data, errors }) => {\n            const context = operation.getContext();\n            //data is from the server and provides the root value to this GraphQL resolution\n            //when there is no resolver, the data is taken from the context\n            graphql(resolver, query, data, context, operation.variables)\n              .then(nextData => {\n                observer.next({\n                  data: nextData,\n                  errors,\n                });\n                observer.complete();\n              })\n              .catch(observerErrorHandler);\n          },\n          error: observerErrorHandler,\n        });\n\n        return () => {\n          if (sub) sub.unsubscribe();\n        };\n      });\n    }\n  }();\n};\n","import {\n  ApolloLink,\n  Observable,\n  Operation,\n  NextLink,\n  FetchResult,\n} from 'apollo-link';\nimport { GraphQLError, ExecutionResult } from 'graphql';\n\nexport interface ErrorResponse {\n  graphQLErrors?: GraphQLError[];\n  networkError?: Error;\n  response?: ExecutionResult;\n  operation: Operation;\n  forward: NextLink;\n}\n\nexport namespace ErrorLink {\n  /**\n   * Callback to be triggered when an error occurs within the link stack.\n   */\n  export interface ErrorHandler {\n    (error: ErrorResponse): Observable<FetchResult> | void;\n  }\n}\n\n// For backwards compatibility.\nexport import ErrorHandler = ErrorLink.ErrorHandler;\n\nexport const onError = (errorHandler: ErrorHandler): ApolloLink => {\n  return new ApolloLink((operation, forward) => {\n    return new Observable(observer => {\n      let sub;\n      let retriedSub;\n      let retriedResult;\n\n      try {\n        sub = forward(operation).subscribe({\n          next: result => {\n            if (result.errors) {\n              retriedResult = errorHandler({\n                graphQLErrors: result.errors,\n                response: result,\n                operation,\n                forward,\n              });\n\n              if (retriedResult) {\n                retriedSub = retriedResult.subscribe({\n                  next: observer.next.bind(observer),\n                  error: observer.error.bind(observer),\n                  complete: observer.complete.bind(observer),\n                });\n                return;\n              }\n            }\n            observer.next(result);\n          },\n          error: networkError => {\n            retriedResult = errorHandler({\n              operation,\n              networkError,\n              //Network errors can return GraphQL errors on for example a 403\n              graphQLErrors: networkError.result && networkError.result.errors,\n              forward,\n            });\n            if (retriedResult) {\n              retriedSub = retriedResult.subscribe({\n                next: observer.next.bind(observer),\n                error: observer.error.bind(observer),\n                complete: observer.complete.bind(observer),\n              });\n              return;\n            }\n            observer.error(networkError);\n          },\n          complete: () => {\n            // disable the previous sub from calling complete on observable\n            // if retry is in flight.\n            if (!retriedResult) {\n              observer.complete.bind(observer)();\n            }\n          },\n        });\n      } catch (e) {\n        errorHandler({ networkError: e, operation, forward });\n        observer.error(e);\n      }\n\n      return () => {\n        if (sub) sub.unsubscribe();\n        if (retriedSub) sub.unsubscribe();\n      };\n    });\n  });\n};\n\nexport class ErrorLink extends ApolloLink {\n  private link: ApolloLink;\n  constructor(errorHandler: ErrorLink.ErrorHandler) {\n    super();\n    this.link = onError(errorHandler);\n  }\n\n  public request(\n    operation: Operation,\n    forward: NextLink,\n  ): Observable<FetchResult> | null {\n    return this.link.request(operation, forward);\n  }\n}\n","/* necessary for backward compat */\r\nexport * from 'apollo-client';\r\nexport * from 'apollo-link';\r\nexport * from 'apollo-cache-inmemory';\r\n\r\nimport { Operation, ApolloLink, Observable } from 'apollo-link';\r\nimport { HttpLink } from 'apollo-link-http';\r\nimport { withClientState, ClientStateConfig } from 'apollo-link-state';\r\nimport { onError, ErrorLink } from 'apollo-link-error';\r\n\r\nimport { ApolloCache } from 'apollo-cache';\r\nimport { InMemoryCache, CacheResolverMap } from 'apollo-cache-inmemory';\r\nimport gql from 'graphql-tag';\r\nimport ApolloClient from 'apollo-client';\r\n\r\nexport { gql, InMemoryCache, HttpLink };\r\n\r\nexport interface PresetConfig {\r\n  request?: (operation: Operation) => Promise<void>;\r\n  uri?: string;\r\n  credentials?: string;\r\n  headers?: any;\r\n  fetch?: GlobalFetch['fetch'];\r\n  fetchOptions?: HttpLink.Options;\r\n  clientState?: ClientStateConfig;\r\n  onError?: ErrorLink.ErrorHandler;\r\n  cacheRedirects?: CacheResolverMap;\r\n  cache?: ApolloCache<any>;\r\n}\r\n\r\n// Yes, these are the exact same as the `PresetConfig` interface. We're\r\n// defining these again so they can be used to verify that valid config\r\n// options are being used in the `DefaultClient` constructor, for clients\r\n// that aren't using Typescript. This duplication is unfortunate, and at\r\n// some point can likely be adjusted so these items are inferred from\r\n// the `PresetConfig` interface using a Typescript transform at compilation\r\n// time. Unfortunately, TS transforms with rollup don't appear to be quite\r\n// working properly, so this will have to be re-visited at some point.\r\n// For now, when updating the properties of the `PresetConfig` interface,\r\n// please also update this constant.\r\nconst PRESET_CONFIG_KEYS = [\r\n  'request',\r\n  'uri',\r\n  'credentials',\r\n  'headers',\r\n  'fetch',\r\n  'fetchOptions',\r\n  'clientState',\r\n  'onError',\r\n  'cacheRedirects',\r\n  'cache',\r\n];\r\n\r\nexport default class DefaultClient<TCache> extends ApolloClient<TCache> {\r\n  constructor(config: PresetConfig = {}) {\r\n    if (config) {\r\n      const diff = Object.keys(config).filter(\r\n        key => PRESET_CONFIG_KEYS.indexOf(key) === -1,\r\n      );\r\n\r\n      if (diff.length > 0) {\r\n        console.warn(\r\n          'ApolloBoost was initialized with unsupported options: ' +\r\n            `${diff.join(' ')}`,\r\n        );\r\n      }\r\n    }\r\n\r\n    const {\r\n      request,\r\n      uri,\r\n      credentials,\r\n      headers,\r\n      fetch,\r\n      fetchOptions,\r\n      clientState,\r\n      cacheRedirects,\r\n      onError: errorCallback,\r\n    } = config;\r\n\r\n    let { cache } = config;\r\n\r\n    if (cache && cacheRedirects) {\r\n      throw new Error(\r\n        'Incompatible cache configuration. If providing `cache` then ' +\r\n          'configure the provided instance with `cacheRedirects` instead.',\r\n      );\r\n    }\r\n\r\n    if (!cache) {\r\n      cache = cacheRedirects\r\n        ? new InMemoryCache({ cacheRedirects })\r\n        : new InMemoryCache();\r\n    }\r\n\r\n    const stateLink = clientState\r\n      ? withClientState({ ...clientState, cache })\r\n      : false;\r\n\r\n    const errorLink = errorCallback\r\n      ? onError(errorCallback)\r\n      : onError(({ graphQLErrors, networkError }) => {\r\n          if (graphQLErrors) {\r\n            graphQLErrors.map(({ message, locations, path }) =>\r\n              // tslint:disable-next-line\r\n              console.log(\r\n                `[GraphQL error]: Message: ${message}, Location: ` +\r\n                  `${locations}, Path: ${path}`,\r\n              ),\r\n            );\r\n          }\r\n          if (networkError) {\r\n            // tslint:disable-next-line\r\n            console.log(`[Network error]: ${networkError}`);\r\n          }\r\n        });\r\n\r\n    const requestHandler = request\r\n      ? new ApolloLink(\r\n          (operation, forward) =>\r\n            new Observable(observer => {\r\n              let handle: any;\r\n              Promise.resolve(operation)\r\n                .then(oper => request(oper))\r\n                .then(() => {\r\n                  handle = forward(operation).subscribe({\r\n                    next: observer.next.bind(observer),\r\n                    error: observer.error.bind(observer),\r\n                    complete: observer.complete.bind(observer),\r\n                  });\r\n                })\r\n                .catch(observer.error.bind(observer));\r\n\r\n              return () => {\r\n                if (handle) {\r\n                  handle.unsubscribe();\r\n                }\r\n              };\r\n            }),\r\n        )\r\n      : false;\r\n\r\n    const httpLink = new HttpLink({\r\n      uri: uri || '/graphql',\r\n      fetch,\r\n      fetchOptions: fetchOptions || {},\r\n      credentials: credentials || 'same-origin',\r\n      headers: headers || {},\r\n    });\r\n\r\n    const link = ApolloLink.from([\r\n      errorLink,\r\n      requestHandler,\r\n      stateLink,\r\n      httpLink,\r\n    ].filter(x => !!x) as ApolloLink[]);\r\n\r\n    // super hacky, we will fix the types eventually\r\n    super({ cache, link } as any);\r\n  }\r\n}\r\n"],"names":["NetworkStatus","getOperationName","print","__extends","Observable","LinkObservable","FetchType","__assign","isEqual","maybeDeepFreeze","tryFunctionOrLogError","Deduplicator","assign","getDefaultValues","getMutationDefinition","graphQLResultHasError","hasDirectives","isProduction","getQueryDefinition","getOperationDefinition","removeConnectionDirectiveFromDocument","makePromise","toPromise","getKey","passthrough","toLink","ApolloLink","empty","from","split","isTerminating","concat","LinkError","execute","createOperation","transformOperation","validateOperation","getFragmentQueryDocument","isTest","warnOnceInDevelopment","createFragmentMap","getFragmentDefinitions","shouldInclude","isField","resultKeyNameFromField","isInlineFragment","toIdValue","isIdValue","storeKeyNameFromField","getMainDefinition","argumentsObjectFromField","getDirectiveInfoFromField","getStoreKeyName","isJsonValue","graphqlAnywhere","addTypenameToDocument","fromError","checkDocument","removeDirectivesFromDocument","graphql"],"mappings":"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"}