(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.Vaadin = global.Vaadin || {})));
}(this, (function (exports) { 'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  };

  var inherits = function (subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };

  var possibleConstructorReturn = function (self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  };

  var toConsumableArray = function (arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    } else {
      return Array.from(arr);
    }
  };

  function toArray$1(objectOrArray) {
    objectOrArray = objectOrArray || [];
    return Array.isArray(objectOrArray) ? objectOrArray : [objectOrArray];
  }

  function log(msg) {
    return '[Vaadin.Router] ' + msg;
  }

  var MODULE = 'module';
  var NOMODULE = 'nomodule';
  var bundleKeys = [MODULE, NOMODULE];

  function ensureBundle(src) {
    if (!src.match(/.+\.[m]?js$/)) {
      throw new Error(log('Unsupported type for bundle "' + src + '": .js or .mjs expected.'));
    }
  }

  function ensureRoute(route) {
    if (!route || !isString(route.path)) {
      throw new Error(log('Expected route config to be an object with a "path" string property, or an array of such objects'));
    }

    var bundle = route.bundle;

    var stringKeys = ['component', 'redirect', 'bundle'];
    if (!isFunction(route.action) && !Array.isArray(route.children) && !isFunction(route.children) && !isObject(bundle) && !stringKeys.some(function (key) {
      return isString(route[key]);
    })) {
      throw new Error(log('Expected route config "' + route.path + '" to include either "' + stringKeys.join('", "') + '" ' + 'or "action" function but none found.'));
    }

    if (bundle) {
      if (isString(bundle)) {
        ensureBundle(bundle);
      } else if (!bundleKeys.some(function (key) {
        return key in bundle;
      })) {
        throw new Error(log('Expected route bundle to include either "' + NOMODULE + '" or "' + MODULE + '" keys, or both'));
      } else {
        bundleKeys.forEach(function (key) {
          return key in bundle && ensureBundle(bundle[key]);
        });
      }
    }

    if (route.redirect) {
      ['bundle', 'component'].forEach(function (overriddenProp) {
        if (overriddenProp in route) {
          console.warn(log('Route config "' + route.path + '" has both "redirect" and "' + overriddenProp + '" properties, ' + ('and "redirect" will always override the latter. Did you mean to only use "' + overriddenProp + '"?')));
        }
      });
    }
  }

  function ensureRoutes(routes) {
    toArray$1(routes).forEach(function (route) {
      return ensureRoute(route);
    });
  }

  function loadScript(src, key) {
    var script = document.head.querySelector('script[src="' + src + '"][async]');
    if (!script) {
      script = document.createElement('script');
      script.setAttribute('src', src);
      if (key === MODULE) {
        script.setAttribute('type', MODULE);
      } else if (key === NOMODULE) {
        script.setAttribute(NOMODULE, '');
      }
      script.async = true;
    }
    return new Promise(function (resolve, reject) {
      script.onreadystatechange = script.onload = function (e) {
        script.__dynamicImportLoaded = true;
        resolve(e);
      };
      script.onerror = function (e) {
        if (script.parentNode) {
          script.parentNode.removeChild(script);
        }
        reject(e);
      };
      if (script.parentNode === null) {
        document.head.appendChild(script);
      } else if (script.__dynamicImportLoaded) {
        resolve();
      }
    });
  }

  function loadBundle(bundle) {
    if (isString(bundle)) {
      return loadScript(bundle);
    } else {
      return Promise.race(bundleKeys.filter(function (key) {
        return key in bundle;
      }).map(function (key) {
        return loadScript(bundle[key], key);
      }));
    }
  }

  function fireRouterEvent(type, detail) {
    window.dispatchEvent(new CustomEvent('vaadin-router-' + type, { detail: detail }));
  }

  function isObject(o) {
    // guard against null passing the typeof check
    return (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object' && !!o;
  }

  function isFunction(f) {
    return typeof f === 'function';
  }

  function isString(s) {
    return typeof s === 'string';
  }

  function getNotFoundError(context) {
    var error = new Error(log('Page not found (' + context.pathname + ')'));
    error.context = context;
    error.code = 404;
    return error;
  }

  /* istanbul ignore next: coverage is calculated in Chrome, this code is for IE */
  function getAnchorOrigin(anchor) {
    // IE11: on HTTP and HTTPS the default port is not included into
    // window.location.origin, so won't include it here either.
    var port = anchor.port;
    var protocol = anchor.protocol;
    var defaultHttp = protocol === 'http:' && port === '80';
    var defaultHttps = protocol === 'https:' && port === '443';
    var host = defaultHttp || defaultHttps ? anchor.hostname // does not include the port number (e.g. www.example.org)
    : anchor.host; // does include the port number (e.g. www.example.org:80)
    return protocol + '//' + host;
  }

  // The list of checks is not complete:
  //  - SVG support is missing
  //  - the 'rel' attribute is not considered
  function vaadinRouterGlobalClickHandler(event) {
    // ignore the click if the default action is prevented
    if (event.defaultPrevented) {
      return;
    }

    // ignore the click if not with the primary mouse button
    if (event.button !== 0) {
      return;
    }

    // ignore the click if a modifier key is pressed
    if (event.shiftKey || event.ctrlKey || event.altKey || event.metaKey) {
      return;
    }

    // find the <a> element that the click is at (or within)
    var anchor = event.target;
    var path = event.composedPath ? event.composedPath() : event.path || [];

    // FIXME(web-padawan): `Symbol.iterator` used by webcomponentsjs is broken for arrays
    // example to check: `for...of` loop here throws the "Not yet implemented" error
    for (var i = 0; i < path.length; i++) {
      var target = path[i];
      if (target.nodeName && target.nodeName.toLowerCase() === 'a') {
        anchor = target;
        break;
      }
    }

    while (anchor && anchor.nodeName.toLowerCase() !== 'a') {
      anchor = anchor.parentNode;
    }

    // ignore the click if not at an <a> element
    if (!anchor || anchor.nodeName.toLowerCase() !== 'a') {
      return;
    }

    // ignore the click if the <a> element has a non-default target
    if (anchor.target && anchor.target.toLowerCase() !== '_self') {
      return;
    }

    // ignore the click if the <a> element has the 'download' attribute
    if (anchor.hasAttribute('download')) {
      return;
    }

    // ignore the click if the target URL is a fragment on the current page
    if (anchor.pathname === window.location.pathname && anchor.hash !== '') {
      return;
    }

    // ignore the click if the target is external to the app
    // In IE11 HTMLAnchorElement does not have the `origin` property
    var origin = anchor.origin || getAnchorOrigin(anchor);
    if (origin !== window.location.origin) {
      return;
    }

    // if none of the above, convert the click into a navigation event
    event.preventDefault();
    fireRouterEvent('go', { pathname: anchor.pathname });
  }

  /**
   * A navigation trigger for Vaadin Router that translated clicks on `<a>` links
   * into Vaadin Router navigation events.
   *
   * Only regular clicks on in-app links are translated (primary mouse button, no
   * modifier keys, the target href is within the app's URL space).
   *
   * @memberOf Vaadin.Router.Triggers
   * @type {NavigationTrigger}
   */
  var CLICK = {
    activate: function activate() {
      window.document.addEventListener('click', vaadinRouterGlobalClickHandler);
    },
    inactivate: function inactivate() {
      window.document.removeEventListener('click', vaadinRouterGlobalClickHandler);
    }
  };

  // PopStateEvent constructor shim
  var isIE = /Trident/.test(navigator.userAgent);

  /* istanbul ignore next: coverage is calculated in Chrome, this code is for IE */
  if (isIE && !isFunction(window.PopStateEvent)) {
    window.PopStateEvent = function (inType, params) {
      params = params || {};
      var e = document.createEvent('Event');
      e.initEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable));
      e.state = params.state || null;
      return e;
    };
    window.PopStateEvent.prototype = window.Event.prototype;
  }

  function vaadinRouterGlobalPopstateHandler(event) {
    if (event.state === 'vaadin-router-ignore') {
      return;
    }
    fireRouterEvent('go', { pathname: window.location.pathname });
  }

  /**
   * A navigation trigger for Vaadin Router that translates popstate events into
   * Vaadin Router navigation events.
   *
   * @memberOf Vaadin.Router.Triggers
   * @type {NavigationTrigger}
   */
  var POPSTATE = {
    activate: function activate() {
      window.addEventListener('popstate', vaadinRouterGlobalPopstateHandler);
    },
    inactivate: function inactivate() {
      window.removeEventListener('popstate', vaadinRouterGlobalPopstateHandler);
    }
  };

  /**
   * Expose `pathToRegexp`.
   */
  var pathToRegexp_1 = pathToRegexp;
  var parse_1 = parse;
  var compile_1 = compile;
  var tokensToFunction_1 = tokensToFunction;
  var tokensToRegExp_1 = tokensToRegExp;

  /**
   * Default configs.
   */
  var DEFAULT_DELIMITER = '/';
  var DEFAULT_DELIMITERS = './';

  /**
   * The main path matching regexp utility.
   *
   * @type {RegExp}
   */
  var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?"]
  // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined]
  '(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?'].join('|'), 'g');

  /**
   * Parse a string for the raw tokens.
   *
   * @param  {string}  str
   * @param  {Object=} options
   * @return {!Array}
   */
  function parse(str, options) {
    var tokens = [];
    var key = 0;
    var index = 0;
    var path = '';
    var defaultDelimiter = options && options.delimiter || DEFAULT_DELIMITER;
    var delimiters = options && options.delimiters || DEFAULT_DELIMITERS;
    var pathEscaped = false;
    var res;

    while ((res = PATH_REGEXP.exec(str)) !== null) {
      var m = res[0];
      var escaped = res[1];
      var offset = res.index;
      path += str.slice(index, offset);
      index = offset + m.length;

      // Ignore already escaped sequences.
      if (escaped) {
        path += escaped[1];
        pathEscaped = true;
        continue;
      }

      var prev = '';
      var next = str[index];
      var name = res[2];
      var capture = res[3];
      var group = res[4];
      var modifier = res[5];

      if (!pathEscaped && path.length) {
        var k = path.length - 1;

        if (delimiters.indexOf(path[k]) > -1) {
          prev = path[k];
          path = path.slice(0, k);
        }
      }

      // Push the current path onto the tokens.
      if (path) {
        tokens.push(path);
        path = '';
        pathEscaped = false;
      }

      var partial = prev !== '' && next !== undefined && next !== prev;
      var repeat = modifier === '+' || modifier === '*';
      var optional = modifier === '?' || modifier === '*';
      var delimiter = prev || defaultDelimiter;
      var pattern = capture || group;

      tokens.push({
        name: name || key++,
        prefix: prev,
        delimiter: delimiter,
        optional: optional,
        repeat: repeat,
        partial: partial,
        pattern: pattern ? escapeGroup(pattern) : '[^' + escapeString(delimiter) + ']+?'
      });
    }

    // Push any remaining characters.
    if (path || index < str.length) {
      tokens.push(path + str.substr(index));
    }

    return tokens;
  }

  /**
   * Compile a string to a template function for the path.
   *
   * @param  {string}             str
   * @param  {Object=}            options
   * @return {!function(Object=, Object=)}
   */
  function compile(str, options) {
    return tokensToFunction(parse(str, options));
  }

  /**
   * Expose a method for transforming tokens into the path function.
   */
  function tokensToFunction(tokens) {
    // Compile all the tokens into regexps.
    var matches = new Array(tokens.length);

    // Compile all the patterns before compilation.
    for (var i = 0; i < tokens.length; i++) {
      if (_typeof(tokens[i]) === 'object') {
        matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');
      }
    }

    return function (data, options) {
      var path = '';
      var encode = options && options.encode || encodeURIComponent;

      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i];

        if (typeof token === 'string') {
          path += token;
          continue;
        }

        var value = data ? data[token.name] : undefined;
        var segment;

        if (Array.isArray(value)) {
          if (!token.repeat) {
            throw new TypeError('Expected "' + token.name + '" to not repeat, but got array');
          }

          if (value.length === 0) {
            if (token.optional) continue;

            throw new TypeError('Expected "' + token.name + '" to not be empty');
          }

          for (var j = 0; j < value.length; j++) {
            segment = encode(value[j], token);

            if (!matches[i].test(segment)) {
              throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '"');
            }

            path += (j === 0 ? token.prefix : token.delimiter) + segment;
          }

          continue;
        }

        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
          segment = encode(String(value), token);

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but got "' + segment + '"');
          }

          path += token.prefix + segment;
          continue;
        }

        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) path += token.prefix;

          continue;
        }

        throw new TypeError('Expected "' + token.name + '" to be ' + (token.repeat ? 'an array' : 'a string'));
      }

      return path;
    };
  }

  /**
   * Escape a regular expression string.
   *
   * @param  {string} str
   * @return {string}
   */
  function escapeString(str) {
    return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, '\\$1');
  }

  /**
   * Escape the capturing group by escaping special characters and meaning.
   *
   * @param  {string} group
   * @return {string}
   */
  function escapeGroup(group) {
    return group.replace(/([=!:$/()])/g, '\\$1');
  }

  /**
   * Get the flags for a regexp from the options.
   *
   * @param  {Object} options
   * @return {string}
   */
  function flags(options) {
    return options && options.sensitive ? '' : 'i';
  }

  /**
   * Pull out keys from a regexp.
   *
   * @param  {!RegExp} path
   * @param  {Array=}  keys
   * @return {!RegExp}
   */
  function regexpToRegexp(path, keys) {
    if (!keys) return path;

    // Use a negative lookahead to match only capturing groups.
    var groups = path.source.match(/\((?!\?)/g);

    if (groups) {
      for (var i = 0; i < groups.length; i++) {
        keys.push({
          name: i,
          prefix: null,
          delimiter: null,
          optional: false,
          repeat: false,
          partial: false,
          pattern: null
        });
      }
    }

    return path;
  }

  /**
   * Transform an array into a regexp.
   *
   * @param  {!Array}  path
   * @param  {Array=}  keys
   * @param  {Object=} options
   * @return {!RegExp}
   */
  function arrayToRegexp(path, keys, options) {
    var parts = [];

    for (var i = 0; i < path.length; i++) {
      parts.push(pathToRegexp(path[i], keys, options).source);
    }

    return new RegExp('(?:' + parts.join('|') + ')', flags(options));
  }

  /**
   * Create a path regexp from string input.
   *
   * @param  {string}  path
   * @param  {Array=}  keys
   * @param  {Object=} options
   * @return {!RegExp}
   */
  function stringToRegexp(path, keys, options) {
    return tokensToRegExp(parse(path, options), keys, options);
  }

  /**
   * Expose a function for taking tokens and returning a RegExp.
   *
   * @param  {!Array}  tokens
   * @param  {Array=}  keys
   * @param  {Object=} options
   * @return {!RegExp}
   */
  function tokensToRegExp(tokens, keys, options) {
    options = options || {};

    var strict = options.strict;
    var end = options.end !== false;
    var delimiter = escapeString(options.delimiter || DEFAULT_DELIMITER);
    var delimiters = options.delimiters || DEFAULT_DELIMITERS;
    var endsWith = [].concat(options.endsWith || []).map(escapeString).concat('$').join('|');
    var route = '';
    var isEndDelimited = tokens.length === 0;

    // Iterate over the tokens and create our regexp string.
    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        route += escapeString(token);
        isEndDelimited = i === tokens.length - 1 && delimiters.indexOf(token[token.length - 1]) > -1;
      } else {
        var prefix = escapeString(token.prefix);
        var capture = token.repeat ? '(?:' + token.pattern + ')(?:' + prefix + '(?:' + token.pattern + '))*' : token.pattern;

        if (keys) keys.push(token);

        if (token.optional) {
          if (token.partial) {
            route += prefix + '(' + capture + ')?';
          } else {
            route += '(?:' + prefix + '(' + capture + '))?';
          }
        } else {
          route += prefix + '(' + capture + ')';
        }
      }
    }

    if (end) {
      if (!strict) route += '(?:' + delimiter + ')?';

      route += endsWith === '$' ? '$' : '(?=' + endsWith + ')';
    } else {
      if (!strict) route += '(?:' + delimiter + '(?=' + endsWith + '))?';
      if (!isEndDelimited) route += '(?=' + delimiter + '|' + endsWith + ')';
    }

    return new RegExp('^' + route, flags(options));
  }

  /**
   * Normalize the given path string, returning a regular expression.
   *
   * An empty array can be passed in for the keys, which will hold the
   * placeholder key descriptions. For example, using `/user/:id`, `keys` will
   * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
   *
   * @param  {(string|RegExp|Array)} path
   * @param  {Array=}                keys
   * @param  {Object=}               options
   * @return {!RegExp}
   */
  function pathToRegexp(path, keys, options) {
    if (path instanceof RegExp) {
      return regexpToRegexp(path, keys);
    }

    if (Array.isArray(path)) {
      return arrayToRegexp( /** @type {!Array} */path, keys, options);
    }

    return stringToRegexp( /** @type {string} */path, keys, options);
  }
  pathToRegexp_1.parse = parse_1;
  pathToRegexp_1.compile = compile_1;
  pathToRegexp_1.tokensToFunction = tokensToFunction_1;
  pathToRegexp_1.tokensToRegExp = tokensToRegExp_1;

  /**
   * Universal Router (https://www.kriasoft.com/universal-router/)
   *
   * Copyright (c) 2015-present Kriasoft.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.txt file in the root directory of this source tree.
   */

  var hasOwnProperty = Object.prototype.hasOwnProperty;

  var cache = new Map();
  // see https://github.com/pillarjs/path-to-regexp/issues/148
  cache.set('|false', {
    keys: [],
    pattern: /(?:)/
  });

  function decodeParam(val) {
    try {
      return decodeURIComponent(val);
    } catch (err) {
      return val;
    }
  }

  function matchPath(routepath, path, exact, parentKeys, parentParams) {
    exact = !!exact;
    var cacheKey = routepath + '|' + exact;
    var regexp = cache.get(cacheKey);

    if (!regexp) {
      var keys = [];
      regexp = {
        keys: keys,
        pattern: pathToRegexp_1(routepath, keys, {
          end: exact,
          strict: routepath === ''
        })
      };
      cache.set(cacheKey, regexp);
    }

    var m = regexp.pattern.exec(path);
    if (!m) {
      return null;
    }

    var params = Object.assign({}, parentParams);

    for (var i = 1; i < m.length; i++) {
      var key = regexp.keys[i - 1];
      var prop = key.name;
      var value = m[i];
      if (value !== undefined || !hasOwnProperty.call(params, prop)) {
        if (key.repeat) {
          params[prop] = value ? value.split(key.delimiter).map(decodeParam) : [];
        } else {
          params[prop] = value ? decodeParam(value) : value;
        }
      }
    }

    return {
      path: m[0],
      keys: (parentKeys || []).concat(regexp.keys),
      params: params
    };
  }

  /**
   * Universal Router (https://www.kriasoft.com/universal-router/)
   *
   * Copyright (c) 2015-present Kriasoft.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.txt file in the root directory of this source tree.
   */

  /**
   * Traverses the routes tree and matches its nodes to the given pathname from
   * the root down to the leaves. Each match consumes a part of the pathname and
   * the matching process continues for as long as there is a matching child
   * route for the remaining part of the pathname.
   *
   * The returned value is a lazily evaluated iterator.
   *
   * The leading "/" in a route path matters only for the root of the routes
   * tree (or if all parent routes are ""). In all other cases a leading "/" in
   * a child route path has no significance.
   *
   * The trailing "/" in a _route path_ matters only for the leaves of the
   * routes tree. A leaf route with a trailing "/" matches only a pathname that
   * also has a trailing "/".
   *
   * The trailing "/" in a route path does not affect matching of child routes
   * in any way.
   *
   * The trailing "/" in a _pathname_ generally does not matter (except for
   * the case of leaf nodes described above).
   *
   * The "" and "/" routes have special treatment:
   *  1. as a single route
   *     the "" and "/" routes match only the "" and "/" pathnames respectively
   *  2. as a parent in the routes tree
   *     the "" route matches any pathname without consuming any part of it
   *     the "/" route matches any absolute pathname consuming its leading "/"
   *  3. as a leaf in the routes tree
   *     the "" and "/" routes match only if the entire pathname is consumed by
   *         the parent routes chain. In this case "" and "/" are equivalent.
   *  4. several directly nested "" or "/" routes
   *     - directly nested "" or "/" routes are 'squashed' (i.e. nesting two
   *       "/" routes does not require a double "/" in the pathname to match)
   *     - if there are only "" in the parent routes chain, no part of the
   *       pathname is consumed, and the leading "/" in the child routes' paths
   *       remains significant
   *
   * Side effect:
   *   - the routes tree { path: '' } matches only the '' pathname
   *   - the routes tree { path: '', children: [ { path: '' } ] } matches any
   *     pathname (for the tree root)
   *
   * Prefix matching can be enabled also by `children: true`.
   */
  function matchRoute(route, pathname, ignoreLeadingSlash, parentKeys, parentParams) {
    var match = void 0;
    var childMatches = void 0;
    var childIndex = 0;
    var routepath = route.path || '';
    if (routepath.charAt(0) === '/') {
      if (ignoreLeadingSlash) {
        routepath = routepath.substr(1);
      }
      ignoreLeadingSlash = true;
    }

    return {
      next: function next(routeToSkip) {
        if (route === routeToSkip) {
          return { done: true };
        }

        var children = route.__children = route.__children || route.children;

        if (!match) {
          match = matchPath(routepath, pathname, !children, parentKeys, parentParams);

          if (match) {
            return {
              done: false,
              value: {
                route: route,
                keys: match.keys,
                params: match.params,
                path: match.path
              }
            };
          }
        }

        if (match && children) {
          while (childIndex < children.length) {
            if (!childMatches) {
              var childRoute = children[childIndex];
              childRoute.parent = route;

              var matchedLength = match.path.length;
              if (matchedLength > 0 && pathname.charAt(matchedLength) === '/') {
                matchedLength += 1;
              }

              childMatches = matchRoute(childRoute, pathname.substr(matchedLength), ignoreLeadingSlash, match.keys, match.params);
            }

            var childMatch = childMatches.next(routeToSkip);
            if (!childMatch.done) {
              return {
                done: false,
                value: childMatch.value
              };
            }

            childMatches = null;
            childIndex++;
          }
        }

        return { done: true };
      }
    };
  }

  /**
   * Universal Router (https://www.kriasoft.com/universal-router/)
   *
   * Copyright (c) 2015-present Kriasoft.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.txt file in the root directory of this source tree.
   */

  function resolveRoute(context) {
    if (isFunction(context.route.action)) {
      return context.route.action(context);
    }
    return undefined;
  }

  /**
   * Universal Router (https://www.kriasoft.com/universal-router/)
   *
   * Copyright (c) 2015-present Kriasoft.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.txt file in the root directory of this source tree.
   */

  function isChildRoute(parentRoute, childRoute) {
    var route = childRoute;
    while (route) {
      route = route.parent;
      if (route === parentRoute) {
        return true;
      }
    }
    return false;
  }

  function generateErrorMessage(currentContext) {
    var errorMessage = 'Path \'' + currentContext.pathname + '\' is not properly resolved due to an error.';
    var routePath = (currentContext.route || {}).path;
    if (routePath) {
      errorMessage += ' Resolution had failed on route: \'' + routePath + '\'';
    }
    return errorMessage;
  }

  function addRouteToChain(context, match) {
    var route = match.route,
        path = match.path;

    function shouldDiscardOldChain(oldChain, route) {
      return !route.parent || !oldChain || !oldChain.length || oldChain[oldChain.length - 1].route !== route.parent;
    }

    if (route && !route.__synthetic) {
      var item = { path: path, route: route };
      if (shouldDiscardOldChain(context.chain, route)) {
        context.chain = [item];
      } else {
        context.chain.push(item);
      }
    }
  }

  /**
   * @memberof Vaadin
   */

  var Resolver = function () {
    function Resolver(routes) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      classCallCheck(this, Resolver);

      if (Object(routes) !== routes) {
        throw new TypeError('Invalid routes');
      }

      this.baseUrl = options.baseUrl || '';
      this.errorHandler = options.errorHandler;
      this.resolveRoute = options.resolveRoute || resolveRoute;
      this.context = Object.assign({ resolver: this }, options.context);
      this.root = Array.isArray(routes) ? { path: '', __children: routes, parent: null, __synthetic: true } : routes;
      this.root.parent = null;
    }

    /**
     * Returns the current list of routes (as a shallow copy). Adding / removing
     * routes to / from the returned array does not affect the routing config,
     * but modifying the route objects does.
     *
     * @return {!Array<!Route>}
     */


    createClass(Resolver, [{
      key: 'getRoutes',
      value: function getRoutes() {
        return [].concat(toConsumableArray(this.root.__children));
      }

      /**
       * Sets the routing config (replacing the existing one).
       *
       * @param {!Array<!Route>|!Route} routes a single route or an array of those
       *    (the array is shallow copied)
       */

    }, {
      key: 'setRoutes',
      value: function setRoutes(routes) {
        ensureRoutes(routes);
        var newRoutes = [].concat(toConsumableArray(toArray$1(routes)));
        this.root.__children = newRoutes;
      }

      /**
       * Appends one or several routes to the routing config and returns the
       * effective routing config after the operation.
       *
       * @param {!Array<!Route>|!Route} routes a single route or an array of those
       *    (the array is shallow copied)
       * @return {!Array<!Route>}
       * @protected
       */

    }, {
      key: 'addRoutes',
      value: function addRoutes(routes) {
        var _root$__children;

        ensureRoutes(routes);
        (_root$__children = this.root.__children).push.apply(_root$__children, toConsumableArray(toArray$1(routes)));
        return this.getRoutes();
      }

      /**
       * Removes all existing routes from the routing config.
       */

    }, {
      key: 'removeRoutes',
      value: function removeRoutes() {
        this.setRoutes([]);
      }

      /**
       * Asynchronously resolves the given pathname, i.e. finds all routes matching
       * the pathname and tries resolving them one after another in the order they
       * are listed in the routes config until the first non-null result.
       *
       * Returns a promise that is fulfilled with the return value of an object that consists of the first
       * route handler result that returns something other than `null` or `undefined` and context used to get this result.
       *
       * If no route handlers return a non-null result, or if no route matches the
       * given pathname the returned promise is rejected with a 'page not found'
       * `Error`.
       *
       * @param {!string|!{pathname: !string}} pathnameOrContext the pathname to
       *    resolve or a context object with a `pathname` property and other
       *    properties to pass to the route resolver functions.
       * @return {!Promise<any>}
       */

    }, {
      key: 'resolve',
      value: function resolve(pathnameOrContext) {
        var _this = this;

        var context = Object.assign({}, this.context, isString(pathnameOrContext) ? { pathname: pathnameOrContext } : pathnameOrContext);
        var match = matchRoute(this.root, context.pathname.substr(this.baseUrl.length));
        var resolve = this.resolveRoute;
        var matches = null;
        var nextMatches = null;
        var currentContext = context;

        function next(resume) {
          var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : matches.value.route;
          var prevResult = arguments[2];

          var routeToSkip = prevResult === null && matches.value.route;
          matches = nextMatches || match.next(routeToSkip);
          nextMatches = null;

          if (!resume) {
            if (matches.done || !isChildRoute(parent, matches.value.route)) {
              nextMatches = matches;
              return Promise.resolve(null);
            }
          }

          if (matches.done) {
            return Promise.reject(getNotFoundError(context));
          }

          addRouteToChain(context, matches.value);
          currentContext = Object.assign({}, context, matches.value);

          return Promise.resolve(resolve(currentContext)).then(function (resolution) {
            if (resolution !== null && resolution !== undefined) {
              currentContext.result = resolution.result || resolution;
              return currentContext;
            }
            return next(resume, parent, resolution);
          });
        }

        context.next = next;

        return Promise.resolve().then(function () {
          return next(true, _this.root);
        }).catch(function (error) {
          var errorMessage = generateErrorMessage(currentContext);
          if (!error) {
            error = new Error(errorMessage);
          } else {
            console.warn(errorMessage);
          }
          error.context = error.context || currentContext;
          // DOMException has its own code which is read-only
          if (!(error instanceof DOMException)) {
            error.code = error.code || 500;
          }
          if (_this.errorHandler) {
            currentContext.result = _this.errorHandler(error);
            return currentContext;
          }
          throw error;
        });
      }
    }]);
    return Resolver;
  }();

  Resolver.pathToRegexp = pathToRegexp_1;

  /**
   * @typedef NavigationTrigger
   * @type {object}
   * @property {function()} activate
   * @property {function()} inactivate
   */

  /** @type {Array<NavigationTrigger>} */
  var triggers = [];

  function setNavigationTriggers(newTriggers) {
    triggers.forEach(function (trigger) {
      return trigger.inactivate();
    });

    newTriggers.forEach(function (trigger) {
      return trigger.activate();
    });

    triggers = newTriggers;
  }

  var willAnimate = function willAnimate(elem) {
    var name = getComputedStyle(elem).getPropertyValue('animation-name');
    return name && name !== 'none';
  };

  var waitForAnimation = function waitForAnimation(elem, cb) {
    var listener = function listener() {
      elem.removeEventListener('animationend', listener);
      cb();
    };
    elem.addEventListener('animationend', listener);
  };

  function animate(elem, className) {
    elem.classList.add(className);

    return new Promise(function (resolve) {
      if (willAnimate(elem)) {
        var rect = elem.getBoundingClientRect();
        var size = 'height: ' + (rect.bottom - rect.top) + 'px; width: ' + (rect.right - rect.left) + 'px';
        elem.setAttribute('style', 'position: absolute; ' + size);
        waitForAnimation(elem, function () {
          elem.classList.remove(className);
          elem.removeAttribute('style');
          resolve();
        });
      } else {
        elem.classList.remove(className);
        resolve();
      }
    });
  }

  var MAX_REDIRECT_COUNT = 256;

  function isResultNotEmpty(result) {
    return result !== null && result !== undefined;
  }

  function copyContextWithoutNext(context) {
    var copy = Object.assign({}, context);
    delete copy.next;
    return copy;
  }

  function createLocation(_ref, route) {
    var _ref$pathname = _ref.pathname,
        pathname = _ref$pathname === undefined ? '' : _ref$pathname,
        _ref$chain = _ref.chain,
        chain = _ref$chain === undefined ? [] : _ref$chain,
        _ref$params = _ref.params,
        params = _ref$params === undefined ? {} : _ref$params,
        redirectFrom = _ref.redirectFrom;

    return {
      pathname: pathname,
      routes: chain.map(function (item) {
        return item.route;
      }),
      route: !route && chain.length && chain[chain.length - 1].route || route,
      params: params,
      redirectFrom: redirectFrom
    };
  }

  function createRedirect(context, pathname) {
    var params = Object.assign({}, context.params);
    return {
      redirect: {
        pathname: pathname,
        from: context.pathname,
        params: params
      }
    };
  }

  function renderComponent(context, component) {
    var element = document.createElement(component);
    element.location = createLocation(context);
    var index = context.chain.map(function (item) {
      return item.route;
    }).indexOf(context.route);
    context.chain[index].element = element;
    return element;
  }

  function runCallbackIfPossible(callback, args, thisArg) {
    if (isFunction(callback)) {
      return callback.apply(thisArg, args);
    }
  }

  function amend(amendmentFunction, args, element) {
    return function (amendmentResult) {
      if (amendmentResult && (amendmentResult.cancel || amendmentResult.redirect)) {
        return amendmentResult;
      }

      if (element) {
        return runCallbackIfPossible(element[amendmentFunction], args, element);
      }
    };
  }

  function processNewChildren(newChildren, route) {
    if (!Array.isArray(newChildren) && !isObject(newChildren)) {
      throw new Error(log('Incorrect "children" value for the route ' + route.path + ': expected array or object, but got ' + newChildren));
    }

    route.__children = [];
    var childRoutes = toArray$1(newChildren);
    for (var i = 0; i < childRoutes.length; i++) {
      ensureRoute(childRoutes[i]);
      route.__children.push(childRoutes[i]);
    }
  }

  function removeDomNodes(nodes) {
    if (nodes && nodes.length) {
      var parent = nodes[0].parentNode;
      for (var i = 0; i < nodes.length; i++) {
        parent.removeChild(nodes[i]);
      }
    }
  }

  function getMatchedPath(chain) {
    return chain.map(function (item) {
      return item.path;
    }).reduce(function (prev, path) {
      if (path.length) {
        return prev + (prev.charAt(prev.length - 1) === '/' ? '' : '/') + path;
      }
      return prev;
    });
  }

  /**
   * A simple client-side router for single-page applications. It uses
   * express-style middleware and has a first-class support for Web Components and
   * lazy-loading. Works great in Polymer and non-Polymer apps.
   *
   * Use `new Router(outlet)` to create a new Router instance. The `outlet` parameter is a reference to the DOM node
   * to render the content into. The Router instance is automatically subscribed to navigation events on `window`.
   *
   * See [Live Examples](#/classes/Vaadin.Router/demos/demo/index.html) for the detailed usage demo and code snippets.
   *
   * See also detailed API docs for the following methods, for the advanced usage:
   *
   * * [setOutlet](#/classes/Vaadin.Router#method-setOutlet) – should be used to configure the outlet.
   * * [setTriggers](#/classes/Vaadin.Router#method-setTriggers) – should be used to configure the navigation events.
   * * [setRoutes](#/classes/Vaadin.Router#method-setRoutes) – should be used to configure the routes.
   *
   * Only `setRoutes` has to be called manually, others are automatically invoked when creating a new instance.
   *
   * @memberof Vaadin
   * @extends Vaadin.Resolver
   * @demo demo/index.html
   * @summary JavaScript class that renders different DOM content depending on
   *    a given path. It can re-render when triggered or automatically on
   *    'popstate' and / or 'click' events.
   */
  var Router = function (_Resolver) {
    inherits(Router, _Resolver);

    /**
     * Creates a new Router instance with a given outlet, and
     * automatically subscribes it to navigation events on the `window`.
     * Using a constructor argument or a setter for outlet is equivalent:
     *
     * ```
     * const router = new Vaadin.Router();
     * router.setOutlet(outlet);
     * ```
     * @param {?Node} outlet
     * @param {?RouterOptions} options
     */
    function Router(outlet, options) {
      classCallCheck(this, Router);

      var _this = possibleConstructorReturn(this, (Router.__proto__ || Object.getPrototypeOf(Router)).call(this, [], Object.assign({}, options)));

      _this.resolveRoute = function (context) {
        return _this.__resolveRoute(context);
      };

      var triggers = Router.NavigationTrigger;
      Router.setTriggers.apply(Router, Object.keys(triggers).map(function (key) {
        return triggers[key];
      }));

      /**
       * A promise that is settled after the current render cycle completes. If
       * there is no render cycle in progress the promise is immediately settled
       * with the last render cycle result.
       *
       * @public
       * @type {!Promise<!Vaadin.Router.Location>}
       */
      _this.ready;
      _this.ready = Promise.resolve(outlet);

      /**
       * Contains read-only information about the current router location:
       * pathname, active routes, parameters. See the
       * [Location type declaration](#/classes/Vaadin.Router.Location)
       * for more details.
       *
       * @public
       * @type {!Vaadin.Router.Location}
       */
      _this.location;
      _this.location = createLocation({});

      _this.__lastStartedRenderId = 0;
      _this.__navigationEventHandler = _this.__onNavigationEvent.bind(_this);
      _this.setOutlet(outlet);
      _this.subscribe();
      return _this;
    }

    createClass(Router, [{
      key: '__resolveRoute',
      value: function __resolveRoute(context) {
        var route = context.route;

        var commands = {
          redirect: function redirect(path) {
            return createRedirect(context, path);
          },
          component: function component(_component) {
            return renderComponent(context, _component);
          }
        };
        var actionResult = runCallbackIfPossible(route.action, [context, commands], route);
        if (isResultNotEmpty(actionResult)) {
          return actionResult;
        }

        if (isString(route.redirect)) {
          return commands.redirect(route.redirect);
        }

        var callbacks = Promise.resolve();

        if (route.bundle) {
          callbacks = callbacks.then(function () {
            return loadBundle(route.bundle);
          }).catch(function () {
            throw new Error(log('Bundle not found: ' + route.bundle + '. Check if the file name is correct'));
          });
        }

        if (isFunction(route.children)) {
          callbacks = callbacks.then(function () {
            return route.children(copyContextWithoutNext(context));
          }).then(function (children) {
            // The route.children() callback might have re-written the
            // route.children property instead of returning a value
            if (!isResultNotEmpty(children) && !isFunction(route.children)) {
              children = route.children;
            }
            processNewChildren(children, route);
          });
        }

        return callbacks.then(function () {
          if (isString(route.component)) {
            return commands.component(route.component);
          }
        });
      }

      /**
       * Sets the router outlet (the DOM node where the content for the current
       * route is inserted). Any content pre-existing in the router outlet is
       * removed at the end of each render pass.
       *
       * NOTE: this method is automatically invoked first time when creating a new Router instance.
       *
       * @param {?Node} outlet the DOM node where the content for the current route
       *     is inserted.
       */

    }, {
      key: 'setOutlet',
      value: function setOutlet(outlet) {
        if (outlet) {
          this.__ensureOutlet(outlet);
        }
        this.__outlet = outlet;
      }

      /**
       * Returns the current router outlet. The initial value is `undefined`.
       *
       * @return {?Node} the current router outlet (or `undefined`)
       */

    }, {
      key: 'getOutlet',
      value: function getOutlet() {
        return this.__outlet;
      }

      /**
       * Sets the routing config (replacing the existing one) and triggers a
       * navigation event so that the router outlet is refreshed according to the
       * current `window.location` and the new routing config.
       *
       * Each route object may have the following properties, listed here in the processing order:
       * * `path` – the route path (relative to the parent route if any) in the
       * [express.js syntax](https://expressjs.com/en/guide/routing.html#route-paths").
       *
       * * `action` – the action that is executed before the route is resolved.
       * The value for this property should be a function, accepting a `context` parameter described below.
       * If present, this function is always invoked first, disregarding of the other properties' presence.
       * If the action returns a non-empty result, current route resolution is finished and other route config properties are ignored.
       * See also **Route Actions** section in [Live Examples](#/classes/Vaadin.Router/demos/demo/index.html).
       *
       * * `redirect` – other route's path to redirect to. Passes all route parameters to the redirect target.
       * The target route should also be defined.
       * See also **Redirects** section in [Live Examples](#/classes/Vaadin.Router/demos/demo/index.html).
       *
       * * `bundle` – string containing the path to `.js` or `.mjs` bundle to load before resolving the route,
       * or the object with "module" and "nomodule" keys referring to different bundles.
       * Each bundle is only loaded once. If "module" and "nomodule" are set, only one bundle is loaded,
       * depending on whether the browser supports ES modules or not.
       * The property is ignored when either an `action` returns the result or `redirect` property is present.
       * Any error, e.g. 404 while loading bundle will cause route resolution to throw.
       * See also **Code Splitting** section in [Live Examples](#/classes/Vaadin.Router/demos/demo/index.html).
       *
       * * `children` – an array of nested routes or a function that provides this
       * array at the render time. The function can be synchronous or asynchronous:
       * in the latter case the render is delayed until the returned promise is
       * resolved. The `children` function is executed every time when this route is
       * being rendered. This allows for dynamic route structures (e.g. backend-defined),
       * but it might have a performance impact as well. In order to avoid calling
       * the function on subsequent renders, you can override the `children` property
       * of the route object and save the calculated array there
       * (via `context.route.children = [ route1, route2, ...];`).
       * Parent routes are fully resolved before resolving the children. Children
       * 'path' values are relative to the parent ones.
       *
       * * `component` – the tag name of the Web Component to resolve the route to.
       * The property is ignored when either an `action` returns the result or `redirect` property is present.
       * If route contains the `component` property (or an action that return a component)
       * and its child route also contains the `component` property, child route's component
       * will be rendered as a light dom child of a parent component.
       *
       * For any route function (`action`, `children`) defined, the corresponding `route` object is available inside the callback
       * through the `this` reference. If you need to access it, make sure you define the callback as a non-arrow function
       * because arrow functions do not have their own `this` reference.
       *
       * `context` object that is passed to `action` function holds the following properties:
       * * `context.pathname` – string with the pathname being resolved
       *
       * * `context.params` – object with route parameters
       *
       * * `context.route` – object that holds the route that is currently being rendered.
       *
       * * `context.next()` – function for asynchronously getting the next route contents from the resolution chain (if any)
       *
       * * `context.redirect(path)` – function that creates a redirect data for the path specified.
       *
       * * `context.component(component)` – function that creates a new HTMLElement with current context
       *
       * @param {!Array<!Object>|!Object} routes a single route or an array of those
       */

    }, {
      key: 'setRoutes',
      value: function setRoutes(routes) {
        get(Router.prototype.__proto__ || Object.getPrototypeOf(Router.prototype), 'setRoutes', this).call(this, routes);
        this.__onNavigationEvent();
      }

      /**
       * Asynchronously resolves the given pathname and renders the resolved route
       * component into the router outlet. If no router outlet is set at the time of
       * calling this method, or at the time when the route resolution is completed,
       * a `TypeError` is thrown.
       *
       * Returns a promise that is fulfilled with the router outlet DOM Node after
       * the route component is created and inserted into the router outlet, or
       * rejected if no route matches the given path.
       *
       * If another render pass is started before the previous one is completed, the
       * result of the previous render pass is ignored.
       *
       * @param {!string|!{pathname: !string}} pathnameOrContext the pathname to
       *    render or a context object with a `pathname` property and other
       *    properties to pass to the resolver.
       * @return {!Promise<!Node>}
       */

    }, {
      key: 'render',
      value: function render(pathnameOrContext, shouldUpdateHistory) {
        var _this2 = this;

        var renderId = ++this.__lastStartedRenderId;
        var pathname = pathnameOrContext.pathname || pathnameOrContext;

        // Find the first route that resolves to a non-empty result
        this.ready = this.resolve(pathnameOrContext)

        // Process the result of this.resolve() and handle all special commands:
        // (redirect / prevent / component). If the result is a 'component',
        // then go deeper and build the entire chain of nested components matching
        // the pathname. Also call all 'on before' callbacks along the way.
        .then(function (context) {
          return _this2.__fullyResolveChain(context);
        }).then(function (context) {
          if (renderId === _this2.__lastStartedRenderId) {
            var previousContext = _this2.__previousContext;

            // Check if the render was prevented and make an early return in that case
            if (context === previousContext) {
              return _this2.location;
            }

            if (shouldUpdateHistory) {
              _this2.__updateBrowserHistory(context.pathname, context.redirectFrom);
            }

            _this2.__addAppearingContent(context, previousContext);
            var animationDone = _this2.__animateIfNeeded(context);

            _this2.__runOnAfterEnterCallbacks(context);
            _this2.__runOnAfterLeaveCallbacks(context, previousContext);

            return animationDone.then(function () {
              if (renderId === _this2.__lastStartedRenderId) {
                // If there is another render pass started after this one,
                // the 'disappearing content' would be removed when the other
                // render pass calls `this.__addAppearingContent()`
                _this2.__removeDisappearingContent();

                _this2.__previousContext = context;
                _this2.location = createLocation(context);
                fireRouterEvent('location-changed', { router: _this2, location: _this2.location });
                return _this2.location;
              }
            });
          }
        }).catch(function (error) {
          if (renderId === _this2.__lastStartedRenderId) {
            if (shouldUpdateHistory) {
              _this2.__updateBrowserHistory(pathname);
            }
            removeDomNodes(_this2.__outlet && _this2.__outlet.children);
            _this2.location = createLocation({ pathname: pathname });
            fireRouterEvent('error', { router: _this2, error: error, pathname: pathname });
            throw error;
          }
        });
        return this.ready;
      }
    }, {
      key: '__fullyResolveChain',
      value: function __fullyResolveChain(originalContext) {
        var _this3 = this;

        var currentContext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : originalContext;

        return this.__amendWithResolutionResult(currentContext).then(function (amendedContext) {
          var initialContext = amendedContext !== currentContext ? amendedContext : originalContext;
          return amendedContext.next().then(function (nextContext) {
            if (nextContext === null) {
              if (amendedContext.pathname !== getMatchedPath(amendedContext.chain)) {
                throw getNotFoundError(initialContext);
              }
            }
            return nextContext ? _this3.__fullyResolveChain(initialContext, nextContext) : _this3.__amendWithOnBeforeCallbacks(initialContext);
          });
        });
      }
    }, {
      key: '__amendWithResolutionResult',
      value: function __amendWithResolutionResult(context) {
        var _this4 = this;

        var result = context.result;
        if (result instanceof HTMLElement) {
          return Promise.resolve(context);
        } else if (result.redirect) {
          return this.__redirect(result.redirect, context.__redirectCount).then(function (context) {
            return _this4.__amendWithResolutionResult(context);
          });
        } else if (result instanceof Error) {
          return Promise.reject(result);
        } else {
          return Promise.reject(new Error(log('Invalid route resolution result for path "' + context.pathname + '". ' + ('Expected redirect object or HTML element, but got: "' + result + '". ') + 'Double check the action return value for the route.')));
        }
      }
    }, {
      key: '__amendWithOnBeforeCallbacks',
      value: function __amendWithOnBeforeCallbacks(contextWithFullChain) {
        var _this5 = this;

        return this.__runOnBeforeCallbacks(contextWithFullChain).then(function (amendedContext) {
          if (amendedContext === _this5.__previousContext || amendedContext === contextWithFullChain) {
            return amendedContext;
          }
          return _this5.__fullyResolveChain(amendedContext);
        });
      }
    }, {
      key: '__runOnBeforeCallbacks',
      value: function __runOnBeforeCallbacks(newContext) {
        var _this6 = this;

        var previousContext = this.__previousContext || {};
        var previousChain = previousContext.chain || [];
        var newChain = newContext.chain;

        var callbacks = Promise.resolve();
        var prevent = function prevent() {
          return { cancel: true };
        };
        var redirect = function redirect(pathname) {
          return createRedirect(newContext, pathname);
        };

        newContext.__divergedChainIndex = 0;
        if (previousChain.length) {
          for (var i = 0; i < Math.min(previousChain.length, newChain.length); i = ++newContext.__divergedChainIndex) {
            if (previousChain[i].route !== newChain[i].route || previousChain[i].path !== newChain[i].path) {
              break;
            }
          }

          for (var _i = previousChain.length - 1; _i >= newContext.__divergedChainIndex; _i--) {
            var location = createLocation(newContext);
            callbacks = callbacks.then(amend('onBeforeLeave', [location, { prevent: prevent }, this], previousChain[_i].element)).then(function (result) {
              if (!(result || {}).redirect) {
                return result;
              }
            });
          }
        }

        for (var _i2 = newContext.__divergedChainIndex; _i2 < newChain.length; _i2++) {
          var _location = createLocation(newContext, newChain[_i2].route);
          callbacks = callbacks.then(amend('onBeforeEnter', [_location, { prevent: prevent, redirect: redirect }, this], newChain[_i2].element));
        }

        return callbacks.then(function (amendmentResult) {
          if (amendmentResult) {
            if (amendmentResult.cancel) {
              return _this6.__previousContext;
            }
            if (amendmentResult.redirect) {
              return _this6.__redirect(amendmentResult.redirect, newContext.__redirectCount);
            }
          }
          return newContext;
        });
      }
    }, {
      key: '__redirect',
      value: function __redirect(redirectData, counter) {
        if (counter > MAX_REDIRECT_COUNT) {
          throw new Error(log('Too many redirects when rendering ' + redirectData.from));
        }

        return this.resolve({
          pathname: Router.pathToRegexp.compile(redirectData.pathname)(redirectData.params),
          redirectFrom: redirectData.from,
          __redirectCount: (counter || 0) + 1
        });
      }
    }, {
      key: '__ensureOutlet',
      value: function __ensureOutlet() {
        var outlet = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.__outlet;

        if (!(outlet instanceof Node)) {
          throw new TypeError(log('Expected router outlet to be a valid DOM Node (but got ' + outlet + ')'));
        }
      }
    }, {
      key: '__updateBrowserHistory',
      value: function __updateBrowserHistory(pathname, replace) {
        if (window.location.pathname !== pathname) {
          var changeState = replace ? 'replaceState' : 'pushState';
          window.history[changeState](null, document.title, pathname);
          window.dispatchEvent(new PopStateEvent('popstate', { state: 'vaadin-router-ignore' }));
        }
      }
    }, {
      key: '__addAppearingContent',
      value: function __addAppearingContent(context, previousContext) {
        this.__ensureOutlet();

        // If the previous 'entering' animation has not completed yet,
        // stop it and remove that content from the DOM before adding new one.
        this.__removeAppearingContent();

        // Find the deepest common parent between the last and the new component
        // chains. Update references for the unchanged elements in the new chain
        var deepestCommonParent = this.__outlet;
        for (var i = 0; i < context.__divergedChainIndex; i++) {
          var unchangedElement = previousContext && previousContext.chain[i].element;
          if (unchangedElement) {
            if (unchangedElement.parentNode === deepestCommonParent) {
              context.chain[i].element = unchangedElement;
              deepestCommonParent = unchangedElement;
            } else {
              break;
            }
          }
        }

        // Keep two lists of DOM elements:
        //  - those that should be removed once the transition animation is over
        //  - and those that should remain
        this.__disappearingContent = Array.from(deepestCommonParent.children);
        this.__appearingContent = [];

        // Add new elements (starting after the deepest common parent) to the DOM.
        // That way only the components that are actually different between the two
        // locations are added to the DOM (and those that are common remain in the
        // DOM without first removing and then adding them again).
        var parentElement = deepestCommonParent;
        for (var _i3 = context.__divergedChainIndex; _i3 < context.chain.length; _i3++) {
          var elementToAdd = context.chain[_i3].element;
          if (elementToAdd) {
            parentElement.appendChild(elementToAdd);
            if (parentElement === deepestCommonParent) {
              this.__appearingContent.push(elementToAdd);
            }
            parentElement = elementToAdd;
          }
        }
      }
    }, {
      key: '__removeDisappearingContent',
      value: function __removeDisappearingContent() {
        if (this.__disappearingContent) {
          removeDomNodes(this.__disappearingContent);
        }
        this.__disappearingContent = null;
        this.__appearingContent = null;
      }
    }, {
      key: '__removeAppearingContent',
      value: function __removeAppearingContent() {
        if (this.__disappearingContent && this.__appearingContent) {
          removeDomNodes(this.__appearingContent);
          this.__disappearingContent = null;
          this.__appearingContent = null;
        }
      }
    }, {
      key: '__runOnAfterLeaveCallbacks',
      value: function __runOnAfterLeaveCallbacks(currentContext, targetContext) {
        if (!targetContext) {
          return;
        }

        // REVERSE iteration: from Z to A
        for (var i = targetContext.chain.length - 1; i >= currentContext.__divergedChainIndex; i--) {
          var currentComponent = targetContext.chain[i].element;
          if (!currentComponent) {
            continue;
          }
          try {
            var location = createLocation(currentContext);
            runCallbackIfPossible(currentComponent.onAfterLeave, [location, {}, targetContext.resolver], currentComponent);
          } finally {
            removeDomNodes(currentComponent.children);
          }
        }
      }
    }, {
      key: '__runOnAfterEnterCallbacks',
      value: function __runOnAfterEnterCallbacks(currentContext) {
        // forward iteration: from A to Z
        for (var i = currentContext.__divergedChainIndex; i < currentContext.chain.length; i++) {
          var currentComponent = currentContext.chain[i].element || {};
          var location = createLocation(currentContext, currentContext.chain[i].route);
          runCallbackIfPossible(currentComponent.onAfterEnter, [location, {}, currentContext.resolver], currentComponent);
        }
      }
    }, {
      key: '__animateIfNeeded',
      value: function __animateIfNeeded(context) {
        var from = (this.__disappearingContent || [])[0];
        var to = (this.__appearingContent || [])[0];
        var promises = [];

        var chain = context.chain;
        var config = void 0;
        for (var i = chain.length; i > 0; i--) {
          if (chain[i - 1].route.animate) {
            config = chain[i - 1].route.animate;
            break;
          }
        }

        if (from && to && config) {
          var leave = isObject(config) && config.leave || 'leaving';
          var enter = isObject(config) && config.enter || 'entering';
          promises.push(animate(from, leave));
          promises.push(animate(to, enter));
        }

        return Promise.all(promises).then(function () {
          return context;
        });
      }

      /**
       * Subscribes this instance to navigation events on the `window`.
       *
       * NOTE: beware of resource leaks. For as long as a router instance is
       * subscribed to navigation events, it won't be garbage collected.
       */

    }, {
      key: 'subscribe',
      value: function subscribe() {
        window.addEventListener('vaadin-router-go', this.__navigationEventHandler);
      }

      /**
       * Removes the subscription to navigation events created in the `subscribe()`
       * method.
       */

    }, {
      key: 'unsubscribe',
      value: function unsubscribe() {
        window.removeEventListener('vaadin-router-go', this.__navigationEventHandler);
      }
    }, {
      key: '__onNavigationEvent',
      value: function __onNavigationEvent(event) {
        var pathname = event ? event.detail.pathname : window.location.pathname;
        this.render(pathname, true);
      }

      /**
       * Configures what triggers Vaadin.Router navigation events:
       *  - `POPSTATE`: popstate events on the current `window`
       *  - `CLICK`: click events on `<a>` links leading to the current page
       *
       * This method is invoked with the pre-configured values when creating a new Router instance.
       * By default, both `POPSTATE` and `CLICK` are enabled. This setup is expected to cover most of the use cases.
       *
       * See the `router-config.js` for the default navigation triggers config. Based on it, you can
       * create the own one and only import the triggers you need, instead of pulling in all the code,
       * e.g. if you want to handle `click` differently.
       *
       * See also **Navigation Triggers** section in [Live Examples](#/classes/Vaadin.Router/demos/demo/index.html).
       *
       * @param {...NavigationTrigger} triggers
       */

    }], [{
      key: 'setTriggers',
      value: function setTriggers() {
        for (var _len = arguments.length, triggers = Array(_len), _key = 0; _key < _len; _key++) {
          triggers[_key] = arguments[_key];
        }

        setNavigationTriggers(triggers);
      }

      /**
       * Triggers navigation to a new path and returns without waiting until the
       * navigation is complete.
       *
       * @param {!string} pathname a new in-app path
       */

    }, {
      key: 'go',
      value: function go(pathname) {
        fireRouterEvent('go', { pathname: pathname });
      }
    }]);
    return Router;
  }(Resolver);

  Router.NavigationTrigger = { POPSTATE: POPSTATE, CLICK: CLICK };

  exports.Router = Router;
  exports.Resolver = Resolver;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=vaadin-router.umd.js.map
