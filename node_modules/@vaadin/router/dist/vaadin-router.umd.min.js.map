{"version":3,"sources":["../src/utils.js","../src/triggers/click.js","../src/triggers/popstate.js","../node_modules/path-to-regexp/index.js","../src/resolver/matchPath.js","../src/resolver/matchRoute.js","../src/resolver/resolveRoute.js","../src/resolver/resolver.js","../src/triggers/setNavigationTriggers.js","../src/transitions/animate.js","../src/router.js","../src/router-config.js"],"names":["toArray","objectOrArray","Array","isArray","log","msg","MODULE","NOMODULE","bundleKeys","ensureBundle","src","match","Error","ensureRoute","route","isString","path","bundle","stringKeys","isFunction","action","children","isObject","some","key","join","forEach","redirect","overriddenProp","console","warn","ensureRoutes","routes","loadScript","script","document","head","querySelector","createElement","setAttribute","async","Promise","resolve","reject","onreadystatechange","onload","e","__dynamicImportLoaded","onerror","parentNode","removeChild","appendChild","fireRouterEvent","type","detail","window","dispatchEvent","CustomEvent","o","_typeof","f","s","getNotFoundError","context","error","pathname","code","vaadinRouterGlobalClickHandler","event","defaultPrevented","button","shiftKey","ctrlKey","altKey","metaKey","anchor","target","composedPath","i","length","nodeName","toLowerCase","hasAttribute","location","hash","origin","port","protocol","hostname","host","getAnchorOrigin","preventDefault","CLICK","activate","addEventListener","inactivate","removeEventListener","vaadinRouterGlobalPopstateHandler","state","test","navigator","userAgent","PopStateEvent","inType","params","createEvent","initEvent","Boolean","bubbles","cancelable","prototype","Event","POPSTATE","pathToRegexp_1","pathToRegexp","parse_1","parse","compile_1","str","options","tokensToFunction","tokensToFunction_1","tokensToRegExp_1","tokensToRegExp","DEFAULT_DELIMITER","DEFAULT_DELIMITERS","PATH_REGEXP","RegExp","res","tokens","index","defaultDelimiter","delimiter","delimiters","pathEscaped","exec","m","escaped","offset","slice","prev","next","name","capture","group","modifier","k","indexOf","push","partial","undefined","repeat","optional","pattern","prefix","escapeGroup","escapeString","substr","matches","babelHelpers.typeof","data","encode","encodeURIComponent","token","segment","value","TypeError","j","String","replace","flags","sensitive","keys","strict","end","endsWith","concat","map","isEndDelimited","groups","source","regexpToRegexp","parts","arrayToRegexp","stringToRegexp","hasOwnProperty","Object","cache","Map","decodeParam","val","decodeURIComponent","err","matchRoute","ignoreLeadingSlash","parentKeys","parentParams","childMatches","childIndex","routepath","charAt","routeToSkip","done","__children","exact","cacheKey","regexp","get","set","assign","prop","call","split","matchPath","childRoute","parent","matchedLength","childMatch","resolveRoute","Resolver","arguments","classCallCheck","this","baseUrl","errorHandler","resolver","root","__synthetic","toConsumableArray","newRoutes","_root$__children","apply","getRoutes","setRoutes","pathnameOrContext","_this","nextMatches","currentContext","resume","parentRoute","isChildRoute","item","oldChain","shouldDiscardOldChain","chain","addRouteToChain","then","resolution","result","catch","errorMessage","routePath","generateErrorMessage","DOMException","triggers","setNavigationTriggers","newTriggers","trigger","willAnimate","elem","getComputedStyle","getPropertyValue","waitForAnimation","cb","listener","animate","className","classList","add","rect","getBoundingClientRect","size","bottom","top","right","left","remove","removeAttribute","isResultNotEmpty","createLocation","_ref","_ref$pathname","_ref$chain","_ref$params","redirectFrom","createRedirect","from","runCallbackIfPossible","callback","args","thisArg","amend","amendmentFunction","element","amendmentResult","cancel","removeDomNodes","nodes","Router","_Resolver","outlet","possibleConstructorReturn","__proto__","getPrototypeOf","__resolveRoute","NavigationTrigger","setTriggers","ready","__lastStartedRenderId","__navigationEventHandler","__onNavigationEvent","bind","setOutlet","subscribe","inherits","createClass","commands","component","_component","renderComponent","actionResult","callbacks","race","filter","copy","copyContextWithoutNext","newChildren","childRoutes","processNewChildren","__ensureOutlet","__outlet","shouldUpdateHistory","_this2","renderId","__fullyResolveChain","previousContext","__previousContext","__updateBrowserHistory","__addAppearingContent","animationDone","__animateIfNeeded","__runOnAfterEnterCallbacks","__runOnAfterLeaveCallbacks","__removeDisappearingContent","router","originalContext","_this3","__amendWithResolutionResult","amendedContext","initialContext","nextContext","reduce","__amendWithOnBeforeCallbacks","_this4","HTMLElement","__redirect","__redirectCount","contextWithFullChain","_this5","__runOnBeforeCallbacks","newContext","_this6","previousChain","newChain","prevent","__divergedChainIndex","Math","min","redirectData","counter","compile","Node","changeState","history","title","__removeAppearingContent","deepestCommonParent","unchangedElement","__disappearingContent","__appearingContent","parentElement","elementToAdd","targetContext","currentComponent","onAfterLeave","onAfterEnter","to","promises","config","leave","enter","all","render","_len","_key"],"mappings":"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","sourcesContent":["export function toArray(objectOrArray) {\n  objectOrArray = objectOrArray || [];\n  return Array.isArray(objectOrArray) ? objectOrArray : [objectOrArray];\n}\n\nexport function log(msg) {\n  return `[Vaadin.Router] ${msg}`;\n}\n\nconst MODULE = 'module';\nconst NOMODULE = 'nomodule';\nconst bundleKeys = [MODULE, NOMODULE];\n\nfunction ensureBundle(src) {\n  if (!src.match(/.+\\.[m]?js$/)) {\n    throw new Error(\n      log(`Unsupported type for bundle \"${src}\": .js or .mjs expected.`)\n    );\n  }\n}\n\nexport function ensureRoute(route) {\n  if (!route || !isString(route.path)) {\n    throw new Error(\n      log(`Expected route config to be an object with a \"path\" string property, or an array of such objects`)\n    );\n  }\n\n  const bundle = route.bundle;\n\n  const stringKeys = ['component', 'redirect', 'bundle'];\n  if (\n    !isFunction(route.action) &&\n    !Array.isArray(route.children) &&\n    !isFunction(route.children) &&\n    !isObject(bundle) &&\n    !stringKeys.some(key => isString(route[key]))\n  ) {\n    throw new Error(\n      log(\n        `Expected route config \"${route.path}\" to include either \"${stringKeys.join('\", \"')}\" ` +\n        `or \"action\" function but none found.`\n      )\n    );\n  }\n\n  if (bundle) {\n    if (isString(bundle)) {\n      ensureBundle(bundle);\n    } else if (!bundleKeys.some(key => key in bundle)) {\n      throw new Error(\n        log('Expected route bundle to include either \"' + NOMODULE + '\" or \"' + MODULE + '\" keys, or both')\n      );\n    } else {\n      bundleKeys.forEach(key => key in bundle && ensureBundle(bundle[key]));\n    }\n  }\n\n  if (route.redirect) {\n    ['bundle', 'component'].forEach(overriddenProp => {\n      if (overriddenProp in route) {\n        console.warn(\n          log(\n            `Route config \"${route.path}\" has both \"redirect\" and \"${overriddenProp}\" properties, ` +\n            `and \"redirect\" will always override the latter. Did you mean to only use \"${overriddenProp}\"?`\n          )\n        );\n      }\n    });\n  }\n}\n\nexport function ensureRoutes(routes) {\n  toArray(routes).forEach(route => ensureRoute(route));\n}\n\nfunction loadScript(src, key) {\n  let script = document.head.querySelector('script[src=\"' + src + '\"][async]');\n  if (!script) {\n    script = document.createElement('script');\n    script.setAttribute('src', src);\n    if (key === MODULE) {\n      script.setAttribute('type', MODULE);\n    } else if (key === NOMODULE) {\n      script.setAttribute(NOMODULE, '');\n    }\n    script.async = true;\n  }\n  return new Promise((resolve, reject) => {\n    script.onreadystatechange = script.onload = e => {\n      script.__dynamicImportLoaded = true;\n      resolve(e);\n    };\n    script.onerror = e => {\n      if (script.parentNode) {\n        script.parentNode.removeChild(script);\n      }\n      reject(e);\n    };\n    if (script.parentNode === null) {\n      document.head.appendChild(script);\n    } else if (script.__dynamicImportLoaded) {\n      resolve();\n    }\n  });\n}\n\nexport function loadBundle(bundle) {\n  if (isString(bundle)) {\n    return loadScript(bundle);\n  } else {\n    return Promise.race(\n      bundleKeys\n        .filter(key => key in bundle)\n        .map(key => loadScript(bundle[key], key))\n    );\n  }\n}\n\nexport function fireRouterEvent(type, detail) {\n  window.dispatchEvent(\n    new CustomEvent(\n      `vaadin-router-${type}`, {detail}));\n}\n\nexport function isObject(o) {\n  // guard against null passing the typeof check\n  return typeof o === 'object' && !!o;\n}\n\nexport function isFunction(f) {\n  return typeof f === 'function';\n}\n\nexport function isString(s) {\n  return typeof s === 'string';\n}\n\nexport function getNotFoundError(context) {\n  const error = new Error(log(`Page not found (${context.pathname})`));\n  error.context = context;\n  error.code = 404;\n  return error;\n}\n","import {fireRouterEvent} from '../utils.js';\n\n/* istanbul ignore next: coverage is calculated in Chrome, this code is for IE */\nfunction getAnchorOrigin(anchor) {\n  // IE11: on HTTP and HTTPS the default port is not included into\n  // window.location.origin, so won't include it here either.\n  const port = anchor.port;\n  const protocol = anchor.protocol;\n  const defaultHttp = protocol === 'http:' && port === '80';\n  const defaultHttps = protocol === 'https:' && port === '443';\n  const host = (defaultHttp || defaultHttps)\n    ? anchor.hostname // does not include the port number (e.g. www.example.org)\n    : anchor.host; // does include the port number (e.g. www.example.org:80)\n  return `${protocol}//${host}`;\n}\n\n// The list of checks is not complete:\n//  - SVG support is missing\n//  - the 'rel' attribute is not considered\nfunction vaadinRouterGlobalClickHandler(event) {\n  // ignore the click if the default action is prevented\n  if (event.defaultPrevented) {\n    return;\n  }\n\n  // ignore the click if not with the primary mouse button\n  if (event.button !== 0) {\n    return;\n  }\n\n  // ignore the click if a modifier key is pressed\n  if (event.shiftKey || event.ctrlKey || event.altKey || event.metaKey) {\n    return;\n  }\n\n  // find the <a> element that the click is at (or within)\n  let anchor = event.target;\n  const path = event.composedPath\n    ? event.composedPath()\n    : (event.path || []);\n\n  // FIXME(web-padawan): `Symbol.iterator` used by webcomponentsjs is broken for arrays\n  // example to check: `for...of` loop here throws the \"Not yet implemented\" error\n  for (let i = 0; i < path.length; i++) {\n    const target = path[i];\n    if (target.nodeName && target.nodeName.toLowerCase() === 'a') {\n      anchor = target;\n      break;\n    }\n  }\n\n  while (anchor && anchor.nodeName.toLowerCase() !== 'a') {\n    anchor = anchor.parentNode;\n  }\n\n  // ignore the click if not at an <a> element\n  if (!anchor || anchor.nodeName.toLowerCase() !== 'a') {\n    return;\n  }\n\n  // ignore the click if the <a> element has a non-default target\n  if (anchor.target && anchor.target.toLowerCase() !== '_self') {\n    return;\n  }\n\n  // ignore the click if the <a> element has the 'download' attribute\n  if (anchor.hasAttribute('download')) {\n    return;\n  }\n\n  // ignore the click if the target URL is a fragment on the current page\n  if (anchor.pathname === window.location.pathname && anchor.hash !== '') {\n    return;\n  }\n\n  // ignore the click if the target is external to the app\n  // In IE11 HTMLAnchorElement does not have the `origin` property\n  const origin = anchor.origin || getAnchorOrigin(anchor);\n  if (origin !== window.location.origin) {\n    return;\n  }\n\n  // if none of the above, convert the click into a navigation event\n  event.preventDefault();\n  fireRouterEvent('go', {pathname: anchor.pathname});\n}\n\n/**\n * A navigation trigger for Vaadin Router that translated clicks on `<a>` links\n * into Vaadin Router navigation events.\n *\n * Only regular clicks on in-app links are translated (primary mouse button, no\n * modifier keys, the target href is within the app's URL space).\n *\n * @memberOf Vaadin.Router.Triggers\n * @type {NavigationTrigger}\n */\nconst CLICK = {\n  activate() {\n    window.document.addEventListener('click', vaadinRouterGlobalClickHandler);\n  },\n\n  inactivate() {\n    window.document.removeEventListener('click', vaadinRouterGlobalClickHandler);\n  }\n};\n\nexport default CLICK;\n","import {fireRouterEvent, isFunction} from '../utils.js';\n\n// PopStateEvent constructor shim\nconst isIE = /Trident/.test(navigator.userAgent);\n\n/* istanbul ignore next: coverage is calculated in Chrome, this code is for IE */\nif (isIE && !isFunction(window.PopStateEvent)) {\n  window.PopStateEvent = function(inType, params) {\n    params = params || {};\n    var e = document.createEvent('Event');\n    e.initEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable));\n    e.state = params.state || null;\n    return e;\n  };\n  window.PopStateEvent.prototype = window.Event.prototype;\n}\n\nfunction vaadinRouterGlobalPopstateHandler(event) {\n  if (event.state === 'vaadin-router-ignore') {\n    return;\n  }\n  fireRouterEvent('go', {pathname: window.location.pathname});\n}\n\n/**\n * A navigation trigger for Vaadin Router that translates popstate events into\n * Vaadin Router navigation events.\n *\n * @memberOf Vaadin.Router.Triggers\n * @type {NavigationTrigger}\n */\nconst POPSTATE = {\n  activate() {\n    window.addEventListener('popstate', vaadinRouterGlobalPopstateHandler);\n  },\n\n  inactivate() {\n    window.removeEventListener('popstate', vaadinRouterGlobalPopstateHandler);\n  }\n};\n\nexport default POPSTATE;\n","/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * Default configs.\n */\nvar DEFAULT_DELIMITER = '/'\nvar DEFAULT_DELIMITERS = './'\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\"]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined]\n  '(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var defaultDelimiter = (options && options.delimiter) || DEFAULT_DELIMITER\n  var delimiters = (options && options.delimiters) || DEFAULT_DELIMITERS\n  var pathEscaped = false\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) !== null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      pathEscaped = true\n      continue\n    }\n\n    var prev = ''\n    var next = str[index]\n    var name = res[2]\n    var capture = res[3]\n    var group = res[4]\n    var modifier = res[5]\n\n    if (!pathEscaped && path.length) {\n      var k = path.length - 1\n\n      if (delimiters.indexOf(path[k]) > -1) {\n        prev = path[k]\n        path = path.slice(0, k)\n      }\n    }\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n      pathEscaped = false\n    }\n\n    var partial = prev !== '' && next !== undefined && next !== prev\n    var repeat = modifier === '+' || modifier === '*'\n    var optional = modifier === '?' || modifier === '*'\n    var delimiter = prev || defaultDelimiter\n    var pattern = capture || group\n\n    tokens.push({\n      name: name || key++,\n      prefix: prev,\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      pattern: pattern ? escapeGroup(pattern) : '[^' + escapeString(delimiter) + ']+?'\n    })\n  }\n\n  // Push any remaining characters.\n  if (path || index < str.length) {\n    tokens.push(path + str.substr(index))\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options))\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')\n    }\n  }\n\n  return function (data, options) {\n    var path = ''\n    var encode = (options && options.encode) || encodeURIComponent\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n        continue\n      }\n\n      var value = data ? data[token.name] : undefined\n      var segment\n\n      if (Array.isArray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but got array')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) continue\n\n          throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j], token)\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\"')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n        segment = encode(String(value), token)\n\n        if (!matches[i].test(segment)) {\n          throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but got \"' + segment + '\"')\n        }\n\n        path += token.prefix + segment\n        continue\n      }\n\n      if (token.optional) {\n        // Prepend partial segment prefixes.\n        if (token.partial) path += token.prefix\n\n        continue\n      }\n\n      throw new TypeError('Expected \"' + token.name + '\" to be ' + (token.repeat ? 'an array' : 'a string'))\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$/()])/g, '\\\\$1')\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options && options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {Array=}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  if (!keys) return path\n\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        pattern: null\n      })\n    }\n  }\n\n  return path\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array=}  keys\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  return new RegExp('(?:' + parts.join('|') + ')', flags(options))\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {Array=}  keys\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}  tokens\n * @param  {Array=}  keys\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  options = options || {}\n\n  var strict = options.strict\n  var end = options.end !== false\n  var delimiter = escapeString(options.delimiter || DEFAULT_DELIMITER)\n  var delimiters = options.delimiters || DEFAULT_DELIMITERS\n  var endsWith = [].concat(options.endsWith || []).map(escapeString).concat('$').join('|')\n  var route = ''\n  var isEndDelimited = tokens.length === 0\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n      isEndDelimited = i === tokens.length - 1 && delimiters.indexOf(token[token.length - 1]) > -1\n    } else {\n      var prefix = escapeString(token.prefix)\n      var capture = token.repeat\n        ? '(?:' + token.pattern + ')(?:' + prefix + '(?:' + token.pattern + '))*'\n        : token.pattern\n\n      if (keys) keys.push(token)\n\n      if (token.optional) {\n        if (token.partial) {\n          route += prefix + '(' + capture + ')?'\n        } else {\n          route += '(?:' + prefix + '(' + capture + '))?'\n        }\n      } else {\n        route += prefix + '(' + capture + ')'\n      }\n    }\n  }\n\n  if (end) {\n    if (!strict) route += '(?:' + delimiter + ')?'\n\n    route += endsWith === '$' ? '$' : '(?=' + endsWith + ')'\n  } else {\n    if (!strict) route += '(?:' + delimiter + '(?=' + endsWith + '))?'\n    if (!isEndDelimited) route += '(?=' + delimiter + '|' + endsWith + ')'\n  }\n\n  return new RegExp('^' + route, flags(options))\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {Array=}                keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, keys)\n  }\n\n  if (Array.isArray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), keys, options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), keys, options)\n}\n","/**\n * Universal Router (https://www.kriasoft.com/universal-router/)\n *\n * Copyright (c) 2015-present Kriasoft.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\nimport pathToRegexp from './path-to-regexp.js';\n\nconst {hasOwnProperty} = Object.prototype;\nconst cache = new Map();\n// see https://github.com/pillarjs/path-to-regexp/issues/148\ncache.set('|false', {\n  keys: [],\n  pattern: /(?:)/\n});\n\nfunction decodeParam(val) {\n  try {\n    return decodeURIComponent(val);\n  } catch (err) {\n    return val;\n  }\n}\n\nfunction matchPath(routepath, path, exact, parentKeys, parentParams) {\n  exact = !!exact;\n  const cacheKey = `${routepath}|${exact}`;\n  let regexp = cache.get(cacheKey);\n\n  if (!regexp) {\n    const keys = [];\n    regexp = {\n      keys,\n      pattern: pathToRegexp(routepath, keys, {\n        end: exact,\n        strict: routepath === ''\n      }),\n    };\n    cache.set(cacheKey, regexp);\n  }\n\n  const m = regexp.pattern.exec(path);\n  if (!m) {\n    return null;\n  }\n\n  const params = Object.assign({}, parentParams);\n\n  for (let i = 1; i < m.length; i++) {\n    const key = regexp.keys[i - 1];\n    const prop = key.name;\n    const value = m[i];\n    if (value !== undefined || !hasOwnProperty.call(params, prop)) {\n      if (key.repeat) {\n        params[prop] = value ? value.split(key.delimiter).map(decodeParam) : [];\n      } else {\n        params[prop] = value ? decodeParam(value) : value;\n      }\n    }\n  }\n\n  return {\n    path: m[0],\n    keys: (parentKeys || []).concat(regexp.keys),\n    params,\n  };\n}\n\nexport default matchPath;\n","/**\n * Universal Router (https://www.kriasoft.com/universal-router/)\n *\n * Copyright (c) 2015-present Kriasoft.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\nimport matchPath from './matchPath.js';\n\n/**\n * Traverses the routes tree and matches its nodes to the given pathname from\n * the root down to the leaves. Each match consumes a part of the pathname and\n * the matching process continues for as long as there is a matching child\n * route for the remaining part of the pathname.\n *\n * The returned value is a lazily evaluated iterator.\n *\n * The leading \"/\" in a route path matters only for the root of the routes\n * tree (or if all parent routes are \"\"). In all other cases a leading \"/\" in\n * a child route path has no significance.\n *\n * The trailing \"/\" in a _route path_ matters only for the leaves of the\n * routes tree. A leaf route with a trailing \"/\" matches only a pathname that\n * also has a trailing \"/\".\n *\n * The trailing \"/\" in a route path does not affect matching of child routes\n * in any way.\n *\n * The trailing \"/\" in a _pathname_ generally does not matter (except for\n * the case of leaf nodes described above).\n *\n * The \"\" and \"/\" routes have special treatment:\n *  1. as a single route\n *     the \"\" and \"/\" routes match only the \"\" and \"/\" pathnames respectively\n *  2. as a parent in the routes tree\n *     the \"\" route matches any pathname without consuming any part of it\n *     the \"/\" route matches any absolute pathname consuming its leading \"/\"\n *  3. as a leaf in the routes tree\n *     the \"\" and \"/\" routes match only if the entire pathname is consumed by\n *         the parent routes chain. In this case \"\" and \"/\" are equivalent.\n *  4. several directly nested \"\" or \"/\" routes\n *     - directly nested \"\" or \"/\" routes are 'squashed' (i.e. nesting two\n *       \"/\" routes does not require a double \"/\" in the pathname to match)\n *     - if there are only \"\" in the parent routes chain, no part of the\n *       pathname is consumed, and the leading \"/\" in the child routes' paths\n *       remains significant\n *\n * Side effect:\n *   - the routes tree { path: '' } matches only the '' pathname\n *   - the routes tree { path: '', children: [ { path: '' } ] } matches any\n *     pathname (for the tree root)\n *\n * Prefix matching can be enabled also by `children: true`.\n */\nfunction matchRoute(route, pathname, ignoreLeadingSlash, parentKeys, parentParams) {\n  let match;\n  let childMatches;\n  let childIndex = 0;\n  let routepath = route.path || '';\n  if (routepath.charAt(0) === '/') {\n    if (ignoreLeadingSlash) {\n      routepath = routepath.substr(1);\n    }\n    ignoreLeadingSlash = true;\n  }\n\n  return {\n    next(routeToSkip) {\n      if (route === routeToSkip) {\n        return {done: true};\n      }\n\n      const children = route.__children = route.__children || route.children;\n\n      if (!match) {\n        match = matchPath(routepath, pathname, !children, parentKeys, parentParams);\n\n        if (match) {\n          return {\n            done: false,\n            value: {\n              route,\n              keys: match.keys,\n              params: match.params,\n              path: match.path\n            },\n          };\n        }\n      }\n\n      if (match && children) {\n        while (childIndex < children.length) {\n          if (!childMatches) {\n            const childRoute = children[childIndex];\n            childRoute.parent = route;\n\n            let matchedLength = match.path.length;\n            if (matchedLength > 0 && pathname.charAt(matchedLength) === '/') {\n              matchedLength += 1;\n            }\n\n            childMatches = matchRoute(\n              childRoute,\n              pathname.substr(matchedLength),\n              ignoreLeadingSlash,\n              match.keys,\n              match.params\n            );\n          }\n\n          const childMatch = childMatches.next(routeToSkip);\n          if (!childMatch.done) {\n            return {\n              done: false,\n              value: childMatch.value,\n            };\n          }\n\n          childMatches = null;\n          childIndex++;\n        }\n      }\n\n      return {done: true};\n    },\n  };\n}\n\nexport default matchRoute;\n","/**\n * Universal Router (https://www.kriasoft.com/universal-router/)\n *\n * Copyright (c) 2015-present Kriasoft.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\nimport {isFunction} from '../utils.js';\n\nfunction resolveRoute(context) {\n  if (isFunction(context.route.action)) {\n    return context.route.action(context);\n  }\n  return undefined;\n}\n\nexport default resolveRoute;\n","/**\n * Universal Router (https://www.kriasoft.com/universal-router/)\n *\n * Copyright (c) 2015-present Kriasoft.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\nimport pathToRegexp from './path-to-regexp.js';\nimport matchRoute from './matchRoute.js';\nimport resolveRoute from './resolveRoute.js';\nimport {toArray, ensureRoutes, isString, getNotFoundError} from '../utils.js';\n\nfunction isChildRoute(parentRoute, childRoute) {\n  let route = childRoute;\n  while (route) {\n    route = route.parent;\n    if (route === parentRoute) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction generateErrorMessage(currentContext) {\n  let errorMessage = `Path '${currentContext.pathname}' is not properly resolved due to an error.`;\n  const routePath = (currentContext.route || {}).path;\n  if (routePath) {\n    errorMessage += ` Resolution had failed on route: '${routePath}'`;\n  }\n  return errorMessage;\n}\n\nfunction addRouteToChain(context, match) {\n  const {route, path} = match;\n  function shouldDiscardOldChain(oldChain, route) {\n    return !route.parent || !oldChain || !oldChain.length || oldChain[oldChain.length - 1].route !== route.parent;\n  }\n\n  if (route && !route.__synthetic) {\n    const item = {path, route};\n    if (shouldDiscardOldChain(context.chain, route)) {\n      context.chain = [item];\n    } else {\n      context.chain.push(item);\n    }\n  }\n}\n\n/**\n * @memberof Vaadin\n */\nclass Resolver {\n  constructor(routes, options = {}) {\n    if (Object(routes) !== routes) {\n      throw new TypeError('Invalid routes');\n    }\n\n    this.baseUrl = options.baseUrl || '';\n    this.errorHandler = options.errorHandler;\n    this.resolveRoute = options.resolveRoute || resolveRoute;\n    this.context = Object.assign({resolver: this}, options.context);\n    this.root = Array.isArray(routes) ? {path: '', __children: routes, parent: null, __synthetic: true} : routes;\n    this.root.parent = null;\n  }\n\n  /**\n   * Returns the current list of routes (as a shallow copy). Adding / removing\n   * routes to / from the returned array does not affect the routing config,\n   * but modifying the route objects does.\n   *\n   * @return {!Array<!Route>}\n   */\n  getRoutes() {\n    return [...this.root.__children];\n  }\n\n  /**\n   * Sets the routing config (replacing the existing one).\n   *\n   * @param {!Array<!Route>|!Route} routes a single route or an array of those\n   *    (the array is shallow copied)\n   */\n  setRoutes(routes) {\n    ensureRoutes(routes);\n    const newRoutes = [...toArray(routes)];\n    this.root.__children = newRoutes;\n  }\n\n  /**\n   * Appends one or several routes to the routing config and returns the\n   * effective routing config after the operation.\n   *\n   * @param {!Array<!Route>|!Route} routes a single route or an array of those\n   *    (the array is shallow copied)\n   * @return {!Array<!Route>}\n   * @protected\n   */\n  addRoutes(routes) {\n    ensureRoutes(routes);\n    this.root.__children.push(...toArray(routes));\n    return this.getRoutes();\n  }\n\n  /**\n   * Removes all existing routes from the routing config.\n   */\n  removeRoutes() {\n    this.setRoutes([]);\n  }\n\n  /**\n   * Asynchronously resolves the given pathname, i.e. finds all routes matching\n   * the pathname and tries resolving them one after another in the order they\n   * are listed in the routes config until the first non-null result.\n   *\n   * Returns a promise that is fulfilled with the return value of an object that consists of the first\n   * route handler result that returns something other than `null` or `undefined` and context used to get this result.\n   *\n   * If no route handlers return a non-null result, or if no route matches the\n   * given pathname the returned promise is rejected with a 'page not found'\n   * `Error`.\n   *\n   * @param {!string|!{pathname: !string}} pathnameOrContext the pathname to\n   *    resolve or a context object with a `pathname` property and other\n   *    properties to pass to the route resolver functions.\n   * @return {!Promise<any>}\n   */\n  resolve(pathnameOrContext) {\n    const context = Object.assign(\n      {},\n      this.context,\n      isString(pathnameOrContext) ? {pathname: pathnameOrContext} : pathnameOrContext\n    );\n    const match = matchRoute(\n      this.root,\n      context.pathname.substr(this.baseUrl.length)\n    );\n    const resolve = this.resolveRoute;\n    let matches = null;\n    let nextMatches = null;\n    let currentContext = context;\n\n    function next(resume, parent = matches.value.route, prevResult) {\n      const routeToSkip = prevResult === null && matches.value.route;\n      matches = nextMatches || match.next(routeToSkip);\n      nextMatches = null;\n\n      if (!resume) {\n        if (matches.done || !isChildRoute(parent, matches.value.route)) {\n          nextMatches = matches;\n          return Promise.resolve(null);\n        }\n      }\n\n      if (matches.done) {\n        return Promise.reject(getNotFoundError(context));\n      }\n\n      addRouteToChain(context, matches.value);\n      currentContext = Object.assign({}, context, matches.value);\n\n      return Promise.resolve(resolve(currentContext)).then(resolution => {\n        if (resolution !== null && resolution !== undefined) {\n          currentContext.result = resolution.result || resolution;\n          return currentContext;\n        }\n        return next(resume, parent, resolution);\n      });\n    }\n\n    context.next = next;\n\n    return Promise.resolve()\n      .then(() => next(true, this.root))\n      .catch((error) => {\n        const errorMessage = generateErrorMessage(currentContext);\n        if (!error) {\n          error = new Error(errorMessage);\n        } else {\n          console.warn(errorMessage);\n        }\n        error.context = error.context || currentContext;\n        // DOMException has its own code which is read-only\n        if (!(error instanceof DOMException)) {\n          error.code = error.code || 500;\n        }\n        if (this.errorHandler) {\n          currentContext.result = this.errorHandler(error);\n          return currentContext;\n        }\n        throw error;\n      });\n  }\n}\n\nResolver.pathToRegexp = pathToRegexp;\n\nexport default Resolver;\n","/**\n * @typedef NavigationTrigger\n * @type {object}\n * @property {function()} activate\n * @property {function()} inactivate\n */\n\n/** @type {Array<NavigationTrigger>} */\nlet triggers = [];\n\nexport default function setNavigationTriggers(newTriggers) {\n  triggers.forEach(trigger => trigger.inactivate());\n\n  newTriggers.forEach(trigger => trigger.activate());\n\n  triggers = newTriggers;\n}\n","const willAnimate = elem => {\n  const name = getComputedStyle(elem).getPropertyValue('animation-name');\n  return name && name !== 'none';\n};\n\nconst waitForAnimation = (elem, cb) => {\n  const listener = () => {\n    elem.removeEventListener('animationend', listener);\n    cb();\n  };\n  elem.addEventListener('animationend', listener);\n};\n\nfunction animate(elem, className) {\n  elem.classList.add(className);\n\n  return new Promise(resolve => {\n    if (willAnimate(elem)) {\n      const rect = elem.getBoundingClientRect();\n      const size = `height: ${rect.bottom - rect.top}px; width: ${rect.right - rect.left}px`;\n      elem.setAttribute('style', `position: absolute; ${size}`);\n      waitForAnimation(elem, () => {\n        elem.classList.remove(className);\n        elem.removeAttribute('style');\n        resolve();\n      });\n    } else {\n      elem.classList.remove(className);\n      resolve();\n    }\n  });\n}\n\nexport default animate;\n","import Resolver from './resolver/resolver.js';\nimport setNavigationTriggers from './triggers/setNavigationTriggers.js';\nimport animate from './transitions/animate.js';\nimport {\n  ensureRoute,\n  fireRouterEvent,\n  loadBundle,\n  log,\n  toArray,\n  isFunction,\n  isString,\n  isObject,\n  getNotFoundError,\n} from './utils.js';\n\nconst MAX_REDIRECT_COUNT = 256;\n\nfunction isResultNotEmpty(result) {\n  return result !== null && result !== undefined;\n}\n\nfunction copyContextWithoutNext(context) {\n  const copy = Object.assign({}, context);\n  delete copy.next;\n  return copy;\n}\n\nfunction createLocation({pathname = '', chain = [], params = {}, redirectFrom}, route) {\n  return {\n    pathname,\n    routes: chain.map(item => item.route),\n    route: (!route && chain.length && chain[chain.length - 1].route) || route,\n    params,\n    redirectFrom,\n  };\n}\n\nfunction createRedirect(context, pathname) {\n  const params = Object.assign({}, context.params);\n  return {\n    redirect: {\n      pathname,\n      from: context.pathname,\n      params\n    }\n  };\n}\n\nfunction renderComponent(context, component) {\n  const element = document.createElement(component);\n  element.location = createLocation(context);\n  const index = context.chain.map(item => item.route).indexOf(context.route);\n  context.chain[index].element = element;\n  return element;\n}\n\nfunction runCallbackIfPossible(callback, args, thisArg) {\n  if (isFunction(callback)) {\n    return callback.apply(thisArg, args);\n  }\n}\n\nfunction amend(amendmentFunction, args, element) {\n  return amendmentResult => {\n    if (amendmentResult && (amendmentResult.cancel || amendmentResult.redirect)) {\n      return amendmentResult;\n    }\n\n    if (element) {\n      return runCallbackIfPossible(element[amendmentFunction], args, element);\n    }\n  };\n}\n\nfunction processNewChildren(newChildren, route) {\n  if (!Array.isArray(newChildren) && !isObject(newChildren)) {\n    throw new Error(\n      log(\n        `Incorrect \"children\" value for the route ${route.path}: expected array or object, but got ${newChildren}`\n      )\n    );\n  }\n\n  route.__children = [];\n  const childRoutes = toArray(newChildren);\n  for (let i = 0; i < childRoutes.length; i++) {\n    ensureRoute(childRoutes[i]);\n    route.__children.push(childRoutes[i]);\n  }\n}\n\nfunction removeDomNodes(nodes) {\n  if (nodes && nodes.length) {\n    const parent = nodes[0].parentNode;\n    for (let i = 0; i < nodes.length; i++) {\n      parent.removeChild(nodes[i]);\n    }\n  }\n}\n\nfunction getMatchedPath(chain) {\n  return chain.map(item => item.path).reduce((prev, path) => {\n    if (path.length) {\n      return prev + (prev.charAt(prev.length - 1) === '/' ? '' : '/') + path;\n    }\n    return prev;\n  });\n}\n\n/**\n * A simple client-side router for single-page applications. It uses\n * express-style middleware and has a first-class support for Web Components and\n * lazy-loading. Works great in Polymer and non-Polymer apps.\n *\n * Use `new Router(outlet)` to create a new Router instance. The `outlet` parameter is a reference to the DOM node\n * to render the content into. The Router instance is automatically subscribed to navigation events on `window`.\n *\n * See [Live Examples](#/classes/Vaadin.Router/demos/demo/index.html) for the detailed usage demo and code snippets.\n *\n * See also detailed API docs for the following methods, for the advanced usage:\n *\n * * [setOutlet](#/classes/Vaadin.Router#method-setOutlet) – should be used to configure the outlet.\n * * [setTriggers](#/classes/Vaadin.Router#method-setTriggers) – should be used to configure the navigation events.\n * * [setRoutes](#/classes/Vaadin.Router#method-setRoutes) – should be used to configure the routes.\n *\n * Only `setRoutes` has to be called manually, others are automatically invoked when creating a new instance.\n *\n * @memberof Vaadin\n * @extends Vaadin.Resolver\n * @demo demo/index.html\n * @summary JavaScript class that renders different DOM content depending on\n *    a given path. It can re-render when triggered or automatically on\n *    'popstate' and / or 'click' events.\n */\nexport class Router extends Resolver {\n\n  /**\n   * Creates a new Router instance with a given outlet, and\n   * automatically subscribes it to navigation events on the `window`.\n   * Using a constructor argument or a setter for outlet is equivalent:\n   *\n   * ```\n   * const router = new Vaadin.Router();\n   * router.setOutlet(outlet);\n   * ```\n   * @param {?Node} outlet\n   * @param {?RouterOptions} options\n   */\n  constructor(outlet, options) {\n    super([], Object.assign({}, options));\n    this.resolveRoute = context => this.__resolveRoute(context);\n\n    const triggers = Router.NavigationTrigger;\n    Router.setTriggers.apply(Router, Object.keys(triggers).map(key => triggers[key]));\n\n    /**\n     * A promise that is settled after the current render cycle completes. If\n     * there is no render cycle in progress the promise is immediately settled\n     * with the last render cycle result.\n     *\n     * @public\n     * @type {!Promise<!Vaadin.Router.Location>}\n     */\n    this.ready;\n    this.ready = Promise.resolve(outlet);\n\n    /**\n     * Contains read-only information about the current router location:\n     * pathname, active routes, parameters. See the\n     * [Location type declaration](#/classes/Vaadin.Router.Location)\n     * for more details.\n     *\n     * @public\n     * @type {!Vaadin.Router.Location}\n     */\n    this.location;\n    this.location = createLocation({});\n\n    this.__lastStartedRenderId = 0;\n    this.__navigationEventHandler = this.__onNavigationEvent.bind(this);\n    this.setOutlet(outlet);\n    this.subscribe();\n  }\n\n  __resolveRoute(context) {\n    const route = context.route;\n\n    const commands = {\n      redirect: path => createRedirect(context, path),\n      component: component => renderComponent(context, component)\n    };\n    const actionResult = runCallbackIfPossible(route.action, [context, commands], route);\n    if (isResultNotEmpty(actionResult)) {\n      return actionResult;\n    }\n\n    if (isString(route.redirect)) {\n      return commands.redirect(route.redirect);\n    }\n\n    let callbacks = Promise.resolve();\n\n    if (route.bundle) {\n      callbacks = callbacks.then(() => loadBundle(route.bundle))\n        .catch(() => {\n          throw new Error(log(`Bundle not found: ${route.bundle}. Check if the file name is correct`));\n        });\n    }\n\n    if (isFunction(route.children)) {\n      callbacks = callbacks\n        .then(() => route.children(copyContextWithoutNext(context)))\n        .then(children => {\n          // The route.children() callback might have re-written the\n          // route.children property instead of returning a value\n          if (!isResultNotEmpty(children) && !isFunction(route.children)) {\n            children = route.children;\n          }\n          processNewChildren(children, route);\n        });\n    }\n\n    return callbacks.then(() => {\n      if (isString(route.component)) {\n        return commands.component(route.component);\n      }\n    });\n  }\n\n  /**\n   * Sets the router outlet (the DOM node where the content for the current\n   * route is inserted). Any content pre-existing in the router outlet is\n   * removed at the end of each render pass.\n   *\n   * NOTE: this method is automatically invoked first time when creating a new Router instance.\n   *\n   * @param {?Node} outlet the DOM node where the content for the current route\n   *     is inserted.\n   */\n  setOutlet(outlet) {\n    if (outlet) {\n      this.__ensureOutlet(outlet);\n    }\n    this.__outlet = outlet;\n  }\n\n  /**\n   * Returns the current router outlet. The initial value is `undefined`.\n   *\n   * @return {?Node} the current router outlet (or `undefined`)\n   */\n  getOutlet() {\n    return this.__outlet;\n  }\n\n  /**\n   * Sets the routing config (replacing the existing one) and triggers a\n   * navigation event so that the router outlet is refreshed according to the\n   * current `window.location` and the new routing config.\n   *\n   * Each route object may have the following properties, listed here in the processing order:\n   * * `path` – the route path (relative to the parent route if any) in the\n   * [express.js syntax](https://expressjs.com/en/guide/routing.html#route-paths\").\n   *\n   * * `action` – the action that is executed before the route is resolved.\n   * The value for this property should be a function, accepting a `context` parameter described below.\n   * If present, this function is always invoked first, disregarding of the other properties' presence.\n   * If the action returns a non-empty result, current route resolution is finished and other route config properties are ignored.\n   * See also **Route Actions** section in [Live Examples](#/classes/Vaadin.Router/demos/demo/index.html).\n   *\n   * * `redirect` – other route's path to redirect to. Passes all route parameters to the redirect target.\n   * The target route should also be defined.\n   * See also **Redirects** section in [Live Examples](#/classes/Vaadin.Router/demos/demo/index.html).\n   *\n   * * `bundle` – string containing the path to `.js` or `.mjs` bundle to load before resolving the route,\n   * or the object with \"module\" and \"nomodule\" keys referring to different bundles.\n   * Each bundle is only loaded once. If \"module\" and \"nomodule\" are set, only one bundle is loaded,\n   * depending on whether the browser supports ES modules or not.\n   * The property is ignored when either an `action` returns the result or `redirect` property is present.\n   * Any error, e.g. 404 while loading bundle will cause route resolution to throw.\n   * See also **Code Splitting** section in [Live Examples](#/classes/Vaadin.Router/demos/demo/index.html).\n   *\n   * * `children` – an array of nested routes or a function that provides this\n   * array at the render time. The function can be synchronous or asynchronous:\n   * in the latter case the render is delayed until the returned promise is\n   * resolved. The `children` function is executed every time when this route is\n   * being rendered. This allows for dynamic route structures (e.g. backend-defined),\n   * but it might have a performance impact as well. In order to avoid calling\n   * the function on subsequent renders, you can override the `children` property\n   * of the route object and save the calculated array there\n   * (via `context.route.children = [ route1, route2, ...];`).\n   * Parent routes are fully resolved before resolving the children. Children\n   * 'path' values are relative to the parent ones.\n   *\n   * * `component` – the tag name of the Web Component to resolve the route to.\n   * The property is ignored when either an `action` returns the result or `redirect` property is present.\n   * If route contains the `component` property (or an action that return a component)\n   * and its child route also contains the `component` property, child route's component\n   * will be rendered as a light dom child of a parent component.\n   *\n   * For any route function (`action`, `children`) defined, the corresponding `route` object is available inside the callback\n   * through the `this` reference. If you need to access it, make sure you define the callback as a non-arrow function\n   * because arrow functions do not have their own `this` reference.\n   *\n   * `context` object that is passed to `action` function holds the following properties:\n   * * `context.pathname` – string with the pathname being resolved\n   *\n   * * `context.params` – object with route parameters\n   *\n   * * `context.route` – object that holds the route that is currently being rendered.\n   *\n   * * `context.next()` – function for asynchronously getting the next route contents from the resolution chain (if any)\n   *\n   * * `context.redirect(path)` – function that creates a redirect data for the path specified.\n   *\n   * * `context.component(component)` – function that creates a new HTMLElement with current context\n   *\n   * @param {!Array<!Object>|!Object} routes a single route or an array of those\n   */\n  setRoutes(routes) {\n    super.setRoutes(routes);\n    this.__onNavigationEvent();\n  }\n\n  /**\n   * Asynchronously resolves the given pathname and renders the resolved route\n   * component into the router outlet. If no router outlet is set at the time of\n   * calling this method, or at the time when the route resolution is completed,\n   * a `TypeError` is thrown.\n   *\n   * Returns a promise that is fulfilled with the router outlet DOM Node after\n   * the route component is created and inserted into the router outlet, or\n   * rejected if no route matches the given path.\n   *\n   * If another render pass is started before the previous one is completed, the\n   * result of the previous render pass is ignored.\n   *\n   * @param {!string|!{pathname: !string}} pathnameOrContext the pathname to\n   *    render or a context object with a `pathname` property and other\n   *    properties to pass to the resolver.\n   * @return {!Promise<!Node>}\n   */\n  render(pathnameOrContext, shouldUpdateHistory) {\n    const renderId = ++this.__lastStartedRenderId;\n    const pathname = pathnameOrContext.pathname || pathnameOrContext;\n\n    // Find the first route that resolves to a non-empty result\n    this.ready = this.resolve(pathnameOrContext)\n\n      // Process the result of this.resolve() and handle all special commands:\n      // (redirect / prevent / component). If the result is a 'component',\n      // then go deeper and build the entire chain of nested components matching\n      // the pathname. Also call all 'on before' callbacks along the way.\n      .then(context => this.__fullyResolveChain(context))\n\n      .then(context => {\n        if (renderId === this.__lastStartedRenderId) {\n          const previousContext = this.__previousContext;\n\n          // Check if the render was prevented and make an early return in that case\n          if (context === previousContext) {\n            return this.location;\n          }\n\n          if (shouldUpdateHistory) {\n            this.__updateBrowserHistory(context.pathname, context.redirectFrom);\n          }\n\n          this.__addAppearingContent(context, previousContext);\n          const animationDone = this.__animateIfNeeded(context);\n\n          this.__runOnAfterEnterCallbacks(context);\n          this.__runOnAfterLeaveCallbacks(context, previousContext);\n\n          return animationDone.then(() => {\n            if (renderId === this.__lastStartedRenderId) {\n              // If there is another render pass started after this one,\n              // the 'disappearing content' would be removed when the other\n              // render pass calls `this.__addAppearingContent()`\n              this.__removeDisappearingContent();\n\n              this.__previousContext = context;\n              this.location = createLocation(context);\n              fireRouterEvent('location-changed', {router: this, location: this.location});\n              return this.location;\n            }\n          });\n        }\n      })\n      .catch(error => {\n        if (renderId === this.__lastStartedRenderId) {\n          if (shouldUpdateHistory) {\n            this.__updateBrowserHistory(pathname);\n          }\n          removeDomNodes(this.__outlet && this.__outlet.children);\n          this.location = createLocation({pathname});\n          fireRouterEvent('error', {router: this, error, pathname});\n          throw error;\n        }\n      });\n    return this.ready;\n  }\n\n  __fullyResolveChain(originalContext, currentContext = originalContext) {\n    return this.__amendWithResolutionResult(currentContext)\n      .then(amendedContext => {\n        const initialContext = amendedContext !== currentContext ? amendedContext : originalContext;\n        return amendedContext.next()\n          .then(nextContext => {\n            if (nextContext === null) {\n              if (amendedContext.pathname !== getMatchedPath(amendedContext.chain)) {\n                throw getNotFoundError(initialContext);\n              }\n            }\n            return nextContext\n              ? this.__fullyResolveChain(initialContext, nextContext)\n              : this.__amendWithOnBeforeCallbacks(initialContext);\n          });\n      });\n  }\n\n  __amendWithResolutionResult(context) {\n    const result = context.result;\n    if (result instanceof HTMLElement) {\n      return Promise.resolve(context);\n    } else if (result.redirect) {\n      return this.__redirect(result.redirect, context.__redirectCount)\n        .then(context => this.__amendWithResolutionResult(context));\n    } else if (result instanceof Error) {\n      return Promise.reject(result);\n    } else {\n      return Promise.reject(\n        new Error(\n          log(\n            `Invalid route resolution result for path \"${context.pathname}\". ` +\n            `Expected redirect object or HTML element, but got: \"${result}\". ` +\n            `Double check the action return value for the route.`\n          )\n        ));\n    }\n  }\n\n  __amendWithOnBeforeCallbacks(contextWithFullChain) {\n    return this.__runOnBeforeCallbacks(contextWithFullChain).then(amendedContext => {\n      if (amendedContext === this.__previousContext || amendedContext === contextWithFullChain) {\n        return amendedContext;\n      }\n      return this.__fullyResolveChain(amendedContext);\n    });\n  }\n\n  __runOnBeforeCallbacks(newContext) {\n    const previousContext = this.__previousContext || {};\n    const previousChain = previousContext.chain || [];\n    const newChain = newContext.chain;\n\n    let callbacks = Promise.resolve();\n    const prevent = () => ({cancel: true});\n    const redirect = (pathname) => createRedirect(newContext, pathname);\n\n    newContext.__divergedChainIndex = 0;\n    if (previousChain.length) {\n      for (let i = 0; i < Math.min(previousChain.length, newChain.length); i = ++newContext.__divergedChainIndex) {\n        if (previousChain[i].route !== newChain[i].route || previousChain[i].path !== newChain[i].path) {\n          break;\n        }\n      }\n\n      for (let i = previousChain.length - 1; i >= newContext.__divergedChainIndex; i--) {\n        const location = createLocation(newContext);\n        callbacks = callbacks\n          .then(amend('onBeforeLeave', [location, {prevent}, this], previousChain[i].element))\n          .then(result => {\n            if (!(result || {}).redirect) {\n              return result;\n            }\n          });\n      }\n    }\n\n    for (let i = newContext.__divergedChainIndex; i < newChain.length; i++) {\n      const location = createLocation(newContext, newChain[i].route);\n      callbacks = callbacks.then(amend('onBeforeEnter', [location, {prevent, redirect}, this], newChain[i].element));\n    }\n\n    return callbacks.then(amendmentResult => {\n      if (amendmentResult) {\n        if (amendmentResult.cancel) {\n          return this.__previousContext;\n        }\n        if (amendmentResult.redirect) {\n          return this.__redirect(amendmentResult.redirect, newContext.__redirectCount);\n        }\n      }\n      return newContext;\n    });\n  }\n\n  __redirect(redirectData, counter) {\n    if (counter > MAX_REDIRECT_COUNT) {\n      throw new Error(log(`Too many redirects when rendering ${redirectData.from}`));\n    }\n\n    return this.resolve({\n      pathname: Router.pathToRegexp.compile(redirectData.pathname)(redirectData.params),\n      redirectFrom: redirectData.from,\n      __redirectCount: (counter || 0) + 1\n    });\n  }\n\n  __ensureOutlet(outlet = this.__outlet) {\n    if (!(outlet instanceof Node)) {\n      throw new TypeError(log(`Expected router outlet to be a valid DOM Node (but got ${outlet})`));\n    }\n  }\n\n  __updateBrowserHistory(pathname, replace) {\n    if (window.location.pathname !== pathname) {\n      const changeState = replace ? 'replaceState' : 'pushState';\n      window.history[changeState](null, document.title, pathname);\n      window.dispatchEvent(new PopStateEvent('popstate', {state: 'vaadin-router-ignore'}));\n    }\n  }\n\n  __addAppearingContent(context, previousContext) {\n    this.__ensureOutlet();\n\n    // If the previous 'entering' animation has not completed yet,\n    // stop it and remove that content from the DOM before adding new one.\n    this.__removeAppearingContent();\n\n    // Find the deepest common parent between the last and the new component\n    // chains. Update references for the unchanged elements in the new chain\n    let deepestCommonParent = this.__outlet;\n    for (let i = 0; i < context.__divergedChainIndex; i++) {\n      const unchangedElement = previousContext && previousContext.chain[i].element;\n      if (unchangedElement) {\n        if (unchangedElement.parentNode === deepestCommonParent) {\n          context.chain[i].element = unchangedElement;\n          deepestCommonParent = unchangedElement;\n        } else {\n          break;\n        }\n      }\n    }\n\n    // Keep two lists of DOM elements:\n    //  - those that should be removed once the transition animation is over\n    //  - and those that should remain\n    this.__disappearingContent = Array.from(deepestCommonParent.children);\n    this.__appearingContent = [];\n\n    // Add new elements (starting after the deepest common parent) to the DOM.\n    // That way only the components that are actually different between the two\n    // locations are added to the DOM (and those that are common remain in the\n    // DOM without first removing and then adding them again).\n    let parentElement = deepestCommonParent;\n    for (let i = context.__divergedChainIndex; i < context.chain.length; i++) {\n      const elementToAdd = context.chain[i].element;\n      if (elementToAdd) {\n        parentElement.appendChild(elementToAdd);\n        if (parentElement === deepestCommonParent) {\n          this.__appearingContent.push(elementToAdd);\n        }\n        parentElement = elementToAdd;\n      }\n    }\n  }\n\n  __removeDisappearingContent() {\n    if (this.__disappearingContent) {\n      removeDomNodes(this.__disappearingContent);\n    }\n    this.__disappearingContent = null;\n    this.__appearingContent = null;\n  }\n\n  __removeAppearingContent() {\n    if (this.__disappearingContent && this.__appearingContent) {\n      removeDomNodes(this.__appearingContent);\n      this.__disappearingContent = null;\n      this.__appearingContent = null;\n    }\n  }\n\n  __runOnAfterLeaveCallbacks(currentContext, targetContext) {\n    if (!targetContext) {\n      return;\n    }\n\n    // REVERSE iteration: from Z to A\n    for (let i = targetContext.chain.length - 1; i >= currentContext.__divergedChainIndex; i--) {\n      const currentComponent = targetContext.chain[i].element;\n      if (!currentComponent) {\n        continue;\n      }\n      try {\n        const location = createLocation(currentContext);\n        runCallbackIfPossible(\n          currentComponent.onAfterLeave,\n          [location, {}, targetContext.resolver],\n          currentComponent);\n      } finally {\n        removeDomNodes(currentComponent.children);\n      }\n    }\n  }\n\n  __runOnAfterEnterCallbacks(currentContext) {\n    // forward iteration: from A to Z\n    for (let i = currentContext.__divergedChainIndex; i < currentContext.chain.length; i++) {\n      const currentComponent = currentContext.chain[i].element || {};\n      const location = createLocation(currentContext, currentContext.chain[i].route);\n      runCallbackIfPossible(\n        currentComponent.onAfterEnter,\n        [location, {}, currentContext.resolver],\n        currentComponent);\n    }\n  }\n\n  __animateIfNeeded(context) {\n    const from = (this.__disappearingContent || [])[0];\n    const to = (this.__appearingContent || [])[0];\n    const promises = [];\n\n    const chain = context.chain;\n    let config;\n    for (let i = chain.length; i > 0; i--) {\n      if (chain[i - 1].route.animate) {\n        config = chain[i - 1].route.animate;\n        break;\n      }\n    }\n\n    if (from && to && config) {\n      const leave = isObject(config) && config.leave || 'leaving';\n      const enter = isObject(config) && config.enter || 'entering';\n      promises.push(animate(from, leave));\n      promises.push(animate(to, enter));\n    }\n\n    return Promise.all(promises).then(() => context);\n  }\n\n  /**\n   * Subscribes this instance to navigation events on the `window`.\n   *\n   * NOTE: beware of resource leaks. For as long as a router instance is\n   * subscribed to navigation events, it won't be garbage collected.\n   */\n  subscribe() {\n    window.addEventListener('vaadin-router-go', this.__navigationEventHandler);\n  }\n\n  /**\n   * Removes the subscription to navigation events created in the `subscribe()`\n   * method.\n   */\n  unsubscribe() {\n    window.removeEventListener('vaadin-router-go', this.__navigationEventHandler);\n  }\n\n  __onNavigationEvent(event) {\n    const pathname = event ? event.detail.pathname : window.location.pathname;\n    this.render(pathname, true);\n  }\n\n  /**\n   * Configures what triggers Vaadin.Router navigation events:\n   *  - `POPSTATE`: popstate events on the current `window`\n   *  - `CLICK`: click events on `<a>` links leading to the current page\n   *\n   * This method is invoked with the pre-configured values when creating a new Router instance.\n   * By default, both `POPSTATE` and `CLICK` are enabled. This setup is expected to cover most of the use cases.\n   *\n   * See the `router-config.js` for the default navigation triggers config. Based on it, you can\n   * create the own one and only import the triggers you need, instead of pulling in all the code,\n   * e.g. if you want to handle `click` differently.\n   *\n   * See also **Navigation Triggers** section in [Live Examples](#/classes/Vaadin.Router/demos/demo/index.html).\n   *\n   * @param {...NavigationTrigger} triggers\n   */\n  static setTriggers(...triggers) {\n    setNavigationTriggers(triggers);\n  }\n\n  /**\n   * Triggers navigation to a new path and returns without waiting until the\n   * navigation is complete.\n   *\n   * @param {!string} pathname a new in-app path\n   */\n  static go(pathname) {\n    fireRouterEvent('go', {pathname});\n  }\n}\n","import CLICK from './triggers/click.js';\nimport POPSTATE from './triggers/popstate.js';\nimport {Router} from './router.js';\nRouter.NavigationTrigger = {POPSTATE, CLICK};\nexport {Router};\n"]}